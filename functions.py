
import numpy as np
import matplotlib.pyplot as plt
from astropy import constants as const
from scipy.io import FortranFile
from scipy.optimize import curve_fit
from numba import jit
from numba import njit, prange
from scipy.interpolate import interp1d
from astropy.cosmology import Planck15 as cosmo
from mpl_toolkits import mplot3d
import sys
import time
import matplotlib
import f_to_py as ftp
from mpl_toolkits.axes_grid1 import make_axes_locatable
from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar
import matplotlib.font_manager as fm
#from scipy.signal import correlate
import Pk_library as PKL

import math
import jax.numpy as jnp

#import blablatest

#sys.exit()
#import jax

from scipy.stats import skew
from scipy.stats import kurtosis
from scipy.stats import norm

from lmfit.models import GaussianModel

from statsmodels.stats.weightstats import DescrStatsW

from scipy.stats import bootstrap

import random



matplotlib.rc('xtick',labelsize=16)
matplotlib.rc('ytick',labelsize=16)
plt.rcParams['font.size'] = 16
#ax.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
#ax.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)

kb = const.k_B.to_value('J/K')
mp = const.m_p.to_value('kg')
me = const.m_e.to_value('kg')
mu = 0.60
g = const.G.to_value('m3/(kg s2)')
H = 67.7699966  # hubble constant in km/s/mpc
omega_m = 0.307114988565445E+00
omega_l = 0.692884981632233E+00
omega_k = 0.298023223876953E-07
omega_b = 0.450000017881393E-01
omega_c = omega_m - omega_b
c = const.c.to_value('m/s')
pc = const.pc.to_value('m')
rho_c = ((3 * (H * (1E3 / (pc * 1E6))) ** 2) / (8 * np.pi * g))
m_sun = const.M_sun.to_value('kg')
kev = 1.602176634e-16

unit_l = 0.227550518265197E+28
unit_d = 0.264088847033921E-29
unit_t = 0.455724529603677E+18


def hydro(file, t_cut, mean_med,log_before,n):
    print('hydro')
    print(file)
    h = FortranFile(file, 'r')

    ncell = h.read_ints()
    #nline = h.read_ints()
    #nline=[1,1]
    #nline=int(nline[0])
    print("ncell", ncell)

    #sys.exit()
    #print("nline",nline)
    #ncell=np.fromfile(file,dtype=np.int)
    #print("ncell",ncell)
    #n_e=np.fromfile(file,dtype=np.float64)
    #print("ne",n_e)
    #sys.exit()
    n_e = []
    #print("ne",n_e)

    #for i in range(0,nline):
    n_e = h.read_reals()
        #n_e=np.concatenate((n_e,n_e_line))
        #print("len ne",len(n_e))

    #plt.hist(n_e, bins=100)
    #plt.xscale('log')
    #plt.yscale('log')
    #plt.show()
    #sys.exit()

    print("t")
    t = []
    #for i in range(0, nline):
    t = h.read_reals()
        #t = np.concatenate((t, t_line))

    #plt.hist(t,bins=100)
    #plt.xscale('log')
    #plt.yscale('log')
    #plt.show()
    #sys.exit()

    print("p")
    p = []
    #for i in range(0, nline):
    p = h.read_reals()
        #p = np.concatenate((p, p_line))

    #plt.hist(p, bins=100)
    #plt.xscale('log')
    #plt.yscale('log')
    #plt.show()
    #sys.exit()

    print("x")
    x = []
    #for i in range(0, nline):
    x = h.read_reals()
    #x = np.concatenate((x, x_line))

    #print("x len",len(x))
    #print("xmin",np.min(x))
    #print("xmax",np.max(x))

    #print("hist x")

    #plt.hist(x, bins=100)
    #plt.show()

    #sys.exit()

    print('y')
    y = []
    #for i in range(0, nline):
    y = h.read_reals()
    #    y = np.concatenate((y, y_line))

    #print("ymin", np.min(y))
    #print("ymax", np.max(y))

    #ys.exit()


    print("z")
    z = []
    #for i in range(0, nline):
    z = h.read_reals()
    #    z = np.concatenate((z, z_line))

    #plt.hist(z, bins=100)
    #plt.show()
    #sys.exit()

    #print("zmin", np.min(z))
    #print("zmax", np.max(z))

    #sys.exit()

    print("vx")
    vx = []
    #for i in range(0, nline):
    vx = h.read_reals()
    #    vx = np.concatenate((vx, vx_line))

    print("vy")
    vy = []
    #for i in range(0, nline):
    vy = h.read_reals()
    #   vy = np.concatenate((vy, vy_line))

    print("vz")
    vz = []
    #for i in range(0, nline):
    vz = h.read_reals()
    #    vz = np.concatenate((vz, vz_line))

    def vel_comp_3D_hist(x,y,z,vx,vy,vz):

        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        # print("x_cen", x_cen, "y_cen", y_cen, "z_cen", z_cen)

        r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)

        vx_virgo = -509.1301
        vy_virgo = 228.9488
        vz_virgo = -131.9249

        vz-=vz_virgo
        vy-=vy_virgo
        vx-=vx_virgo



        #plt.hist(vz[r<2500],bins=100)
        #plt.show()
        #sys.exit()

        def gauss(x, A, mu, sigma):
            return A * norm.pdf(x, mu, sigma)
        def gaussian_fit(data,count,bins):

            # Bin centers for fitting
            bin_centers = (bins[:-1] + bins[1:]) / 2

            # Define Gaussian function

            model= GaussianModel()

            params = model.make_params(amplitude=1, center=np.mean(data), sigma=np.std(data))
            result = model.fit(count, params, x=bin_centers)

            print(result.fit_report())

            #print("best values",result.best_values)
            #print("best fit",result.best_fit)
            #print("red chi2",result.redchi)

            amplitude_best = result.params['amplitude'].value
            amplitude_error = result.params['amplitude'].stderr

            center_best = result.params['center'].value
            center_error = result.params['center'].stderr

            sigma_best = result.params['sigma'].value
            sigma_error = result.params['sigma'].stderr

            height_best = result.params['height'].value
            height_error = result.params['height'].stderr

            chi2 = result.chisqr
            red_chi2 = result.redchi

            popt=[amplitude_best,center_best,sigma_best,height_best]
            errors=[amplitude_error,center_error,sigma_error,height_error]

            #sys.exit()



            # Initial guesses: amplitude, mean, std
            #p0 = [0.015, np.mean(data), np.std(data)]

            # Perform the fit
            #popt, pcov = curve_fit(gauss, bin_centers, count, p0=p0)



            # Extract fitted parameters and their errors from the covariance matrix
            #A_fit, mu_fit, sigma_fit = popt
            #errors = np.sqrt(np.diag(pcov))

            #print(f'Fit results: A = {A_fit:.3g} ± {errors[0]:.3g}, '
            #      f'mean = {mu_fit:.3g} ± {errors[1]:.3g}, '
            #      f'std = {sigma_fit:.3g} ± {errors[2]:.3g}')

            #expected = gauss(bin_centers, *popt)
            #chi2 = np.sum((count - expected) ** 2 / expected)
            #dof = len(count) - len(popt)

            #print(f'Chi-square: {chi2:.3g}')
            #print(f'Reduced Chi-square: {chi2 / dof:.3g}')

            #red_chi2= chi2/dof

            #normalisation = A_fit/(np.sqrt(2*np.pi)*sigma_fit)
            #normalisation_error = (1/(np.sqrt(2*np.pi)*sigma_fit))*np.sqrt(errors[0]**2+((-A_fit*errors[2])/sigma_fit)**2)

            #print("normalisation",normalisation,"±",normalisation_error)

            return popt, errors, chi2, red_chi2,bin_centers
            #sys.exit()

        large=1

        def velocity_components_hist(x,y,z,vx,vy,vz,large):

            f, axs = plt.subplots(3, 4, figsize=(20, 8), constrained_layout=True)

            if large==1:
                r1 = 2147
                r2 = 1087
                plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
                pdfrvir= "PDF ($R<R_{vir}$)"
                pdfr500= "PDF ($R<R_{500}$)"
                height= 0.0017

            if large == 0:
                r1 = 500
                r2 = 100
                plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
                pdfrvir = "PDF ($R<500 kpc$)"
                pdfr500 = "PDF ($R<100 kpc$)"
                height = 0.0035

            vx_r1 = vx[r < r1]
            vy_r1 = vy[r < r1]
            vz_r1 = vz[r < r1]

            print("nbr of cells with T<10^7K",len(vx_r1[t[r<r1]<1e7]),"ratio",len(vx_r1[t[r<r1]<1e7])/len(vx_r1))

            vx_r1 = vx_r1[t[r<r1]<1e7]

            #sys.exit()

            # meanvx,stdvx = norm.fit(vx_r1)
            # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

            print(
                f"vx_r1 stat: mean={np.mean(vx_r1):.4g}, "f"median={np.median(vx_r1):.4g}, "f"std={np.std(vx_r1):.4g}, "f"skewness={skew(vx_r1):.4g}, "f"kurtosis={kurtosis(vx_r1):.4g}")

            # sys.exit()

            print(
                f"vy_r1 stat: mean={np.mean(vy_r1):.4g}, "f"median={np.median(vy_r1):.4g}, "f"std={np.std(vy_r1):.4g}, "f"skewness={skew(vy_r1):.4g}, "f"kurtosis={kurtosis(vy_r1):.4g}")
            print(
                f"vz_r1 stat: mean={np.mean(vz_r1):.4g}, "f"median={np.median(vz_r1):.4g}, "f"std={np.std(vz_r1):.4g}, "f"skewness={skew(vz_r1):.4g}, "f"kurtosis={kurtosis(vz_r1):.4g}")

            vx_r2 = vx[r < r2]
            vy_r2 = vy[r < r2]
            vz_r2 = vz[r < r2]

            print(
                f"vx_r2 stat: mean={np.mean(vx_r2):.4g}, "f"median={np.median(vx_r2):.4g}, "f"std={np.std(vx_r2):.4g}, "f"skewness={skew(vx_r2):.4g}, "f"kurtosis={kurtosis(vx_r2):.4g}")
            print(
                f"vy_r2 stat: mean={np.mean(vy_r2):.4g}, "f"median={np.median(vy_r2):.4g}, "f"std={np.std(vy_r2):.4g}, "f"skewness={skew(vy_r2):.4g}, "f"kurtosis={kurtosis(vy_r2):.4g}")
            print(
                f"vz_r2 stat: mean={np.mean(vz_r2):.4g}, "f"median={np.median(vz_r2):.4g}, "f"std={np.std(vz_r2):.4g}, "f"skewness={skew(vz_r2):.4g}, "f"kurtosis={kurtosis(vz_r2):.4g}")

            count, bins, _ =axs[0, 0].hist(vx[r<r1], bins=20, alpha=0.6, color='red',density=True)

            #print("count",count)
            #sys.exit()

            popt,errors,chi2, red_chi2 = gaussian_fit(vx[r<r1],count,bins)
            axs[0, 0].plot(bins,gauss(bins,*popt[0:3]) , color='black', label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(popt[1],errors[1],popt[2],errors[2],popt[3], errors[3], chi2, red_chi2))

            # axs[0,0].yscale('log')
            axs[0, 0].set_xlim(-1900, 1900)
            axs[0, 0].set_ylim(0, height)
            #axs[0, 0].set_ylim(0, 1.2e6)
            # axs[0,0].legend(fontsize=10)
            #axs[0, 0].set_title("$V_x$")
            # axs[0,0].set_xlabel("Vx [km/s]")
            #axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
            axs[0, 0].set_ylabel(pdfrvir)
            axs[0, 0].set_xticks([])
            axs[0,0].legend(fontsize=10)

            count, bins, _ = axs[0, 1].hist(vy[r<r1], bins=20, alpha=0.6, color='blue', density=True)

            popt,errors,chi2, red_chi2 = gaussian_fit(vy[r<r1],count,bins)
            axs[0, 1].plot(bins,gauss(bins,*popt[0:3]) , color='black', label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(popt[1],errors[1],popt[2],errors[2],popt[3], errors[3], chi2, red_chi2))


            # xs[0,1].yscale('log')
            axs[0, 1].set_xlim(-1900, 1900)
            axs[0, 1].set_ylim(0, height)
            #axs[0, 1].set_ylim(0, 1.2e6)
            # axs[0,1].legend(fontsize=10)
            #axs[0, 1].set_title("y component")
            axs[0, 1].set_yticks([])
            # axs[0,1].set_xlabel("Vy [km/s]")
            axs[0, 1].set_xticks([])
            axs[0, 1].legend(fontsize=10)

            count, bins, _ = axs[0, 2].hist(vz[r<r1], bins=20, alpha=0.6, color='green',density=True)

            popt,errors,chi2, red_chi2 = gaussian_fit(vz[r<r1],count,bins)
            axs[0, 2].plot(bins,gauss(bins,*popt[0:3]) , color='black', label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(popt[1],errors[1],popt[2],errors[2],popt[3], errors[3], chi2, red_chi2))



            # axs[0,2].yscale('log')
            axs[0, 2].set_xlim(-1900, 1900)
            axs[0, 2].set_ylim(0, height)
            #axs[0, 2].set_ylim(0, 1.2e6)
            # axs[0,2].legend(fontsize=10)
            #axs[0, 2].set_title("z projection")
            # axs[0,2].set_xlabel("Vz [km/s]")
            axs[0, 2].set_yticks([])
            axs[0, 2].set_xticks([])
            axs[0, 2].legend(fontsize=10)

            axs[0, 3].hist(vx[r<r1], bins=20, alpha=0.6, color='red', label='$V_x$',density=True)
            axs[0, 3].hist(vy[r<r1], bins=20, alpha=0.6, color='blue', label='$V_y$',density=True)
            axs[0, 3].hist(vz[r<r1], bins=20, alpha=0.6, color='green', label='$V_z$',density=True)
            axs[0, 3].set_xlim(-1900, 1900)
            axs[0, 3].set_ylim(0, height)
            #axs[0, 3].set_ylim(0, 1.2e6)
            axs[0, 3].set_yticks([])
            axs[0, 3].set_xticks([])
            axs[0, 3].legend(fontsize=10)

            #plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            count, bins, _ = axs[1, 0].hist(vx[r<r2], bins=20, alpha=0.6, color='red',density=True)

            popt, errors, chi2, red_chi2 = gaussian_fit(vx[r < r2], count, bins)
            axs[1, 0].plot(bins, gauss(bins, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))


            # axs[1,0].yscale('log')
            axs[1, 0].set_xlim(-1900, 1900)
            axs[1, 0].set_ylim(0, height)
            #axs[1, 0].set_ylim(0, 1.3e4)
            # axs[1,0].legend(fontsize=10)
            # axs[1,0].set_title("x projection")
            # axs[1,0].set_xlabel("Vx [km/s]")
            #axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
            axs[1, 0].set_ylabel(pdfr500)
            axs[1, 0].set_xticks([])
            axs[1, 0].legend(fontsize=10)

            count, bins, _ = axs[1, 1].hist(vy[r<r2], bins=20, alpha=0.6, color='blue',density=True)

            popt, errors, chi2, red_chi2 = gaussian_fit(vy[r < r2], count, bins)
            axs[1, 1].plot(bins, gauss(bins, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))


            # xs[1,1].yscale('log')
            axs[1, 1].set_xlim(-1900, 1900)
            axs[1, 1].set_ylim(0, height)
            #axs[1, 1].set_ylim(0, 1.3e4)
            # axs[1,1].legend(fontsize=10)
            # axs[1,1].set_title("y projection")
            axs[1, 1].set_yticks([])
            # axs[1,1].set_xlabel("Vy [km/s]")
            axs[1, 1].set_xticks([])
            axs[1, 1].legend(fontsize=10)

            count, bins, _ = axs[1, 2].hist(vz[r<r2], bins=20, alpha=0.6, color='green',density=True)

            popt, errors, chi2, red_chi2 = gaussian_fit(vz[r < r2], count, bins)
            axs[1, 2].plot(bins, gauss(bins, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[1,2].yscale('log')
            axs[1, 2].set_xlim(-1900, 1900)
            axs[1, 2].set_ylim(0, height)
            #axs[1, 2].set_ylim(0, 1.3e4)
            # axs[1,2].legend(fontsize=10)
            # axs[1,2].set_title("z projection")
            # axs[1,2].set_xlabel("Vz [km/s]")
            axs[1, 2].set_yticks([])
            axs[1, 2].set_xticks([])
            axs[1, 2].legend(fontsize=10)

            axs[1, 3].hist(vx[r<r2], bins=20, alpha=0.6, color='red', label='$V_x$',density=True)
            axs[1, 3].hist(vy[r<r2], bins=20, alpha=0.6, color='blue', label='$V_y$',density=True)
            axs[1, 3].hist(vz[r<r2], bins=20, alpha=0.6, color='green', label='$V_z$',density=True)
            axs[1, 3].set_xlim(-1900, 1900)
            axs[1, 3].set_ylim(0, height)
            #axs[1, 3].set_ylim(0, 1.3e4)
            axs[1, 3].set_yticks([])
            axs[1, 3].legend(fontsize=10)
            #plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            axs[2, 0].hist(vx[r<r1], bins=20, alpha=0.6, color='red', label='$R<R_{vir}$',density=True)
            axs[2, 0].hist(vx[r<r2], bins=20, alpha=0.6, color='darkred', label='$R<R_{500}$',density=True)
            # axs[2,0].yscale('log')
            axs[2, 0].set_xlim(-1900, 1900)
            axs[2, 0].set_ylim(0, height)
            # axs[2, 0].set_ylim(0, 700)
            # axs[2,0].legend(fontsize=10)
            # axs[2,0].set_title("x projection")
            axs[2, 0].set_xlabel("Vx [km/s]")
            axs[2, 0].set_ylabel("PDF")
            axs[2, 0].legend(fontsize=10)
            #axs[2, 0].set_yscale('log')

            axs[2, 1].hist(vy[r<r1], bins=20, alpha=0.6, color='blue', label='$R<R_{vir}$',density=True)
            axs[2, 1].hist(vy[r<r2], bins=20, alpha=0.6, color='darkblue', label='$R<R_{500}$',density=True)
            # xs[2,1].yscale('log')
            axs[2, 1].set_xlim(-1900, 1900)
            axs[2,1].set_ylim(0, height)
            # axs[2, 1].set_ylim(0, 700)
            # axs[2,1].legend(fontsize=10)
            # axs[2,1].set_title("y projection")
            axs[2, 1].set_yticks([])
            axs[2, 1].set_xlabel("Vy [km/s]")
            axs[2, 1].legend(fontsize=10)
            #axs[2, 1].set_yscale('log')

            axs[2, 2].hist(vz[r<r1], bins=20, alpha=0.6, color='green', label='$R<R_{vir}$',density=True)
            axs[2, 2].hist(vz[r<r2], bins=20, alpha=0.6, color='darkgreen', label='$R<R_{500}$',density=True)
            # axs[2,2].yscale('log')
            axs[2, 2].set_xlim(-1900, 1900)
            axs[2, 2].set_ylim(0, height)
            # axs[2, 2].set_ylim(0, 700)
            # axs[2,2].legend(fontsize=10)
            # axs[2,2].set_title("z projection")
            axs[2, 2].set_xlabel("Vz [km/s]")
            axs[2, 2].set_yticks([])
            axs[2, 2].legend(fontsize=10)
            #axs[2, 2].set_yscale('log')

            # axs[3].yscale('log')

            # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
            # plt.grid(b=None)
            plt.legend()
            # plt.ylabel("PDF")
            axs[1,3].set_xlabel("V [km/s]")

            axs[2,3].axis("off")

            # plt.yscale('log')
            # plt.title("Vz distribution on ew sightline velocity along z axis")
             # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

            plt.show()

            sys.exit()

        def velocity_components_hist_5x4(x,y,z,vx,vy,vz,large):
            f, axs = plt.subplots(5, 4, figsize=(20, 8), constrained_layout=True)

            if large == 1:
                r1 = 2147
                r2 = 1087
                plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
                pdfrvir = "PDF \n ($R<R_{vir}$)"
                pdfr500 = "PDF \n ($R<R_{500}$)"
                height = 0.0017
                #height = 0.0035

            if large == 0:
                r1 = 500
                r2 = 100
                plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
                pdfrvir = "PDF \n ($R<500\,\mathrm{kpc}$)"
                pdfr500 = "PDF \n ($R<100$ kpc)"
                height = 0.0035

            vx_r1 = vx[r < r1]
            vy_r1 = vy[r < r1]
            vz_r1 = vz[r < r1]

            #print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

            #vx_r1 = vx_r1[t[r < r1] < 1e7]

            # meanvx,stdvx = norm.fit(vx_r1)
            # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

            print(
                f"vx_r1 stat: mean={np.mean(vx_r1):.4g}, "f"median={np.median(vx_r1):.4g}, "f"std={np.std(vx_r1):.4g}, "f"skewness={skew(vx_r1):.4g}, "f"kurtosis={kurtosis(vx_r1):.4g}")

            # sys.exit()

            print(
                f"vy_r1 stat: mean={np.mean(vy_r1):.4g}, "f"median={np.median(vy_r1):.4g}, "f"std={np.std(vy_r1):.4g}, "f"skewness={skew(vy_r1):.4g}, "f"kurtosis={kurtosis(vy_r1):.4g}")
            print(
                f"vz_r1 stat: mean={np.mean(vz_r1):.4g}, "f"median={np.median(vz_r1):.4g}, "f"std={np.std(vz_r1):.4g}, "f"skewness={skew(vz_r1):.4g}, "f"kurtosis={kurtosis(vz_r1):.4g}")

            vx_r2 = vx[r < r2]
            vy_r2 = vy[r < r2]
            vz_r2 = vz[r < r2]

            print(
                f"vx_r2 stat: mean={np.mean(vx_r2):.4g}, "f"median={np.median(vx_r2):.4g}, "f"std={np.std(vx_r2):.4g}, "f"skewness={skew(vx_r2):.4g}, "f"kurtosis={kurtosis(vx_r2):.4g}")
            print(
                f"vy_r2 stat: mean={np.mean(vy_r2):.4g}, "f"median={np.median(vy_r2):.4g}, "f"std={np.std(vy_r2):.4g}, "f"skewness={skew(vy_r2):.4g}, "f"kurtosis={kurtosis(vy_r2):.4g}")
            print(
                f"vz_r2 stat: mean={np.mean(vz_r2):.4g}, "f"median={np.median(vz_r2):.4g}, "f"std={np.std(vz_r2):.4g}, "f"skewness={skew(vz_r2):.4g}, "f"kurtosis={kurtosis(vz_r2):.4g}")

            count, bins, _ = axs[0, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='darkred', density=True)

            # print("count",count)
            # sys.exit()

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r1], count, bins)
            axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[0,0].yscale('log')
            axs[0, 0].set_xlim(-1600, 1600)
            axs[0, 0].set_ylim(1e-5, height)
            # axs[0, 0].set_ylim(0, 1.2e6)
            # axs[0,0].legend(fontsize=10)
            # axs[0, 0].set_title("$V_x$")
            # axs[0,0].set_xlabel("Vx [km/s]")
            # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
            axs[0, 0].set_ylabel(pdfrvir)
            axs[0, 0].set_xticks([])
            axs[0, 0].set_yscale('log')
            #axs[0, 0].legend(fontsize=10)
            #axs[0,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='solid')


            count, bins, _ = axs[0, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='darkblue', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r1], count, bins)
            axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[0,1].yscale('log')
            axs[0, 1].set_xlim(-1600, 1600)
            axs[0, 1].set_ylim(1e-5, height)
            # axs[0, 1].set_ylim(0, 1.2e6)
            # axs[0,1].legend(fontsize=10)
            # axs[0, 1].set_title("y component")
            axs[0, 1].set_yticks([])
            # axs[0,1].set_xlabel("Vy [km/s]")
            axs[0, 1].set_xticks([])
            axs[0, 1].set_yscale('log')
            #axs[0, 1].legend(fontsize=10)
            axs[0, 1].yaxis.set_visible(False)
            #axs[0, 1].axvline(x=np.mean(vy[r < r1]), color='black', linestyle='solid')

            count, bins, _ = axs[0, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='darkgreen', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r1], count, bins)
            axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[0,2].yscale('log')
            axs[0, 2].set_xlim(-1600, 1600)
            axs[0, 2].set_ylim(1e-5, height)
            # axs[0, 2].set_ylim(0, 1.2e6)
            # axs[0,2].legend(fontsize=10)
            # axs[0, 2].set_title("z projection")
            # axs[0,2].set_xlabel("Vz [km/s]")
            axs[0, 2].set_yticks([])
            axs[0, 2].set_xticks([])
            axs[0, 2].set_yscale('log')
            #axs[0, 2].legend(fontsize=10)
            axs[0, 2].yaxis.set_visible(False)
            #axs[0, 2].axvline(x=np.mean(vz[r < r1]), color='black', linestyle='solid')

            axs[0, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='darkred', label='$V_x$', density=True)
            axs[0, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='darkblue', label='$V_y$', density=True)
            axs[0, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='darkgreen', label='$V_z$', density=True)
            axs[0, 3].set_xlim(-1600, 1600)
            axs[0, 3].set_ylim(1e-5, height)
            # axs[0, 3].set_ylim(0, 1.2e6)
            axs[0, 3].set_yticks([])
            axs[0, 3].set_xticks([])
            axs[0, 3].set_yscale('log')
            #axs[0, 3].legend(fontsize=10)
            axs[0, 3].yaxis.set_visible(False)
            #axs[0, 3].axvline(x=np.mean(vx[r < r1]), color='red', linestyle='solid')
            #axs[0, 3].axvline(x=np.mean(vy[r < r1]), color='blue', linestyle='solid')
            #axs[0, 3].axvline(x=np.mean(vz[r < r1]), color='green', linestyle='solid')


            # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            count, bins, _ = axs[1, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='red', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r2], count, bins)
            axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[1,0].yscale('log')
            axs[1, 0].set_xlim(-1600, 1600)
            axs[1, 0].set_ylim(1e-5, height)
            # axs[1, 0].set_ylim(0, 1.3e4)
            # axs[1,0].legend(fontsize=10)
            # axs[1,0].set_title("x projection")
            # axs[1,0].set_xlabel("Vx [km/s]")
            # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
            axs[1, 0].set_ylabel(pdfr500)
            axs[1, 0].set_xticks([])
            axs[1, 0].set_yscale('log')
            #axs[1, 0].legend(fontsize=10)
            #axs[1,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashed')

            count, bins, _ = axs[1, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r2], count, bins)
            axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[1,1].yscale('log')
            axs[1, 1].set_xlim(-1600, 1600)
            axs[1, 1].set_ylim(1e-5, height)
            # axs[1, 1].set_ylim(0, 1.3e4)
            # axs[1,1].legend(fontsize=10)
            # axs[1,1].set_title("y projection")
            axs[1, 1].set_yticks([])
            # axs[1,1].set_xlabel("Vy [km/s]")
            axs[1, 1].set_xticks([])
            axs[1, 1].set_yscale('log')
            #axs[1, 1].legend(fontsize=10)
            axs[1, 1].yaxis.set_visible(False)
            #axs[1, 1].axvline(x=np.mean(vy[r < r2]), color='black', linestyle='dashed')

            count, bins, _ = axs[1, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='green', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r2], count, bins)
            axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[1,2].yscale('log')
            axs[1, 2].set_xlim(-1600, 1600)
            axs[1, 2].set_ylim(1e-5, height)
            # axs[1, 2].set_ylim(0, 1.3e4)
            # axs[1,2].legend(fontsize=10)
            # axs[1,2].set_title("z projection")
            # axs[1,2].set_xlabel("Vz [km/s]")
            axs[1, 2].set_yticks([])
            axs[1, 2].set_xticks([])
            axs[1, 2].set_yscale('log')
            #axs[1, 2].legend(fontsize=10)
            axs[1, 2].yaxis.set_visible(False)
            #axs[1, 2].axvline(x=np.mean(vz[r < r2]), color='black', linestyle='dashed')

            axs[1, 3].hist(vx[r < r2], bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
            axs[1, 3].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
            axs[1, 3].hist(vz[r < r2], bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
            axs[1, 3].set_xlim(-1600, 1600)
            axs[1, 3].set_ylim(1e-5, height)
            # axs[1, 3].set_ylim(0, 1.3e4)
            axs[1, 3].set_yticks([])
            axs[1, 3].set_xticks([])
            axs[1, 3].set_yscale('log')
            #axs[1, 3].legend(fontsize=10)
            axs[1, 3].yaxis.set_visible(False)
            #axs[1, 3].axvline(x=np.mean(vx[r < r2]), color='red', linestyle='dashed')
            #axs[1, 3].axvline(x=np.mean(vy[r < r2]), color='blue', linestyle='dashed')
            #axs[1, 3].axvline(x=np.mean(vz[r < r2]), color='green', linestyle='dashed')
            # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            ########################################
            ########################################

            large=0

            if large == 0:
                r1 = 500
                r2 = 100
                plt.suptitle("Velocity components PDFs within spheres of 500kpc and 100kpc radii")
                pdfrvir = "PDF \n ($R<500\,\mathrm{kpc}$)"
                pdfr500 = "PDF \n ($R<100\,\mathrm{kpc}$)"
                height1 = 0.002
                height = 0.0035

            vx_r1 = vx[r < r1]
            vy_r1 = vy[r < r1]
            vz_r1 = vz[r < r1]

            vx_r2 = vx[r < r2]
            vy_r2 = vy[r < r2]
            vz_r2 = vz[r < r2]

            count, bins, _ = axs[2, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', density=True)

            # print("count",count)
            # sys.exit()

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r1], count, bins)
            axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[2,0].yscale('log')
            axs[2, 0].set_xlim(-1600, 1600)
            axs[2, 0].set_ylim(1e-5, height1)
            # axs[2, 0].set_ylim(0, 1.2e6)
            # axs[2,0].legend(fontsize=10)
            # axs[2, 0].set_title("$V_x$")
            # axs[2,0].set_xlabel("Vx [km/s]")
            # axs[2, 0].set_ylabel("PDF ($R<R_{vir}$)")
            axs[2, 0].set_ylabel(pdfrvir)
            axs[2, 0].set_xticks([])
            axs[2, 0].set_yscale('log')
            # axs[2, 0].legend(fontsize=10)
            #axs[2,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='dotted')

            count, bins, _ = axs[2, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r1], count, bins)
            axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[2,1].yscale('log')
            axs[2, 1].set_xlim(-1600, 1600)
            axs[2, 1].set_ylim(1e-5, height1)
            # axs[2, 1].set_ylim(0, 1.2e6)
            # axs[2,1].legend(fontsize=10)
            # axs[2, 1].set_title("y component")
            axs[2, 1].set_yticks([])
            # axs[2,1].set_xlabel("Vy [km/s]")
            axs[2, 1].set_xticks([])
            axs[2, 1].set_yscale('log')
            # axs[2, 1].legend(fontsize=10)
            axs[2, 1].yaxis.set_visible(False)
            #axs[2, 1].axvline(x=np.mean(vy[r < r1]), color='black', linestyle='dotted')

            count, bins, _ = axs[2, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r1], count, bins)
            axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[2,2].yscale('log')
            axs[2, 2].set_xlim(-1600, 1600)
            axs[2, 2].set_ylim(1e-5, height1)
            # axs[2, 2].set_ylim(0, 1.2e6)
            # axs[2,2].legend(fontsize=10)
            # axs[2, 2].set_title("z projection")
            # axs[2,2].set_xlabel("Vz [km/s]")
            axs[2, 2].set_yticks([])
            axs[2, 2].set_xticks([])
            axs[2, 2].set_yscale('log')
            # axs[2, 2].legend(fontsize=10)
            axs[2, 2].yaxis.set_visible(False)
            #axs[2, 2].axvline(x=np.mean(vz[r < r1]), color='black', linestyle='dotted')

            axs[2, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', label='$V_x$', density=True)
            axs[2, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', label='$V_y$', density=True)
            axs[2, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', label='$V_z$', density=True)
            axs[2, 3].set_xlim(-1600, 1600)
            axs[2, 3].set_ylim(1e-5, height1)
            # axs[2, 3].set_ylim(0, 1.2e6)
            axs[2, 3].set_yticks([])
            axs[2, 3].set_xticks([])
            axs[2, 3].set_yscale('log')
            #axs[2, 3].legend(fontsize=10)
            axs[2, 3].yaxis.set_visible(False)
            #axs[2, 3].axvline(x=np.mean(vx[r < r1]), color='red', linestyle='dotted')
            #axs[2, 3].axvline(x=np.mean(vy[r < r1]), color='blue', linestyle='dotted')
            #axs[2, 3].axvline(x=np.mean(vz[r < r1]), color='green', linestyle='dotted')

            # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[2, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            count, bins, _ = axs[3, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r2], count, bins)
            axs[3, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[3,0].yscale('log')
            axs[3, 0].set_xlim(-1600, 1600)
            axs[3, 0].set_ylim(1e-5, height)
            # axs[3, 0].set_ylim(0, 1.3e4)
            # axs[3,0].legend(fontsize=10)
            # axs[3,0].set_title("x projection")
            # axs[3,0].set_xlabel("Vx [km/s]")
            # axs[3, 0].set_ylabel("PDF ($R<R_{500}$)")
            axs[3, 0].set_ylabel(pdfr500)
            axs[3, 0].set_xticks([])
            axs[3, 0].set_yscale('log')
            # axs[3, 0].legend(fontsize=10)
            #axs[3,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashdot')

            count, bins, _ = axs[3, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r2], count, bins)
            axs[3, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[3,1].yscale('log')
            axs[3, 1].set_xlim(-1600, 1600)
            axs[3, 1].set_ylim(1e-5, height)
            # axs[3, 1].set_ylim(0, 1.3e4)
            # axs[3,1].legend(fontsize=10)
            # axs[3,1].set_title("y projection")
            axs[3, 1].set_yticks([])
            # axs[3,1].set_xlabel("Vy [km/s]")
            axs[3, 1].set_xticks([])
            axs[3, 1].set_yscale('log')
            # axs[3, 1].legend(fontsize=10)
            axs[3, 1].yaxis.set_visible(False)
            #axs[3, 1].axvline(x=np.mean(vy[r < r2]), color='black', linestyle='dashdot')


            count, bins, _ = axs[3, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r2], count, bins)
            axs[3, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[3,2].yscale('log')
            axs[3, 2].set_xlim(-1600, 1600)
            axs[3, 2].set_ylim(1e-5, height)
            # axs[3, 2].set_ylim(0, 1.3e4)
            # axs[3,2].legend(fontsize=10)
            # axs[3,2].set_title("z projection")
            # axs[3,2].set_xlabel("Vz [km/s]")
            axs[3, 2].set_yticks([])
            axs[3, 2].set_xticks([])
            axs[3, 2].set_yscale('log')
            # axs[3, 2].legend(fontsize=10)
            axs[3, 2].yaxis.set_visible(False)
            #axs[3, 2].axvline(x=np.mean(vz[r < r2]), color='black', linestyle='dashdot')

            axs[3, 3].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', label='$V_x$', density=True)
            axs[3, 3].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', label='$V_y$', density=True)
            axs[3, 3].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', label='$V_z$', density=True)
            axs[3, 3].set_xlim(-1600, 1600)
            axs[3, 3].set_ylim(1e-5, height)
            # axs[3, 3].set_ylim(0, 1.3e4)
            axs[3, 3].set_yticks([])
            axs[3, 3].set_xticks([])
            #axs[3, 3].legend(fontsize=10)
            axs[3, 3].set_yscale('log')
            axs[3, 3].yaxis.set_visible(False)
            #axs[3, 3].axvline(x=np.mean(vx[r < r2]), color='red', linestyle='dashdot')
            #axs[3, 3].axvline(x=np.mean(vy[r < r2]), color='blue', linestyle='dashdot')
            #axs[3, 3].axvline(x=np.mean(vz[r < r2]), color='green', linestyle='dashdot')
            # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[3, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)



            ########################################
            ########################################

            rvir=2147
            r500=1087

            axs[4, 0].hist(vx[r < rvir], bins=20, alpha=0.6, color='darkred', label='$R<R_{vir}$', density=True)#,histtype='step',linewidth=2)
            axs[4, 0].hist(vx[r < r500], bins=20, alpha=0.6, color='red', label='$R<R_{500}$', density=True)#,histtype='step',linewidth=2)
            axs[4, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', label='$R<500kpc$', density=True)#,histtype='step',linewidth=2)
            axs[4, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', label='$R<100kpc$', density=True)#,histtype='step',linewidth=2)
            # axs[4,0].yscale('log')
            axs[4, 0].set_xlim(-1600, 1600)
            axs[4, 0].set_ylim(1e-5, height)
            # axs[4, 0].set_ylim(0, 700)
            # axs[4,0].legend(fontsize=10)
            # axs[4,0].set_title("x projection")
            axs[4, 0].set_xlabel("$v_{x}~[\mathrm{km~s^{-1}}]$")
            axs[4, 0].set_ylabel("PDF")
            axs[4, 0].set_yscale('log')
            #axs[4,0].axvline(x=np.mean(vx[r<rvir]), color='black', linestyle='solid')
            #axs[4,0].axvline(x=np.mean(vx[r<r500]), color='black', linestyle='dashed')
            #axs[4,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='dotted')
            #axs[4,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashdot')
            #axs[4, 0].legend(fontsize=10)
            # axs[4, 0].set_yscale('log')

            axs[4, 1].hist(vy[r < rvir], bins=20, alpha=0.6, color='darkblue', label='$R<R_{vir}$', density=True)#,histtype='step',linewidth=2)
            axs[4, 1].hist(vy[r < r500], bins=20, alpha=0.6, color='blue', label='$R<R_{500}$', density=True)#,histtype='step',linewidth=2)
            axs[4, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', label='$R<500kpc$', density=True)#,histtype='step',linewidth=2)
            axs[4, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', label='$R<100kpc$', density=True)#,histtype='step',linewidth=2)
            # xs[4,1].yscale('log')
            axs[4, 1].set_xlim(-1600, 1600)
            axs[4, 1].set_ylim(1e-5, height)
            # axs[4, 1].set_ylim(0, 700)
            # axs[4,1].legend(fontsize=10)
            # axs[4,1].set_title("y projection")
            axs[4, 1].set_yticks([])
            axs[4, 1].set_xlabel("$v_{y}~[\mathrm{km~s^{-1}}]$")
            axs[4, 1].set_yscale('log')
            #axs[4,1].axvline(x=np.mean(vy[r<rvir]), color='black', linestyle='solid')
            #axs[4,1].axvline(x=np.mean(vy[r<r500]), color='black', linestyle='dashed')
            #axs[4,1].axvline(x=np.mean(vy[r<r1]), color='black', linestyle='dotted')
            #axs[4,1].axvline(x=np.mean(vy[r<r2]), color='black', linestyle='dashdot')
            #axs[4, 1].legend(fontsize=10)
            # axs[4, 1].set_yscale('log')
            axs[4, 1].yaxis.set_visible(False)

            axs[4, 2].hist(vz[r < rvir], bins=20, alpha=0.6, color='darkgreen', label='$R<R_{vir}$', density=True)#,histtype='step',linewidth=2)
            axs[4, 2].hist(vz[r < r500], bins=20, alpha=0.6, color='green', label='$R<R_{500}$', density=True)#,histtype='step',linewidth=2)
            axs[4, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', label='$R<500kpc$', density=True)#,histtype='step',linewidth=2)
            axs[4, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', label='$R<100kpc$', density=True)#,histtype='step',linewidth=2)
            # axs[4,2].yscale('log')
            axs[4, 2].set_xlim(-1600, 1600)
            axs[4, 2].set_ylim(1e-5, height)
            # axs[4, 2].set_ylim(0, 700)
            # axs[4,2].legend(fontsize=10)
            # axs[4,2].set_title("z projection")
            axs[4, 2].set_xlabel("$v_{z}~[\mathrm{km~s^{-1}}]$")
            axs[4, 2].set_yticks([])
            #axs[4, 2].legend(fontsize=10)
            axs[4, 2].set_yscale('log')
            #axs[4,2].axvline(x=np.mean(vz[r<rvir]), color='black', linestyle='solid')
            #axs[4,2].axvline(x=np.mean(vz[r<r500]), color='black', linestyle='dashed')
            #axs[4,2].axvline(x=np.mean(vz[r<r1]), color='black', linestyle='dotted')
            #axs[4,2].axvline(x=np.mean(vz[r<r2]), color='black', linestyle='dashdot')
            axs[4, 2].yaxis.set_visible(False)
            # axs[4, 2].set_yscale('log')

            # axs[3].yscale('log')

            # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
            # plt.grid(b=None)
            plt.legend()
            # plt.ylabel("PDF")
            axs[3, 3].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")

            axs[4, 3].axis("off")

            # plt.yscale('log')
            # plt.title("Vz distribution on ew sightline velocity along z axis")
            # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

            plt.suptitle("Velocity components distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii spheres")

            plt.show()

            sys.exit()

        velocity_components_hist_5x4(x,y,z,vx,vy,vz,large)

    #vel_comp_3D_hist(x,y,z,vx,vy,vz)

    vx_virgo = -509.1301
    vy_virgo = 228.9488
    vz_virgo = -131.9249

    vz -= vz_virgo
    vy -= vy_virgo
    vx -= vx_virgo

    vx*=1e5
    vy*=1e5
    vz*=1e5

    print("m")
    m = []
    #for i in range(0, nline):
    m = h.read_reals()
    #    m = np.concatenate((m, m_line))

    #print("mass min",np.min(m))
    #print("mass max",np.max(m))
    #sys.exit()

    #plt.hist(np.log10(m),bins=100,range=[2,7.2])
    #plt.show()
    #sys.exit()

    print("lvl")
    lvl = []
    #for i in range(0, nline):
    lvl = h.read_reals()
    #    lvl = np.concatenate((lvl, lvl_line))

    #print("max lvl",np.max(lvl))
    #print("min lvl",np.min(lvl))

    #sys.exit()

    #plt.hist2d(m,lvl,bins=[100,9],range=[[1E2,1E7],[11,19]])
    #plt.show()

    #sys.exit()

    #plt.scatter(m,lvl)
    #plt.show()
    #sys.exit()



    m_cumul_ba = np.zeros(21)

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

    #cond = np.logical_and(x-x_cen<7000,np.logical_and(x-x_cen>-9000,np.logical_and(y-y_cen<2500,np.logical_and(y-y_cen>-2500,np.logical_and(z-z_cen<2500,z-z_cen>-2500)))))

    #lvl_test= lvl[cond]

    #print("lvl inf 15",len(lvl_test[lvl_test<15]),"tot lvl test",len(lvl_test))

    #sys.exit()

    #print("x_cen",x_cen,"y_cen",y_cen,"z_cen",z_cen)


    def resolution_hist(x,y,z,lvl,x_cen,y_cen,z_cen):
        x-=x_cen
        y-=y_cen
        z-=z_cen

        #plt.hist(x,bins=100)

        cond = np.logical_and(x>-9000,np.logical_and(x<-7000,np.logical_and(y>2500,np.logical_and(y<4500,np.logical_and(z>-1000,z<1000)))))

        #cond = np.logical_and(x > -9000, np.logical_and(x < -7000, np.logical_and(y > -5000, np.logical_and(y < 5000,np.logical_and(z > -5000,z < 5000)))))


        plt.hist(lvl[cond],bins=100)
        plt.show()
        sys.exit()

    #resolution_hist(x,y,z,lvl,x_cen,y_cen,z_cen)

    def compute_sound_speed(vx,vy,vz):

        print("compute sound speed")

        size = (737441*0.03)/8
        size = 1000
        print("size",size)

        vx_virgo = -509.1301
        vy_virgo = 228.9488
        vz_virgo = -131.9249

        vx -= vx_virgo
        vy -= vy_virgo
        vz -= vz_virgo

        cond = np.logical_and(np.abs(x-x_cen)<size/2,np.logical_and(np.abs(y-y_cen)<size/2,np.abs(z-z_cen)<size/2))

        #plt.hist(x[cond],bins=100)
        #plt.show()
        #sys.exit()


        t_mean = np.mean(t[cond])
        print("T_mean","{:.2e}".format(t_mean))

        cs=np.sqrt(((5/3)*kb*t_mean)/(mu*mp))

        cs_all = np.sqrt(((5 / 3) * kb * t) / (mu * mp))

        print("mp",mp)



        v_mean = np.mean(np.sqrt(vx[cond]**2+vy[cond]**2+vz[cond]**2))

        v_mean *= 1e3

        v_all = np.sqrt(vx**2+vy**2+vz**2)

        v_all *= 1e3

        print("v_mean","{:.2e}".format(v_mean))

        print("cs", "{:.2e}".format(cs))

        print("Mach number","{:.2e}".format(v_mean/cs))


        ratio = v_all/cs_all

        plt.hist(ratio[ratio<100], bins=100)
        plt.show()

        sys.exit()

    #compute_sound_speed(vx, vy, vz)

    def velocity_radial_profile(x,y,z,vx,vy,vz,n,m):
        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)

        rlog = np.log10(r)

        vx_virgo = -509.1301
        vy_virgo = 228.9488
        vz_virgo = -131.9249

        vx -= vx_virgo
        vy -= vy_virgo
        vz -= vz_virgo

        v = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)

        rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

        v_rad_log = np.zeros(n)
        err_v = np.zeros(n)

        for i in range(0, n):
            print(i)

            #cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
            # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
            #cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))


            #cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y > y_cen,z > z_cen)))) #Sector 8 = Spherical Collapse
            #cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x < x_cen,np.logical_and(y < y_cen,z < z_cen))))  # Sector 1 = Relaxed
            #cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y < y_cen, z < z_cen))))  # Sector 5 = Filament

            cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025) #Full box

            m_sum_log = m[cond]
            v_sum_log = v[cond]

            #v_rad_log[i] = np.sum(v_sum_log * m_sum_log) / np.sum(m_sum_log)
            v_rad_log[i] = np.mean(v_sum_log)

            #err_v[i] = np.sqrt(np.sum(m_sum_log * (v_sum_log - v_rad_log[i]) ** 2) / np.sum(m_sum_log))
            err_v[i] = np.std(v_sum_log)

        plt.scatter(rlogbin_cen, v_rad_log, s=6, c='green')  # , c='blue')
        plt.errorbar(rlogbin_cen, v_rad_log, yerr=err_v, ls='dotted', label='sector 1', alpha=0.7, c='green')  # , c='blue')
        plt.show()

        sys.exit()

    #velocity_radial_profile(x,y,z,vx,vy,vz,n,m)





    #sys.exit()

    #r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)

    #plt.hist(r,bins=100)
    #plt.show()
    #sys.exit()

    #for i in range(0, 21):
    #    print(i)

        # cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
        # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
        #cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))
        #m_sum_log = m[cond]
    #    rlim = 10 ** ((18 + i) * 0.1)
    #    print(i, 'rlim ', rlim)
        # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
    #    m_cumul_ba[i] = np.sum(m[r < rlim])

    #print("msumbar", m_cumul_ba)
    #np.save("m_cumul_ba_21.npy", m_cumul_ba)

    #sys.exit()

    #@jit(nopython=True)
    def change_units(x, y, z, p, n_e, t, m,vx,vy,vz,lvl):
        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        #print("x_cen", x_cen, "y_cen", y_cen, "z_cen", z_cen)

        r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)

        #m_bar_inside_200kpc = np.sum(m[r < 200])
        #np.save("m_bar_inside_200kpc_77_bins.npy",m_bar_inside_200kpc)
        #print("m_bar within 200kpc saved")
        #sys.exit()
        # r=np.array(r)

        # n_e *= 1E6 / 0.864
        n_e /= 0.864 # np/ne = 0.864
        # plt.hist(np.log10(n_e),bins=100,range=[-3,7])
        # plt.show()
        # sys.exit()
        p /= 10
        p /= 1.602 * 10 ** (-10)
        p *= (0.76 / 0.864)
        # print("P",p)
        print("nb part", len(n_e))

        # m_no_cut = m
        # r_no_cut = r

        if t_cut == 1:
            lim = 0
            cond = np.logical_and(t > 1E5, n_e > 0) #Standard condition
            #cond = np.logical_and(t > 1E5,np.logical_and(n_e > 0,np.logical_and(x>x_cen,np.logical_and(y>y_cen,z>z_cen)))) #Conditions for sectors study
            n_e2 = n_e[cond]
            t_2 = t[cond]
            x_2 = x[cond]
            y_2 = y[cond]
            z_2 = z[cond]
            p = p[cond]
            r = r[cond]
            m = m[cond]
            t = t[cond]
            vx = vx[cond]
            vy = vy[cond]
            vz = vz[cond]
            lvl = lvl[cond]
            n_e = n_e2
            t =t_2
            x =x_2
            y = y_2
            z =z_2

        if t_cut == 2:
            cond = np.logical_and(t > 1E7, n_e > 0)
            n_e2 = n_e[cond]
            p = p[cond]
            r = r[cond]
            m = m[cond]
            t = t[cond]
            n_e = n_e2

        print("nb part after cut", len(n_e))

        t *= kb / 1.602e-16

        k=t/n_e**(2/3)

        #convert electron density in cm-3 to gas (hydrogen) density in gcm-3
        rho=(n_e*0.864*mp*1e3)

        #vx*=1e6
        #vy*=1e6
        #vz*=1e6 #comprendre pk j'avais mis *1e6 et pk ça a l'air de marcher (plutôt que *1e5 qui permettrait de passer de km/s à cm/s)

        rlog = np.log10(r)

        if log_before==1:
            p = np.log10(p)
            t = np.log10(t)
            n_e = np.log10(n_e)
            k = np.log10(k)

        ####test for validity of method : log before sum ok ?

        #np.save("p_test.npy",p)
        #np.save("m_test.npy",m)
        #np.save("ne_test.npy",n_e)

        ####



        return x, y, z, p, n_e, t, m, rlog, k, rho,vx,vy,vz,lvl

    # start=time.time()
    x, y, z, p, n_e, t, m, rlog, k, rho, vx, vy, vz, lvl = change_units(x, y, z, p, n_e, t, m,vx,vy,vz,lvl)

    print("unit change done")

    def ne_t_hist(n_e,t,rlog):

        log_ne = np.log10(n_e)
        log_t = np.log10(t)

        log_ne_5Mpc = log_ne[rlog<3.6989] #r<5Mpc
        log_t_5Mpc = log_t[rlog<3.6989] #r<5Mpc

        log_ne_2Mpc = log_ne[rlog<3.301] #r<5Mpc
        log_t_2Mpc = log_t[rlog<3.301] #r<5Mpc

        def K_to_keV(t):
            return 10**t * kb / 1.6e-16

        def keV_to_K(t):
            return np.log10(t * 1.6e-16 / kb)

        #kev_pos=np.logspace(-5,1.3,10)

        kev_pos = np.array([0.01,0.05,0.1,0.5,1,2,4,8,12,20])

        f,ax = plt.subplots(1,1,figsize=(10,10),constrained_layout=True)

        plt.hist2d(log_ne,log_t, bins=[100, 100],density=True,range=[[-7,-1],[3,9]],cmap='magma_r')
        secax = ax.secondary_yaxis('right', functions=(K_to_keV, keV_to_K))
        secax.set_ylabel(r'$T~[\mathrm{keV}]$')#, fontsize=fs)
        secax.set_yticks(kev_pos)
        #secax.tick_params(labelsize=fs)
        #plt.hist2d(log_ne_2Mpc,log_t_2Mpc, bins=[100, 100],density=True,range=[[-7,-1],[3,9]],cmap='magma_r')
        #plt.hist2d(log_ne_5Mpc, log_t_5Mpc, bins=[100, 100], density=True, range=[[-7, -1], [3, 9]], cmap='magma_r')
        plt.colorbar()
        plt.xlabel('log($n_e~[\mathrm{cm^-3}]$)')
        plt.ylabel('log($T~[\mathrm{K}]$)')
        plt.title("Density and temperature distribution in the zoom-in box")
        plt.show()

        sys.exit()

    def pos_t_hist(x,y,z,t,n_e):

        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        x -= x_cen
        y -= y_cen
        z -= z_cen

        cond_z = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(y > -100, y < 100)))
        cond_x = np.logical_and(z > -100, np.logical_and(z < 100, np.logical_and(y > -100, y < 100)))
        cond_y = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(z > -100, z < 100)))

        log_t = np.log10(t)
        log_ne = np.log10(n_e)

        #plt.hist2d(z[cond_z],,bins=100)





        def K_to_keV(t):
            return 10 ** t * kb / 1.6e-16

        def keV_to_K(t):
            return np.log10(t * 1.6e-16 / kb)

        #kev_pos = np.linspace(0, 15, 20)
        #kev_pos = np.logspace(-5, 1.3, 10)

        kev_pos = np.array([0.01, 0.1, 0.5, 4, 20])



        f, ax = plt.subplots(2, 1, figsize=(12, 6), constrained_layout=True)

        plt.sca(ax[0])
        #plt.hist2d(x[cond_x], log_t[cond_x], bins=[200, 50], density=True, range=[[-10000, 10000], [5, 9]],cmap='inferno_r')
        plt.hist2d(y[cond_y], log_t[cond_y], bins=[200, 50], density=True, range=[[-5000, 5000], [7.5, 8.5]],cmap='inferno_r')
        #plt.hist2d(z[cond_z], log_t[cond_z], bins=[200, 50], density=True, range=[[-10000, 10000], [5, 9]],cmap='inferno_r')

        secax = ax[0].secondary_yaxis('right', functions=(K_to_keV, keV_to_K))
        secax.set_ylabel(r'$T~[\mathrm{keV}]$')  # , fontsize=fs)
        secax.set_yticks(kev_pos)
        # secax.tick_params(labelsize=fs)
        # plt.hist2d(log_ne_2Mpc,log_t_2Mpc, bins=[100, 100],density=True,range=[[-7,-1],[3,9]],cmap='magma_r')
        # plt.hist2d(log_ne_5Mpc, log_t_5Mpc, bins=[100, 100], density=True, range=[[-7, -1], [3, 9]], cmap='magma_r')
        plt.colorbar()

        #plt.xlabel('$x-x_{Virgo}~[\mathrm{kpc}]$')
        #plt.xlabel('$y-y_{Virgo}~[\mathrm{kpc}]$')
        #plt.xlabel('$z-z_{Virgo}~[\mathrm{kpc}]$')

        plt.ylabel('log($T~[\mathrm{K}]$)')

        plt.xticks([])

        #plt.title("Temperature and density distribution along the x sightline")
        plt.title("Temperature and density distribution along the y sightline")
        #plt.title("Temperature and density distribution along the z sightline")

        plt.sca(ax[1])
        #plt.hist2d(x[cond_x], log_ne[cond_x], bins=[200, 50], density=True, range=[[-10000, 10000], [-7, -1]],cmap='cividis_r')
        plt.hist2d(y[cond_y], log_ne[cond_y], bins=[200, 50], density=True, range=[[-5000, 5000], [-7, -1]],cmap='cividis_r')
        #plt.hist2d(z[cond_z], log_ne[cond_z], bins=[200, 50], density=True, range=[[-10000, 10000], [-7, -1]], cmap='cividis_r')

        #secax = ax.secondary_yaxis('right', functions=(K_to_keV, keV_to_K))
        #secax.set_ylabel(r'$T~[\mathrm{keV}]$')  # , fontsize=fs)
        #secax.set_yticks(kev_pos)
        # secax.tick_params(labelsize=fs)
        # plt.hist2d(log_ne_2Mpc,log_t_2Mpc, bins=[100, 100],density=True,range=[[-7,-1],[3,9]],cmap='magma_r')
        # plt.hist2d(log_ne_5Mpc, log_t_5Mpc, bins=[100, 100], density=True, range=[[-7, -1], [3, 9]], cmap='magma_r')
        plt.colorbar()

        #plt.xlabel('$x-x_{Virgo}~[\mathrm{kpc}]$')
        plt.xlabel('$y-y_{Virgo}~[\mathrm{kpc}]$')
        #plt.xlabel('$z-z_{Virgo}~[\mathrm{kpc}]$')

        #plt.ylabel('log($T~[\mathrm{K}]$)')
        plt.ylabel('log($n_e~[\mathrm{cm^-3}]$)')

        # plt.title("Temperature distribution along the x sightline")
        # plt.title("Temperature distribution along the y sightline")
        #plt.title("Density distribution along the z sightline")

        plt.show()

        sys.exit()


    def vlos_hist(x,y,z,vx,vy,vz,t):

        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        x -= x_cen
        y -= y_cen
        z -= z_cen

        vx_virgo = -509.1301
        vy_virgo = 228.9488
        vz_virgo = -131.9249

        vx -= vx_virgo
        vy -= vy_virgo
        vz -= vz_virgo

        cond_z = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(y > -100, y < 100)))
        cond_x = np.logical_and(z > -100, np.logical_and(z < 100, np.logical_and(y > -100, y < 100)))
        cond_y = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(z > -100, z < 100)))
        cond_T = np.logical_and(t > 2e7, t < 1.4e8)

        cond_zT = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(y > -100, np.logical_and(y < 100,np.logical_and(t > 2e7, t < 1.4e8)))))
        #cond_xT = np.logical_and(z > -100, np.logical_and(z < 100, np.logical_and(y > -100, y < 100,np.logical_and(t > 2e7, t < 1.4e8))))
        cond_xT = np.logical_and(z > -100, np.logical_and(z < 100, np.logical_and(y > -100, np.logical_and(y < 100, np.logical_and(t > 2e7,t < 1.4e8)))))
        cond_yT = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(z > -100, np.logical_and(z < 100,np.logical_and(t > 2e7, t < 1.4e8)))))




        #log_t = np.log10(t)
        #log_ne = np.log10(n_e)


        los_v = vy

        los_vcond = los_v[cond_y]

        los_vcondT = los_v[cond_yT]

        plt.hist(los_v,bins=100,label="Full box",alpha=0.5)
        plt.hist(los_vcond,bins=100,label="centred $100kpc^2$ y los",alpha=0.5)
        plt.hist(los_vcondT,bins=100,label="centred $100kpc^2$ y los, T in XRISM range",alpha=0.5)
        plt.legend()
        plt.title("Vy distribution along y axis")
        plt.yscale('log')
        plt.xlim(-2000,2000)
        plt.xlabel("Vy [km/s]")
        plt.ylabel("Number of cells")


        plt.show()

        sys.exit()

    #ne_t_hist(n_e,t,rlog)

    #vlos_hist(x,y,z,vx,vy,vz,t)

    #pos_t_hist(x,y,z,t,n_e)

    #r=10**rlog
    #plt.hist2d(r,lvl,bins=[20,6],range=[[0,300],[16,21]])
    #plt.hist(lvl[r<100])

    #plt.colorbar()
    #plt.show()

    #sys.exit()

    # print("r",rlog)

    # end=time.time()
    # print("time change units",end-start)
    # sys.exit()

    # print("p",p[0:10])
    # ptest=n_e*t
    # print("n_e*T",ptest[0:10])
    # ratio=p/ptest
    # print("ratio", ratio[0:10])

    # sys.exit()

    # plt.hist2d(r,lvl,bins=[2000,8])
    # plt.colorbar()
    # plt.xscale('log')
    # plt.show()

    # print(len(rlog))
    # print(lvl)
    # print(len(lvl))

    # print("exit")
    # sys.exit()

    # t_rad = np.zeros(400)
    # ne_rad = np.zeros(400)
    # ne_rad_std = np.zeros(400)
    # p_rad = np.zeros(400)
    # m_rad = np.zeros(400)
    # n_rad = np.zeros(400)

    def normal_scale():
        for i in range(400):
            print(i)
            cond = np.logical_and(r > i * 10, r < (i + 1) * 10)
            t_sum = t[cond]
            m_sum = m[cond]
            if np.sum(m_sum) > 0:
                t_rad[i] = np.sum(t_sum * m_sum) / np.sum(m_sum)
            else:
                t_rad[i] = np.nan
            ne_rad[i] = np.median(n_e[cond])
            p_rad[i] = np.median(p[cond])
            # m_rad[i]=np.sum(m_sum)
            m_rad[i] = np.sum(m_no_cut[np.logical_and(r_no_cut > i * 10, r_no_cut < (i + 1) * 10)])
            n_rad[i] = len(m_sum)
            # print(n_rad)
            # nb=int(n_rad[i]*0.5)
            # print("nb",nb)
            # med=np.zeros(100)
            # if(nb>1):
            #    for j in range(100):
            #        #print(j)
            #        med[j]=np.median(resample(n_e[cond],n_samples=nb))
            #
            #        ne_rad_std[i]=np.std(med)
            #    else:
            #        ne_rad_std[i]=0

    # normal_scale()

    # print("n_e[cond]",n_e[cond])
    # nbs=resample(n_e[cond],n_samples=10)
    # print("nbs",nbs)
    # print(ne_rad_std)

    # for i in range(5,395):
    #    T_smooth[i]=np.median(t_rad[i-5:i+5])
    #    ne_smooth[i]=np.mean(ne_rad[i-10:i+10])
    #    P_smooth[i]=np.mean(p_rad[i-10:i+10])

    # for i in range(-20,50):
    #    clog=np.logical_and(rlog>i*0.1,rlog<(i+1)*0.1)
    #    t_sum_log=tlog[~clog]
    #    m_sum_log=m[~clog]
    #    p_rad_log[i+20]=np.median(plog[~clog])
    #    t_rad_log[i+20]=np.sum(t_sum_log*m_sum_log)/np.sum(m_sum_log)
    #    ne_rad_log[i+20]=np.median(ne_log[~clog])
    #@jit(nopython=True)
    def log_scale(n):
        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076
        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)


        #n = 40 #modif pr secteurs :77, 40 avant (pour 40 bins de 0.05)


        p_rad_log = np.zeros(n)
        t_rad_log = np.zeros(n)
        ne_rad_log = np.zeros(n)
        n_log = np.zeros(n)
        m_rad_log = np.zeros(n)
        err_p = np.zeros(n)
        err_ne = np.zeros(n)
        err_t = np.zeros(n)

        p_turb = np.zeros(n)
        err_pturb = np.zeros(n)

        k_rad_log = np.zeros(n)
        err_k = np.zeros(n)

        print("med_mean=", mean_med)

        ####test for validity of method : log before sum ok ?

        #p_test = np.load("p_test.npy")
        #m_test = np.load("m_test.npy")
        #n_e_test = np.load("ne_test.npy")

        #p_rad_test = np.zeros(n)
        #ne_rad_test = np.zeros(n)

        ####


        #m_cumul_ba=np.zeros(40)

        ###### modif pour secteurs:
        #n = 77
        #rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

        for i in range(0, n):
            print(i)

            cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
            # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
            #cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))


            #cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y > y_cen,z > z_cen)))) #Sector 8 = Spherical Collapse
            #cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x < x_cen,np.logical_and(y < y_cen,z < z_cen))))  # Sector 1 = Relaxed
            #cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y < y_cen, z < z_cen))))  # Sector 5 = Filament

            #cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025) #Full box

            m_sum_log = m[cond]
            #rlim = 10 ** ((35.5 + i) * 0.05)
            #print(i, 'rlim ', rlim)
            # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
            #m_cumul_ba[i] = np.sum(m[r < rlim])


            # print('test')
            if mean_med == 1:
                # print('test 1')
                p_sum_log = p[cond]
                ne_sum_log = n_e[cond]
                t_sum_log = t[cond]
                k_sum_log = k[cond]


                # print('test 1.5')
                # print("msumlog",m_sum_log)
                # print("psumlog",p_sum_log)
                p_rad_log[i] = np.sum(p_sum_log * m_sum_log) / np.sum(m_sum_log)
                # print('test 2')
                ne_rad_log[i] = np.sum(ne_sum_log * m_sum_log) / np.sum(m_sum_log)
                # print('test 3')
                t_rad_log[i] = np.sum(t_sum_log * m_sum_log) / np.sum(m_sum_log)
                # print('test 4')
                err_ne[i] = np.sqrt(np.sum(m_sum_log * (ne_sum_log - ne_rad_log[i]) ** 2) / np.sum(m_sum_log))
                err_t[i] = np.sqrt(np.sum(m_sum_log * (t_sum_log - t_rad_log[i]) ** 2) / np.sum(m_sum_log))
                err_p[i] = np.sqrt(np.sum(m_sum_log * (p_sum_log - p_rad_log[i]) ** 2) / np.sum(m_sum_log))

                k_rad_log[i] = np.sum(k_sum_log * m_sum_log) / np.sum(m_sum_log)
                err_k[i] = np.sqrt(np.sum(m_sum_log * (k_sum_log - k_rad_log[i]) ** 2) / np.sum(m_sum_log))

                vxmean = np.mean(vx[cond])
                vymean = np.mean(vy[cond])
                vzmean = np.mean(vz[cond])
                sigmax = np.sum(m_sum_log * (vx[cond] - vxmean) ** 2) / np.sum(m_sum_log)
                sigmay = np.sum(m_sum_log * (vy[cond] - vymean) ** 2) / np.sum(m_sum_log)
                sigmaz = np.sum(m_sum_log * (vz[cond] - vzmean) ** 2) / np.sum(m_sum_log)
                sigmatot=sigmax+sigmay+sigmaz
                #print("vxmean",vxmean)
                #print("sigmax",np.sqrt(sigmax))
                rhomean=np.sum(rho[cond] * m_sum_log) / np.sum(m_sum_log)

                p_turb[i]=(1/3)*rhomean*sigmatot

                ####test for validity of method : log before sum ok ?

                #m_sum_test = m_test[cond]
                #p_sum_test = p_test[cond]

                #p_rad_test[i] = np.sum(p_sum_test * m_sum_test) / np.sum(m_sum_test)
                #ne_rad_test[i] = np.sum(n_e_test[cond] * m_sum_test) / np.sum(m_sum_test)

                ###

            elif (mean_med == 2):
                p_sum_log = p[cond]
                ne_sum_log = n_e[cond]
                t_sum_log = t[cond]
                k_sum_log = k[cond]

                t_rad_log[i] = np.median(t_sum_log)
                p_rad_log[i] = np.median(p_sum_log)
                ne_rad_log[i] = np.median(ne_sum_log)
                k_rad_log[i] = np.median(k_sum_log)

                err_ne[i] = np.median(np.abs(ne_sum_log - ne_rad_log[i]))
                err_p[i] = np.median(np.abs(p_sum_log - p_rad_log[i]))
                err_t[i] = np.median(np.abs(t_sum_log - t_rad_log[i]))
                err_k[i] = np.median(np.abs(k_sum_log - k_rad_log[i]))

            else:
                print('test 0')
                p_rad_log[i] = np.median(plog[cond])
                ne_rad_log[i] = np.median(ne_log[cond])

                t_sum_log = tlog[cond]
                t_rad_log[i] = np.sum(t_sum_log * m_sum_log) / np.sum(m_sum_log)

                err_ne[i] = np.median(np.abs(ne_log[cond] - ne_rad_log[i]))
                err_p[i] = np.median(np.abs(plog[cond] - p_rad_log[i]))
                err_t[i] = np.sqrt(np.sum(m_sum_log * (t_sum_log - t_rad_log[i]) ** 2) / np.sum(m_sum_log))
            n_log[i] = len(m_sum_log)
            m_rad_log[i] = np.sum(m_sum_log)
            print(len(m_sum_log))

        #print("msumbar", m_cumul_ba)
        #np.save("m_cumul_ba.npy", m_cumul_ba)

        #sys.exit()

        #print("p_turb", p_turb)

        p_turb /= 10
        p_turb /= 1.602 * 10 ** (-10)
        p_turb = np.log10(p_turb)
        #print("p_turb log", p_turb)

        if log_before == 0:
            err_p = err_p / (np.log(10) * p_rad_log)
            err_t = err_t / (np.log(10) * t_rad_log)
            err_ne = err_ne / (np.log(10) * ne_rad_log)
            err_k = err_k / (np.log(10) * k_rad_log)
            p_rad_log = np.log10(p_rad_log)
            t_rad_log = np.log10(t_rad_log)
            ne_rad_log = np.log10(ne_rad_log)
            k_rad_log = np.log10(k_rad_log)





        def save_data_sectors(file,n):
            rad_data = np.zeros((10, n))
            rad_data[0, :] = p_rad_log
            rad_data[1, :] = err_p
            rad_data[2, :] = ne_rad_log
            rad_data[3, :] = err_ne
            rad_data[4, :] = t_rad_log
            rad_data[5, :] = err_t
            rad_data[6, :] = k_rad_log
            rad_data[7, :] = err_k
            rad_data[8, :] = m_rad_log
            rad_data[9, :] = n_log

            np.save(file, rad_data)
            print("data saved")
            sys.exit()

        #save_data_sectors("./sectors_study/splashback/lograd_profs_h_all_77_med_before_log.npy",77)

        ##plt.scatter(rlogbin_cen, p_rad_log, s=6, c='green')  # , c='blue')
        #plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_p, ls='dotted', label='sector 1', alpha=0.7, c='green')  # , c='blue')


        ##Test for method validity

        #print("p_rad_log",p_rad_log)

        #p_rad_test = np.log10(p_rad_test)
        #ne_rad_test = np.log10(ne_rad_test)

        #print("p_rad_test", p_rad_test)

        #np.save('p_rad_test.npy',p_rad_test)
        #np.save('ne_rad_test.npy',ne_rad_test)

        #print("test profs saved")
        #sys.exit()

        #plt.plot(rlogbin_cen, p_rad_log, ls='dotted', label='original method', alpha=0.7, c='green')# , c='blue')
        #plt.plot(rlogbin_cen, p_rad_test, ls='dotted', label='test', alpha=0.7, c='blue')
        #plt.xscale("log")
        #plt.legend()
        #plt.axvline(x=1087, color='grey')
        #plt.text(1087, -7, "$\mathrm{R_{500}}$", rotation=90, size=16)
        #plt.axvline(x=2147, color='grey', ls='dashed')
        #plt.text(2147, -7, "$\mathrm{R_{vir}}$", rotation=90, size=16)

        #plt.show()

        #sys.exit()

        return p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_ne, err_p, err_t, err_k,p_turb

    def test():
        p_rad_log = np.array(
            [np.median(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
        ne_rad_log = np.array(
            [np.median(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
        n_log = np.array([len(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
        m_rad_log = np.array(
            [np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
        t_rad_log = np.array([np.sum(tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * m[
            np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) / np.sum(
            m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])

        mad_ne_log = np.array(
            [np.median(np.abs(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - ne_rad_log[i]))
             for i in range(40)])
        mad_plog = np.array(
            [np.median(np.abs(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - p_rad_log[i])) for
             i in range(40)])
        w_std_plog = np.array([np.sqrt(np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * (
                tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - t_rad_log[i]) ** 2) / np.sum(
            m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)])) for i in range(40)])

        return p_rad_log, t_rad_log, ne_rad_log, m_rad_log, n_log, mad_ne_log, mad_plog, w_std_plog

    # start=time.time()
    p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_nelog, err_plog, err_tlog, err_klog,p_turb = log_scale(n)

    print("p_rad_log",p_rad_log)
    #sys.exit()


    rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

    #np.save("entropy_profile_Virgo.npy",k_rad_log)
    #np.save("entropy_profile_Virgo_errb.npy", err_klog)
    #print("data saved")
    #sys.exit()
    #plt.scatter(rlogbin_cen,k_rad_log)
    #plt.errorbar(rlogbin_cen,k_rad_log,yerr=err_klog,ls='dotted')
    #plt.xscale('log')
    #plt.yscale('log')
    #plt.show()
    #sys.exit()

    ptot=10**p_rad_log+10**p_turb
    alpha=(10**p_turb)/ptot
    print('p_rad_log',10**p_rad_log)
    print("pturb",10**p_turb)
    print("ptot",ptot)
    #sys.exit()
    #plt.scatter(rlogbin_cen,p_rad_log,s=6, c='orange')
    #plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted', label='$8192^3$', alpha=0.7, c='orange')

    plt.plot(rlogbin_cen/1087,alpha,c='purple')
    plt.xscale('log')
    plt.xlim(0.02,2)
    plt.show()
    #np.save("alpha.npy",alpha)
    sys.exit()

    # end=time.time()
    # print("durée:",end-start)

    #rratio=rlogbin_cen/1087
    #krad=np.array([10**k_rad_log[i] for i in range(len(k_rad_log))])

    #rad_data = np.zeros((2, 40))
    #rad_data[0,:]=krad
    #rad_data[1,:]=krad*err_klog
    #np.save("K_prof_high",rad_data)

    #plt.plot(rratio,10**p_turb/(10**p_rad_log))
    #plt.scatter(rlogbin_cen, krad, s=6, c='green',label='Entropy')
    #plt.errorbar(rlogbin_cen, krad, yerr=krad*err_klog, ls='dotted', label='3D, 8192^3', alpha=0.7, c='orange')
    #plt.scatter(rlogbin_cen, p_rad_log, s=6, c='orange')
    #plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted',label='Rescaled data (lvl=15, low res)', alpha=0.7, c='orange')
    #plt.scatter(rlogbin_cen,np.log10(10**p_rad_log+10**p_turb),label='P_tot',s=6,c='blue')
    #plt.xscale('log')
    #plt.yscale('log')
    # plt.yscale('log')
    #plt.axvline(x=1087, color='grey')
    #plt.text(1087, 2.75, "$R_{500}$", rotation=90, size=16)
    #plt.axvline(x=2147, color='grey', ls='dashed')
    #plt.text(2147, 2.75, "$R_{vir}$", rotation=90, size=16)
    #plt.xlabel("R(kpc)", size=16)
    #plt.ylabel('$log_{10}(K[keV.cm^{2}])$')
    #plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
    #plt.legend(prop={'size': 16})
    #plt.show()

    #sys.exit()

    # return t_rad, ne_rad, p_rad, m_rad, n_rad, p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, ne_rad_std, mad_ne_log, mad_plog, w_std_plog
    return p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, err_nelog, err_plog, err_tlog,


def dm(file):
    print('dm')
    #test=np.fromfile(file)
    #print(np.shape(test))
    #sys.exit()
    d = FortranFile(file, 'r')

    print('fichier dm ouvert')

    ncell = d.read_ints()
    print("n dm cell", ncell)

    #print(f_to_py.__doc__)
    #print(f_to_py.func_to_py.read_dm_file.__doc__)

    #sys.exit()

    #x = np.asfortranarray(np.zeros(ncell))
    #y = np.asfortranarray(np.zeros(ncell))
    #z = np.asfortranarray(np.zeros(ncell))
    #r = np.asfortranarray(np.zeros(ncell))

    #print("x")
    #x = f_to_py.func_to_py.read_dm_file(ncell, 1)

    #print("y")
    #y = f_to_py.func_to_py.read_dm_file(ncell, 2)

    #print("y", y[1:10])

    #print("z")
    #z = f_to_py.func_to_py.read_dm_file(ncell, 3)

    #print("z",z[1:10])

    #print("x")
    #x = f_to_py.func_to_py.read_dm_file(ncell, 1)


    #print("test")

    #print("x",x)

    print("test")

    #sys.exit()
    x = d.read_reals()
    #x = d.read_reals(dtype='f8')
    #print('x', x[0:10])
    #print(len(x))
    y = d.read_reals()
    z = d.read_reals()
    vx = d.read_reals()
    vy = d.read_reals()
    vz = d.read_reals()
    m = d.read_reals()
    #print(len(m))

    print("lecture données fini")

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

    #print("xcen", x_cen)

    #r = [np.sqrt((x[i] - x_cen) ** 2 + (y[i] - y_cen) ** 2 + (z[i] - z_cen) ** 2) for i in range(len(x))]

    r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)
    # plt.hist(r)
    # plt.scatter(x[0::10000],y[0::10000],c='black')
    # plt.scatter(x_cen,y_cen,s=20,c="blue")
    # plt.show()
    # sys.exit()
    rlog = np.log10(r)
    rlog = np.array(rlog)
    #print(rlog)

    print('rayon part dm fini')

    #nbin=40
    nbin = 77

    m_rad = np.zeros(nbin)
    n_rad = np.zeros(nbin)

    #rlogbin = np.array([10 ** ((17.5 + i) * 0.1) for i in range(nbin + 1)])
    rlogbin = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])

    nbin = 77
    rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(nbin)])

    for i in range(nbin):
        #cond = np.logical_and(rlog > (i + 35) * 0.1, rlog < (i + 36) * 0.1)
        cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)
        m_rad[i] = np.sum(m[cond])
        n_rad[i] = len(m[cond])
        #print("mass in bin", i, " :", m_rad[i])
        #print("nbr of particles in rad", i, " :", n_rad[i])

    #msum=np.array(np.sum(m_rad[0:i] for i in range(nbin)))
    #print("msums",msum)
    #np.savetxt("lograd_dm_21.txt")
    #sys.exit()

    return m_rad,n_rad


def density(mh, mdm, t, r):
    print('density')
    x = int(r // 10)
    den = np.zeros(40)
    den_norm = np.zeros(40)
    m_tot = np.zeros(40)
    mdmtot = np.zeros(40)
    for i in range(0, 40):
        den[i] = (3 * m_sun * np.sum(mdm[0:i + 1])) / (4 * np.pi * (10 ** ((i + 35) * 0.05) * pc * 1E3) ** 3)
        den_norm[i] = den[i] / (rho_c * (omega_c / omega_m))
        m_tot[i] = np.sum(mdm[0:i + 1]) + np.sum(mh[0:i + 1])
        mdmtot[i] = np.sum(mdm[0:i + 1])
    return den, den_norm, m_tot, mdmtot


def upplog(x, p0, c500, alpha, beta, gamma):
    return np.log10(p0) - gamma * np.log10(c500 * x) + ((gamma - beta) / alpha) * np.log10(1 + (c500 * x) ** alpha)


def upp(x, p0, c500, alpha, beta, gamma):  # function used to fit with upp
    return p0 / (((c500 * x) ** gamma) * ((1 + (c500 * x) ** alpha) ** ((beta - gamma) / alpha)))


def fit_fcts():
    def dupp(x, p0, c500, alpha, beta, gamma):
        return p0 * (-gamma * c500 * (c500 * x) ** (-gamma - 1) * (1 + (c500 * x) ** alpha) ** (
                (alpha - beta) / gamma) + (
                             (gamma - beta

                              ) / alpha) * alpha * c500 * (c500 * x) ** (alpha - 1) * (1 + (c500 * x) ** alpha) ** (
                             (gamma - beta - 1) / alpha) * (c500 * x) ** gamma)

    def n_model(x, n0, a, b, c, e, rc, rs):  # ,n02,b2,rc2):
        return (n0 ** 2 * (x / rc) ** (-a)) / ((1 + (x / rc) ** 2) ** (3 * b - a / 2) * (1 + (x / rs) ** c) ** (
                e / c))  # +n02**2/((1+(x/rc)**2)**(3*b2))

    def n_model_log(x, n0, a, b, c, e, rc, rs):
        return 2 * np.log10(n0) - a * np.log10(x / rc) - (3 * b - a / 2) * np.log10(1 + (x / rc) ** 2) - (
                e / c) * np.log10(
            1 + (x / rs) ** c)

    def n_beta_model(x, n0, rc, b):
        return n0 ** 2 / ((1 + (x / rc) ** 2) ** (3 * b))

    def n_beta_model_log(x, n0, rc, b):
        return 2 * np.log10(n0) - 3 * b * np.log10(1 + (x / rc) ** 2)

    def T_model(r, t0, a, acool, b, c, rt, rcool, tau):
        x = (r / rcool) ** acool
        rsrt = r / rt
        return t0 * ((x + tau) / (x + 1)) * (rsrt ** (-a) / (1 + rsrt ** b) ** (c / b))

    def fit(test):
        if test == 0:
            npne = 0.864 * 1e-12 * n_e ** 2
            npnefit = npne[np.where(np.isnan(npne) == False)]
            rfitn = r_bin[np.where(np.isnan(npne) == False)]

            modelnbeta = [f.n_beta_model(r_bin[i], 5E-3, 100, 0.5) for i in range(400)]
            modeln = [f.n_model(r_bin[i], 5E-3, 1.5, 0.5, 3, 2.5, 100, 1000) for i in range(400)]

            popt, pcov = curve_fit(f.n_beta_model, rfitn, npnefit, p0=[5E-3, 100, 0.5])
            print(popt)
            popt2, pcov2 = curve_fit(f.n_model, rfitn, npnefit, p0=[5E-3, 1.5, 0.5, 3, 2.5, 100, 1000])
            print(popt2)

            plt.plot(r_bin, npne, '.', label='data')
            plt.plot(r_bin, modeln, label='model_n')
            plt.plot(r_bin, modelnbeta, label='model_beta')
            plt.plot(r_bin, f.n_beta_model(r_bin, *popt), label='fit_beta_model')
            plt.plot(r_bin, f.n_model(r_bin, *popt2), label='fit_Vikhlinin_model')

        if test == 1:
            npnelog = 2 * ne_log - 12 + np.log10(0.864)
            npnelogfit = npnelog[np.where(np.isnan(npnelog) == False)]
            rfitnlog = rlog[np.where(np.isnan(npnelog) == False)]

            modelnbetalog = [f.n_beta_model_log(rlog[i], 5E-3, 100, 0.5) for i in range(70)]
            modelnlog = [f.n_model_log(rlog[i], 5E-3, 1.5, 0.5, 3, 2.5, 100, 1000) for i in range(70)]

            popt, pcov = curve_fit(f.n_beta_model_log, rfitnlog, npnelogfit, p0=[5E-3, 100, 0.5])
            print(popt)
            popt2, pcov2 = curve_fit(f.n_model_log, rfitnlog, npnelogfit, p0=[5E-3, 1.5, 0.5, 3, 2.5, 100, 1000])
            print(popt2)

            plt.plot(rlog, npnelog, '.', label='data')
            plt.plot(rlog, modelnlog, label='model_n')
            plt.plot(rlog, modelnbetalog, label='model_beta')
            plt.plot(rlog, f.n_beta_model_log(rlog, *popt), label='fit_beta_model')
            plt.plot(rlog, f.n_model_log(rlog, *popt2), label='fit_Vikhlinin_model')

        if test == 2:
            tkev = t * kb / 1.6e-16
            tfit = tkev[np.where(np.isnan(tkev) == False)]
            rfit = r_bin[np.where(np.isnan(tkev) == False)]
            modelt = [f.T_model(r_bin[i], 8, 0, 1, 5, 10, 1000, 100, 0.25) for i in range(400)]
            popt, pcov = curve_fit(f.T_model, rfit, tfit, p0=[8, 0, 1, 5, 10, 1000, 100, 0.25])
            print(popt)
            plt.plot(r_bin, tkev, '.', label='data')
            plt.plot(r_bin, f.T_model(r_bin, *popt), label='fit')
            plt.plot(r_bin, modelt, label='model')

        plt.xscale('log')

    def biaswfit():
        print("dupp(1)", f.dupp(1, 4.27273774, 1.51552205, 1.81110149, 4.71021605, 0.43440187))
        dupp = [f.dupp((i * 100) / 1085, 4.27273774, 1.51552205, 1.81110149, 4.71021605, 0.43440187) for i in
                range(1, 40)]
        print(dupp[10])

        mpfit = [
            (-r_bin[int(i * 10)] * p[int(i * 10)] * dupp[i - 1]) / (g * mu * mp * n_e[int(i * 10)]) * (
                    (1E3 * pc) / m_sun)
            for i in range(1, 40)]
        # t=t[t<1E5]
        print("mpfit", mpfit)

        ratiopfit = [mpfit[i - 1] / m_tot[int(i * 10)] for i in range(1, 40)]
        x = [i * 100 for i in range(1, 40)]
        # plt.plot(x,ratiopfit,label='P_fit')

    def press(p, pstd):
        # P500=np.nansum(p[0:108]*n[0:108])/np.sum(n[0:108])
        # print("n :",n)
        # print("P500 :",P500)
        # p/=P500
        # print(p)
        n = 60
        r_bin = np.zeros(n)
        for i in range(0, n):
            r_bin[i] = (10 ** ((i + 20) * 0.05)) / 1075

        # pfit=np.zeros(70)
        # rfit=np.zeros(70)
        # pfit=[p if np.isnan(p[i])==False else -10 for i in range(len(p))]
        print("p", p)
        pfit = p[np.where(np.isnan(p) == False)]
        print("pfit", pfit)
        rfit = r_bin[np.where(np.isnan(p) == False)]
        print("rfit", rfit)
        pstdfit = pstd[np.where(np.isnan(p) == False)]
        print("pstdfit", pstdfit)
        # rfit=[r_bin[i] if np.isnan(p[i])==False else -10 for i in p]
        # print("p",p)

        # popt,pcov=curve_fit(upplog,rfit[2:20],pfit[2:20],p0=[6.41,1.81,1.33,4.13,0.31],bounds=([0,0,0,0,-10],[600,20,10,15,10]),absolute_sigma=True,method='trf')
        popt, pcov = curve_fit(upplog, rfit[pstdfit > 0], pfit[pstdfit > 0], sigma=pstdfit[pstdfit > 0],
                               p0=[6.41, 1.81, 1.33, 4.13, 0.31], bounds=([0, 0, 0, 0, -10], [600, 20, 10, 15, 10]),
                               absolute_sigma=True, method='trf')
        print("fit params", popt)
        covar = [pcov[i][i] for i in range(5)]
        print("covar", covar)
        # r_bin=[(10**((20+i)*0.05))/1075 for i in range(0,n)]
        # r_bin=np.array(r_bin)
        p13 = [upplog(r_bin[i], 6.41, 1.81, 1.33, 4.13, 0.31) for i in range(0, n)]
        a10 = [upplog(r_bin[i], 8.40, 1.18, 1.05, 5.49, 0.31) for i in range(0, n)]
        p7 = [upplog(r_bin[i], 3.36, 1.18, 1.08, 4.30, 0.31) for i in range(0, n)]
        a85p = [upplog(r_bin[i], 5.99, 0.02, 0.48, 14.97, 0.31) for i in range(0, n)]

        # fig=plt.figure()
        plt.scatter(r_bin[:], p[:], s=6)
        plt.errorbar(r_bin[:], p[:], y_err=pstdfit, label='Virgo', ls='None')
        plt.plot(r_bin, p13, label="P13", color='green', lw=1.0)
        plt.plot(r_bin, a10, label='A10', color='purple', lw=1.0)
        plt.plot(r_bin, p7, label='P7', color='red', lw=1.0)
        plt.plot(r_bin, upplog(r_bin, *popt), '--', label="fit", color="grey", lw=1.0)
        # plt.loglog(r_bin,a85p,label='A85_P13',color='yellow')
        plt.xlim(0.01, 10)
        plt.ylim(-5, 2)
        plt.xscale('log')
        plt.xlabel('$r/r_{500}$')
        plt.ylabel('$log_{10}(p/P_{500})$')
        plt.tick_params(top=True, left=True, bottom=True, right=True, labelleft=True, labelbottom=True)
        plt.legend()
        plt.show()


def local_env(n):
    h = FortranFile('virgo_xyz_hydro_l17.dat', "r")
    n_e = h.read_reals()
    t = h.read_reals()
    print(t)
    p = h.read_reals()
    n_e *= 1E6 / 0.864
    p /= 10
    x = h.read_reals()
    y = h.read_reals()
    z = h.read_reals()
    vx = h.read_reals()
    vy = h.read_reals()
    vz = h.read_reals()
    m = h.read_reals()

    gal_list = np.loadtxt("list_gal_251.dat_js_nocontam")
    cond = np.logical_and(gal_list[:, 20] > 0.47783, np.logical_and(gal_list[:, 20] < 0.49139,
                                                                    np.logical_and(gal_list[:, 21] > 0.50131,
                                                                                   np.logical_and(
                                                                                       gal_list[:, 21] < 0.51487,
                                                                                       np.logical_and(
                                                                                           gal_list[:, 22] > 0.49009,
                                                                                           gal_list[:,
                                                                                           22] < 0.50365)))))
    # print("cond",cond[0:40])
    cen_x = (gal_list[:, 3][cond] - 0.5) * (unit_l / 3.08567758128E21)
    cen_y = (gal_list[:, 4][cond] - 0.5) * (unit_l / 3.08567758128E21)
    cen_z = (gal_list[:, 5][cond] - 0.5) * (unit_l / 3.08567758128E21)

    r_vir_dm = gal_list[:, 23][cond] * (unit_l / 3.08567758128E21)

    vir_x = 0.48461068
    vir_y = 0.50809848
    vir_z = 0.49687076

    vir_x = (vir_x - 0.5) * (unit_l / 3.08567758128E21)
    vir_y = (vir_y - 0.5) * (unit_l / 3.08567758128E21)
    vir_z = (vir_z - 0.5) * (unit_l / 3.08567758128E21)

    dist = np.sqrt((cen_x - vir_x) ** 2 + (cen_y - vir_y) ** 2 + (cen_z - vir_z) ** 2)

    # cen_x=0.48287964   #!gal 10
    # cen_y=0.50985229
    # cen_z=0.49664778

    # cen_x= (cen_x-0.5)*(unit_l/3.08567758128E21)
    # cen_y= (cen_y-0.5)*(unit_l/3.08567758128E21)
    # cen_z= (cen_z-0.5)*(unit_l/3.08567758128E21)

    meanT = np.zeros(len(cen_x))
    minT = np.zeros(len(cen_x))

    # for n in range(0,len(cen_x)):

    #    print(n)

    #    width=r_vir_dm[n]
    #    min_x=cen_x[n]-width
    #    max_x=cen_x[n]+width
    #    min_y=cen_y[n]-width
    #    max_y=cen_y[n]+width
    #    min_z=cen_z[n]-width
    #    max_z=cen_z[n]+width

    #    cond=np.logical_and(x>min_x,np.logical_and(x<max_x,np.logical_and(y>min_y,np.logical_and(y<max_y,np.logical_and(z>min_z,z<max_z)))))

    # print("cond",cond)

    # meanT=np.sum(t[cond]*m[cond])/np.sum(m[cond])
    #    meanT[n]=np.mean(t[cond])
    #    if(len(t[cond])>0):
    #        minT[n]=np.min(t[cond])
    #    else:
    #        minT[n]=np.nan

    # print("meanT",meanT[0:30])
    # print("meanT2",meanT[~np.isnan(meanT)][0:30])

    # plt.hist2d(np.log10(meanT[~np.isnan(meanT)][1:]),dist[~np.isnan(meanT)][1:],cmap="autumn",norm=colors.LogNorm(),bins=(20,20))
    # plt.hist(dist[~np.isnan(meanT)][1:],bins=20)
    plt.hist(r_vir_dm[gal_list[:, 2][cond] > 1e9], bins=200)
    print("nbr gal", len(r_vir_dm[gal_list[:, 2][cond] > 1e9]))
    # plt.xlabel("$log_{10}(T_{mean}[K])$")
    # plt.xlabel("$d_{Virgo} (kpc)$")
    plt.xlabel("Galaxy mass ($log_{10}(M_{\odot})$)")
    plt.ylabel("$N_{gal}$")
    # plt.colorbar()
    plt.show()

    # medT=np.median(t[cond])
    # print("meanT",meanT)
    # print("nbr cell",len(t[cond]))

    # plt.hist(np.log10(t[cond]),bins=30)
    # plt.xlabel("$\frac{T_{cell}}{T_{mean}}$")
    # plt.ylabel("$N_{cell}$")
    # plt.xlabel("$log_{10}(t[K])$")
    # plt.xlabel("$T_{cell}/T_{med}$")
    # titre="gal "+str(n)+", $n_{cells}$= "+str(len(t[cond]))+", $r_{vir}$="+str(int(r_vir_dm[n]))+"kpc d="+str(int(dist))+"kpc"# $T_{mean}$="+f"{meanT:.2e}"#+"K"
    # plt.title(titre)
    # plt.title("Distribution of cells depending on their temperature out of the mean temperature")
    # plt.show()


def ratios(plog, tlog, ne_log, m_tot, unit, sp, sne, st,alpha):
    def mhex(i, tlog, ne_log, unit):
        r_bin = i
        b = 0.05
        dt = np.gradient(tlog, b)
        dne = np.gradient(ne_log, b)
        dt = dt[r_bin]
        dne = dne[r_bin]
        if unit == 0:
            m = (((-10 ** ((i + 35) * 0.05) * kb * 10 ** tlog[r_bin]) / (g * mu * mp)) * (dne + dt)) * (
                    (1E3 * pc) / m_sun)

        if unit == 1:
            m = (((-10 ** ((i + 35) * 0.05) * 10 ** tlog[r_bin]) / (g * mu * mp)) * (dne + dt)) * (
                    (1E3 * pc * kev) / m_sun)

            invt = np.array([1 / (10 ** tlog[i]) for i in range(len(tlog))])
            #print("invt", invt)
            dinvt = np.gradient(invt, b)
            dinvt = dinvt[r_bin]

            invne = np.array([1 / (10 ** ne_log[i]) for i in range(len(ne_log))])
            #print("invp", invne)
            dinvne = np.gradient(invne, b)
            dinvne = dinvne[r_bin]

            dmdne = -((10 ** ((i + 35) * 0.05) * dinvne * 10 ** tlog[i]) / (g * mu * mp)) * ((1E3 * pc * kev) / m_sun)
            dmdt = m / (10 ** tlog[r_bin]) - ((10 ** ((i + 35) * 0.05) * dinvt * 10 ** tlog[i]) / (g * mu * mp)) * (
                        (1E3 * pc * kev) / m_sun)
            sm = np.sqrt(
                dmdne ** 2 * (10 ** sne[i] * 10 ** ne_log[i]) ** 2 + dmdt ** 2 * (10 ** st[i] * 10 ** tlog[i]) ** 2)
            #print("sm", sm)
            #print("m", m)

        return m, sm, dne, dt

    def mhesz(i, plog, ne_log, unit, sp, sne):
        b = 0.05
        r_bin = i
        dp = np.gradient(plog, b)
        dp = dp[r_bin]
        if unit == 0:
            mg = ((-10 ** ((i + 35) * 0.05) * 10 ** plog[r_bin] * dp) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                    (1E3 * pc) / m_sun)
        if unit == 1:
            m = ((-10 ** ((i + 35) * 0.05) * 10 ** plog[r_bin] * dp) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                    (1E3 * pc * kev) / m_sun)

            invp = np.array([1 / (10 ** plog[i]) for i in range(len(plog))])
            # print("invp",invp)
            dinvp = np.gradient(invp, b)
            dinvp = dinvp[r_bin]
            # print("dinvp",dinvp)
            dmdne = -m / (10 ** ne_log[r_bin])
            dmdp = m / (10 ** plog[r_bin]) - (
                        (10 ** ((i + 35) * 0.05) * dinvp * 10 ** plog[i]) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                               (1E3 * pc * kev) / m_sun)
            # dmdp=0
            sm = np.sqrt(
                dmdne ** 2 * (10 ** sne[i] * 10 ** ne_log[i]) ** 2 + dmdp ** 2 * (10 ** sp[i] * 10 ** plog[i]) ** 2)
            # print("sne",sne[i])
            # print("sp",sp[i])
            # print("dmdne",dmdne)
            # print("dmdp",dmdp)
            # print("sm",sm)
            # print("m ",m)
            # sys.exit()
        return m, sm, dp

    def mhecorr(i,plog,ne_log,mhesz,alpha):
        b = 0.05
        r_bin = i
        dalpha = np.gradient(alpha, b)
        dalpha = dalpha[r_bin]
        #print("dalpha",dalpha)
        mcorr=(1/(1-alpha[r_bin]))*(mhesz-(alpha[r_bin]/(1-alpha[r_bin]))* ((10 ** ((i + 35) * 0.05) * 10 ** plog[r_bin] * dalpha) / (g * mu * mp * 10 ** ne_log[r_bin]))* (
                    (1E3 * pc * kev) / m_sun))
        #print("mcorr",mcorr)
        return mcorr



    def compar_bias(i, plog, tlog, ne_log, m_tot,alpha):
        mxlog, smx, dne, dt = mhex(i, tlog, ne_log, unit)
        # print("mhexlog", f"{mxlog:.3e}", "M_sun")
        mszlog, smsz, dp = mhesz(i, plog, ne_log, unit, sp, sne)
        mcorr=mhecorr(i,plog,ne_log,mszlog,alpha)
        return mxlog / m_tot[i], mszlog / m_tot[i], dne, dt, dp, smx / m_tot[i], smsz / m_tot[i], mcorr / m_tot[i]
        # return mxlog,mszlog,dne,dt,dp,smx,smsz

    bx = np.zeros(40)
    bsz = np.zeros(40)
    dne = np.zeros(40)
    dt = np.zeros(40)
    dp = np.zeros(40)
    smx = np.zeros(40)
    smsz = np.zeros(40)
    bcorr = np.zeros(40)

    for i in range(40):
        bx[i], bsz[i], dne[i], dt[i], dp[i], smx[i], smsz[i], bcorr[i] = compar_bias(i, plog, tlog, ne_log, m_tot, alpha)
    rlogbin = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])
    print("mtot r500",f"{m_tot[25]:.3e}")
    print("mhe r500",f"{m_tot[25]*bsz[25]:.3e}")
    print("mhe r500 corr",f"{m_tot[25]*bcorr[25]:.3e}")

    #print("presure derivative",dp)
    #sys.exit()

    def derivatives_plot():
        plt.plot(rlogbin, dne, label="dln(n_e)/dln(r)")
        plt.plot(rlogbin, dt, label="dln(T)/dln(r)")
        plt.plot(rlogbin, dp, label="dln(P)/dln(r)")
        plt.plot(rlogbin, dt + dne, label="dln(T)/dln(r)+dln(ne)/dln(r)", ls='dashed')
        plt.axvline(x=1087, color='grey', label='$R_{500}$')
        plt.axvline(x=2024, color='grey', ls='dashed', label='$R_{Vir}$')
        plt.axvline(x=850, color='black', ls='dashed', label='$R_{bump}$')
        plt.legend()
        plt.show()
        sys.exit()

    #print("smsz", smsz)
    #print("smx", smx)

    # sys.exit()
    return bx, bsz, smx, smsz,bcorr

def ratios_dep():


    d = FortranFile("rad_log_dm_21.dat", 'r')

    mdm = d.read_reals()
    mdm_sum = np.array([np.sum(mdm[0:i]) for i in range(21)])

    b = FortranFile("rad_log_baryons_21.dat", 'r')

    mb = b.read_reals()
    mb_sum = np.array([np.sum(mb[0:i]) for i in range(21)])

    m_tot=mdm_sum+mb_sum

    m_cumul_dm = np.load("m_cumul_dm_21.npy")
    m_cumul_ba = np.load("m_cumul_ba_21.npy")
    m_cumul_sum = m_cumul_dm + m_cumul_ba

    m_tot = m_cumul_sum

    rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(21)])

    #plt.plot(rlogbin_cen,m_tot)
    #plt.show()

    x_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_x_h.txt")
    y_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_y_h.txt")
    z_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_z_h.txt")
    cen_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_MW_h.txt")
    fil_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_fil_h.txt")
    filx_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_filx_h.txt")
    fily_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_fily_h.txt")

    sx_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_x_h.txt")
    sy_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_y_h.txt")
    sz_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_z_h.txt")
    scen_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_MW_h.txt")
    sfil_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_fil_h.txt")
    sfilx_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_filx_h.txt")
    sfily_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_fily_h.txt")

    x_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_x_h.txt")
    y_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_y_h.txt")
    z_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_z_h.txt")
    cen_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_cen_h.txt")
    fil_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_fil_h.txt")
    filx_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_filx_h.txt")
    fily_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_fily_h.txt")

    sx_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_x_h.txt")
    sy_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_y_h.txt")
    sz_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_z_h.txt")
    scen_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_cen_h.txt")
    sfil_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_fil_h.txt")
    sfilx_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_filx_h.txt")
    sfily_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_fily_h.txt")

    #print(rlogbin_cen[12])


    def fitting_profs(p,ne,r):
        r500 = 1087
        p=10**p
        p500=p[12]
        pratio=np.log10(p/p500)

        popt, pcov = curve_fit(upplog, r / r500, pratio, p0=[6.41, 1.81, 1.33, 4.13, 0.31],bounds=([0, 0, 0, 0, -10], [600, 20, 10, 15, 10]), method='trf')

        popt_ne, pcov_ne = curve_fit(log_beta_model, r, ne)

        print("popt p", popt)
        print("sigma p", np.sqrt(np.diagonal(pcov)))
        print("popt ne",popt_ne)
        print("sigma ne", np.sqrt(np.diagonal(pcov_ne)))

        pfit = np.log10(10 ** (upplog(r / r500, *popt)) * p500)
        nefit = log_beta_model(rlogbin_cen, *popt_ne)

        return pfit, nefit

    print("cen")
    cen_p_fit,cen_ne_fit=fitting_profs(cen_p,cen_ne,rlogbin_cen)

    print("fil")
    fil_p_fit, fil_ne_fit = fitting_profs(fil_p, fil_ne, rlogbin_cen)

    print("filx")
    filx_p_fit, filx_ne_fit = fitting_profs(filx_p, filx_ne, rlogbin_cen)

    print("fily")
    fily_p_fit, fily_ne_fit = fitting_profs(fily_p, fily_ne, rlogbin_cen)

    #sys.exit()

    r500=1087

    def plot_p_fit():
        Plogmed_c8, Pstdlogmed_c8, Plogmean_c8, Pstdlogmean_c8, Tlogmed_c8, Tstdlogmed_c8, Tlogmean_c8, Tstdlogmean_c8, nelogmed_c8, nestdlogmed_c8, nelogmean_c8, nestdlogmean_c8, nlog_c8, mlog_c8, ndm_c8, mdm_c8, inf_c8, middle_c8, sup_c8 = load_lograd_dat("lograd_data_lvl21_cleanm1e8.5.npy")

        plt.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        plt.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True, labelleft=True)

        plt.plot(rlogbin_cen/r500,cen_p,label="Cen",color="forestgreen",ls="dashed")
        plt.plot(rlogbin_cen/r500,cen_p_fit,label="Cen fitted",color='forestgreen',ls="dotted")

        plt.plot(rlogbin_cen / r500, fil_p, label="Fil", color="skyblue", ls="dashed")
        plt.plot(rlogbin_cen / r500, fil_p_fit, label="Fil fitted", color='skyblue', ls="dotted")

        plt.plot(rlogbin_cen / r500, filx_p, label="Filx", color="red", ls="dashed")
        plt.plot(rlogbin_cen / r500, filx_p_fit, label="Filx fitted", color='red', ls="dotted")

        plt.plot(rlogbin_cen / r500, fily_p, label="Fily", color="purple", ls="dashed")
        plt.plot(rlogbin_cen / r500, fily_p_fit, label="Fily fitted", color='purple', ls="dotted")

        rlogbin_3D = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])
        plt.plot(rlogbin_3D/r500,Plogmean_c8,label="3D",ls="solid",marker='.',color='orange')
        plt.xscale('log')
        plt.xlabel('$R/R_{500}$',size=16)
        #plt.ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{e}}$[c$\mathrm{m^{-3}}$])", size=16)
        plt.ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)
        plt.axvline(x=1087/r500, color='grey')
        plt.text(1087/r500, -6, "$\mathrm{R_{500}}$", rotation=90, size=16)
        plt.axvline(x=2147/r500, color='grey', ls='dashed')
        plt.text(2147/r500, -6, "$\mathrm{R_{vir}}$", rotation=90, size=16)
        plt.legend(prop={'size': 16})

        plt.legend()
        plt.show()
        sys.exit()

    def mhex(i, tlog, ne_log, unit):
        r_bin = i
        b = 0.05
        dt = np.gradient(tlog, b)
        dne = np.gradient(ne_log, b)
        dt = dt[r_bin]
        dne = dne[r_bin]
        if unit == 0:
            m = (((-10 ** ((i + 35) * 0.05) * kb * 10 ** tlog[r_bin]) / (g * mu * mp)) * (dne + dt)) * (
                    (1E3 * pc) / m_sun)

        if unit == 1:
            m = (((-10 ** ((i + 35) * 0.05) * 10 ** tlog[r_bin]) / (g * mu * mp)) * (dne + dt)) * (
                    (1E3 * pc * kev) / m_sun)

            invt = np.array([1 / (10 ** tlog[i]) for i in range(len(tlog))])
            print("invt", invt)
            dinvt = np.gradient(invt, b)
            dinvt = dinvt[r_bin]

            invne = np.array([1 / (10 ** ne_log[i]) for i in range(len(ne_log))])
            print("invp", invne)
            dinvne = np.gradient(invne, b)
            dinvne = dinvne[r_bin]

            dmdne = -((10 ** ((i + 35) * 0.05) * dinvne * 10 ** tlog[i]) / (g * mu * mp)) * ((1E3 * pc * kev) / m_sun)
            dmdt = m / (10 ** tlog[r_bin]) - ((10 ** ((i + 35) * 0.05) * dinvt * 10 ** tlog[i]) / (g * mu * mp)) * (
                        (1E3 * pc * kev) / m_sun)
            sm = np.sqrt(
                dmdne ** 2 * (10 ** sne[i] * 10 ** ne_log[i]) ** 2 + dmdt ** 2 * (10 ** st[i] * 10 ** tlog[i]) ** 2)
            print("sm", sm)
            print("m", m)

        return m, sm, dne, dt

    def mhesz(i, plog, ne_log, unit, sp, sne):
        b = 0.1
        r_bin = i
        dp = np.gradient(plog, b)
        dp = dp[r_bin]
        if unit == 0:
            mg = ((-10 ** ((i + 35) * 0.05) * 10 ** plog[r_bin] * dp) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                    (1E3 * pc) / m_sun)
        if unit == 1:
            m = ((-10 ** ((i + 18) * 0.1) * 10 ** plog[r_bin] * dp) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                    (1E3 * pc * kev) / m_sun)

            invp = np.array([1 / (10 ** plog[i]) for i in range(len(plog))])
            # print("invp",invp)
            dinvp = np.gradient(invp, b)
            dinvp = dinvp[r_bin]
            # print("dinvp",dinvp)
            dmdne = -m / (10 ** ne_log[r_bin])
            dmdp = m / (10 ** plog[r_bin]) - (
                        (10 ** ((i + 18) * 0.1) * dinvp * 10 ** plog[i]) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                               (1E3 * pc * kev) / m_sun)
            # dmdp=0
            sm = np.sqrt(
                dmdne ** 2 * (10 ** sne[i] * 10 ** ne_log[i]) ** 2 + dmdp ** 2 * (10 ** sp[i] * 10 ** plog[i]) ** 2)
            # print("sne",sne[i])
            # print("sp",sp[i])
            # print("dmdne",dmdne)
            # print("dmdp",dmdp)
            # print("sm",sm)
            # print("m ",m)
            # sys.exit()
        return m, sm, dp

    def compar_bias(i, plog, ne_log, m_tot,sp,sne):
        #mxlog, smx, dne, dt = mhex(i, tlog, ne_log, unit)
        # print("mhexlog", f"{mxlog:.3e}", "M_sun")
        mszlog, smsz, dp = mhesz(i, plog, ne_log, 1, sp, sne)
        # print("mhesz_log", f"{mszlog:.3e}", "M_sun")
        return  mszlog / m_tot[i], dp, smsz / m_tot[i]
        # return mxlog,mszlog,dne,dt,dp,smx,smsz

    nbin=21
    bx = np.zeros(nbin)
    bsz = np.zeros(nbin)
    dne = np.zeros(nbin)
    dt = np.zeros(nbin)
    dp = np.zeros(nbin)
    smx = np.zeros(nbin)
    smsz = np.zeros(nbin)

    bcenfit = np.zeros(nbin)
    bfilfit = np.zeros(nbin)
    bfilxfit = np.zeros(nbin)
    bfilyfit = np.zeros(nbin)

    bcen = np.zeros(nbin)
    bfil = np.zeros(nbin)
    bfilx = np.zeros(nbin)
    bfily = np.zeros(nbin)

    for i in range(nbin):
        #bsz[i],dp[i],smsz[i] = compar_bias(i, fily_p, fily_ne, m_tot,sfily_p,sfily_ne)
        bcenfit[i], dp[i], smsz[i] = compar_bias(i, cen_p_fit, cen_ne_fit, m_tot, scen_p, scen_ne)
        bfilfit[i], dp[i], smsz[i] = compar_bias(i, fil_p_fit, fil_ne_fit, m_tot, scen_p, scen_ne)
        bfilxfit[i], dp[i], smsz[i] = compar_bias(i, filx_p_fit, filx_ne_fit, m_tot, scen_p, scen_ne)
        bfilyfit[i], dp[i], smsz[i] = compar_bias(i, fily_p_fit, fily_ne_fit, m_tot, scen_p, scen_ne)

        bcen[i], dp[i], smsz[i] = compar_bias(i, cen_p, cen_ne, m_tot, scen_p, scen_ne)
        bfil[i], dp[i], smsz[i] = compar_bias(i, fil_p, fil_ne, m_tot, scen_p, scen_ne)
        bfilx[i], dp[i], smsz[i] = compar_bias(i, filx_p, filx_ne, m_tot, scen_p, scen_ne)
        bfily[i], dp[i], smsz[i] = compar_bias(i, fily_p, fily_ne, m_tot, scen_p, scen_ne)

    rlogbin_3D = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])
    rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(21)])

    #print("rlobbincen",rlogbin_cen)
    #sys.exit()


    #print("pressure derivative",dp)

    #print("bsz",bsz)

    #np.savetxt("fily_bias",bsz)

    #bx = np.loadtxt("x_bias")
    #by = np.loadtxt("y_bias")
    #bz = np.loadtxt("z_bias")
    #bcen = np.loadtxt("cen_bias")
    #bfil = np.loadtxt("fil_bias")
    #bfilx = np.loadtxt("filx_bias")
    #bfily = np.loadtxt("fily_bias")
    b3d = np.load("bsz_virgo_3D_h.npy")

    print("bcen",bcen)


    print("mtot r500", f"{m_tot[12]:.3e}")
    print("mhe r500 cen", f"{m_tot[12] * bcen[12]:.3e}")
    print("mhe r500 fil", f"{m_tot[12] * bfil[12]:.3e}")
    print("mhe r500 filx", f"{m_tot[12] * bfilx[12]:.3e}")
    print("mhe r500 fily", f"{m_tot[12] * bfily[12]:.3e}")

    print("mhe r500 cen fit", f"{m_tot[12] * bcenfit[12]:.3e}")
    print("mhe r500 fil fit", f"{m_tot[12] * bfilfit[12]:.3e}")
    print("mhe r500 filx fit", f"{m_tot[12] * bfilxfit[12]:.3e}")
    print("mhe r500 fily fit", f"{m_tot[12] * bfilyfit[12]:.3e}")

    #sys.exit()

    def fitted_bias_plot():

        b3d_fit=np.load("fitted_3D_bias.npy")

        r500 = 1087
        un = [1 for i in range(21)]
        zerohuit = [0.8 for i in range(21)]
        un = np.array(un)
        zerohuit = np.array(zerohuit)

        f, (a, b) = plt.subplots(2, 1)

        a.plot(rlogbin_3D, b3d, label="3D, $8192^3$, no fit", ls="solid", marker=".", color='orange')
        a.plot(rlogbin_cen, bfil, label="Fil, no fit", color="blue", ls='dotted', marker='.')
        a.plot(rlogbin_cen, bfilx, label="Filx, no fit", color="green", ls='dashed', marker='.')
        a.plot(rlogbin_cen, bfily, label="Fily, no fit", color="dimgrey", ls='dashdot', marker='.')
        a.plot(rlogbin_cen, bcen, label="Cen, no fit", color="red", ls='solid', marker='.')
        a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
        # a.plot(rlogbin, zerohuit, color='grey')
        # a.plot(rlogbin, un, color='black')
        a.set_xscale('log')
        a.legend(prop={'size': 16})
        a.set_ylabel("$(1-\mathrm{b})=rac{M_{\mathrm{HE}}}{M_{\mathrm{tot}}}$")

        a.axvline(x=1087, color='grey')  # label='$R_{500}$')
        a.axvline(x=2147, color='grey', ls='dashed')  # label='$R_{Vir}$')
        a.text(1087, 0.2, "$R_{500}$", rotation=90, size=16)
        a.text(2147, 0.2, "$R_{vir}$", rotation=90, size=16)
        a.plot(rlogbin_cen, zerohuit, color='grey')
        a.plot(rlogbin_cen, un, color='black')
        a.set_xlim(200, 4500)
        a.set_ylim(0, 6)

        b.plot(rlogbin_3D, b3d_fit, label="3D, $8192^3$, fit", ls="solid", marker=".", color='orange')
        b.plot(rlogbin_cen, bfilfit, label="Fil, fit", color="blue", ls='dotted', marker='.')
        b.plot(rlogbin_cen, bfilxfit, label="Filx, fit", color="green", ls='dashed', marker='.')
        b.plot(rlogbin_cen, bfilyfit, label="Fily, fit", color="dimgrey", ls='dashdot', marker='.')
        b.plot(rlogbin_cen, bcenfit, label="Cen, fit", color="red", ls='solid', marker='.')

        b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True, labelleft=True)
        # b.plot(rlogbin, zerohuit, color='grey')
        # b.plot(rlogbin, un, color='black')
        b.set_xscale('log')
        b.legend(prop={'size': 16})
        b.set_ylabel("$(1-\mathrm{b})=rac{M_{\mathrm{HE}}}{M_{\mathrm{tot}}}$")
        b.set_xlabel("$R \; [\mathrm{kpc}]$")

        b.axvline(x=1087, color='grey')  # label='$R_{500}$')
        b.axvline(x=2147, color='grey', ls='dashed')  # label='$R_{Vir}$')
        b.text(1087, 0.2, "$R_{500}$", rotation=90, size=16)
        b.text(2147, 0.2, "$R_{vir}$", rotation=90, size=16)
        b.plot(rlogbin_cen, zerohuit, color='grey')
        b.plot(rlogbin_cen, un, color='black')
        b.set_xlim(200, 4500)
        b.set_ylim(0, 6)

        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()
        print("end")
        sys.exit()

    fitted_bias_plot()



    plt.plot(rlogbin_3D,b3d,label="3D, $8192^3$",ls="solid",marker=".",color='orange')
    #plt.plot(rlogbin_cen,bx,label="x",color="red",ls='dashed',marker='.')
    #plt.plot(rlogbin_cen, by, label="y", color="lightgreen", ls='dashed',marker='.')
    #plt.plot(rlogbin_cen, bz, label="z", color="skyblue", ls='dashed',marker='.')

    # plt.plot(rlogbin_cen, bfil, label="Fil", color="skyblue", ls='dashed', marker='.')
    # plt.plot(rlogbin_cen, bfilx, label="Filx", color="red", ls='dashed', marker='.')
    # plt.plot(rlogbin_cen, bfily, label="Fily", color="purple", ls='dashed', marker='.')
    plt.plot(rlogbin_cen, bcen, label="Cen", color="forestgreen", ls='dashed', marker='.')

    # plt.plot(rlogbin_cen, bfilfit, label="Fil fit", color="skyblue", ls='dotted', marker='.')
    # plt.plot(rlogbin_cen, bfilxfit, label="Filx fit", color="red", ls='dotted', marker='.')
    # plt.plot(rlogbin_cen, bfilyfit, label="Fily fit", color="purple", ls='dotted', marker='.')
    plt.plot(rlogbin_cen, bcenfit, label="Cen fit", color="forestgreen", ls='dotted', marker='.')


    plt.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    plt.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    un = [1 for i in range(21)]
    zerohuit = [0.8 for i in range(21)]
    un = np.array(un)
    zerohuit = np.array(zerohuit)
    plt.plot(rlogbin_cen, zerohuit, color='grey')
    plt.plot(rlogbin_cen, un, color='black')
    plt.xscale('log')
    plt.xlabel('R (kpc)')
    plt.ylabel('$(1-\mathrm{b})=\frac{M_{\mathrm{HE}}}{M_{\mathrm{tot}}}$')
    #plt.ylabel('$(1-b)=\frac{M_{HE}}{M_{tot}}$')
    plt.axvline(x=1087, color='grey')  # label='$R_{500}$')
    plt.axvline(x=2147, color='grey', ls='dashed')  # label='$R_{Vir}$')
    plt.text(1087, 0.2, "$R_{500}$", rotation=90, size=16)
    plt.text(2147, 0.2, "$R_{vir}$", rotation=90, size=16)
    # plt.axvline(x=950, color='grey', ls='dotted')# label='$R_{bump}$')
    # plt.text(950, 1.1, "$R_{bump}$", rotation=90, size=16)
    plt.xlim(200, 4500)
    #plt.ylim(0.75, 2.1)
    plt.ylim(0, 6)
    # plt.grid()
    plt.legend()
    plt.show()
    sys.exit()

    def derivatives_plot():
        plt.plot(rlogbin, dne, label="dln(n_e)/dln(r)")
        plt.plot(rlogbin, dt, label="dln(T)/dln(r)")
        plt.plot(rlogbin, dp, label="dln(P)/dln(r)")
        plt.plot(rlogbin, dt + dne, label="dln(T)/dln(r)+dln(ne)/dln(r)", ls='dashed')
        plt.axvline(x=1087, color='grey', label='$R_{500}$')
        plt.axvline(x=2024, color='grey', ls='dashed', label='$R_{Vir}$')
        plt.axvline(x=850, color='black', ls='dashed', label='$R_{bump}$')
        plt.legend()
        plt.show()
        sys.exit()

    print("smsz", smsz)
    print("smx", smx)

    # sys.exit()
    return bx, bsz, smx, smsz

def load_lograd_dat(file):
    rad_data = np.load(file)
    Plogmed = rad_data[0, :]
    Pstdlogmed = rad_data[1, :]
    Plogmean = rad_data[2, :]
    Pstdlogmean = rad_data[3, :]
    Tlogmed = rad_data[4, :]
    Tstdlogmed = rad_data[5, :]
    Tlogmean = rad_data[6, :]
    Tstdlogmean = rad_data[7, :]
    nelogmed = rad_data[8, :]
    nestdlogmed = rad_data[9, :]
    nelogmean = rad_data[10, :]
    nestdlogmean = rad_data[11, :]
    nlog = rad_data[12, :]
    mlog = rad_data[13, :]
    ndm = rad_data[14, :]
    mdm = rad_data[15, :]
    inf = rad_data[16, :]
    middle = rad_data[17, :]
    sup = rad_data[18, :]
    print("Loading ",file,"complete")
    return Plogmed,Pstdlogmed,Plogmean,Pstdlogmean,Tlogmed,Tstdlogmed,Tlogmean,Tstdlogmean,nelogmed,nestdlogmed,nelogmean,nestdlogmean,nlog,mlog,ndm,mdm,inf,middle,sup




def projection(file,prop,filout_deproj,filout_std_deproj,obs_prof=None, plot_prof=None, deproj=None):

    def deproj_process(nbin):

        ## toy model ##

        #map=np.load(file)
        #map *= pc * 1e4 #for to model column density
        #print(map)
        #print(np.shape(map))

        h = FortranFile(file, 'r')
        map = []
        #nline = h.read_ints()
        #print("nline", nline)
        #nline = 16
        # sys.exit()
        #for i in range(nline):
        #   print(i)
        #    m = h.read_reals()
            # print("m",m)
            # sys.exit()
        #    map = np.concatenate((map, m))

        ####

        #h = FortranFile(file, 'r')
        #nx,ny,nz = h.read_ints()
        #cen_x,cen_y,cen_z = h.read_reals()
        map = h.read_reals()
        map=np.array(map)
        px=int(np.sqrt(len(map)))
        print('px',px)
        map = np.reshape(map, (px, px))


        print("file loaded")
        #sys.exit()
        #print("max T", max(map))
        #print("min T", min(map))
        if prop=="T":
            map /= (kb / 1.602e-16)
            #print("max T",max(map))
            #print("min T",min(map))


        min_x = 0
        max_x = len(map[:, 0])

        min_y = 0
        max_y = len(map[0, :])
        print("max x", max_x,"max y",max_y)

        cen_x = int(max_x / 2)
        cen_y = int(max_y / 2)

        #print(cen_x, cen_y)

        #d = np.array([[np.log10(np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 22.5049133) for i in range(max_x)] for j in range(max_y)]) #still useful for toy model tests
        #d = np.array([[np.log10(np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 0.3516375) for i in range(max_x)] for j in range(max_y)])
        #np.save("map_distances_lvl15_666.npy",d)

        #print("distances saved")
        #sys.exit()

        #d = np.loadtxt('map_distances_11.25245.npy')
        #if px==2000:
        #    d = np.loadtxt('map_distances_2000_10')
        #if px==4000:
        #    d = np.load('map_distances_4000_5.npy')
        #d = np.load('map_distances_8000_2.5.npy')
        #d=np.load('map_distances_12000_1.67.npy')
        #d = np.load('map_distances_16000_1.25.npy')
        #if px==10000:
        #    d = np.load('map_distances_10000_2.npy')
        #if px==1000:
        #    d = np.load('map_distances_1000_20.npy')
        #d = np.load('map_distances_3000_6.67.npy')
        #d = np.load('map_distances_1500_13.33.npy')
        #d = np.load('map_distances_22.504.npy')
        #d = np.load('map_distances_5.6262.npy')
        d = np.load('maps/map_distances_1.4065.npy')
        #d = np.load('map_distances_lvl15_proj_vel.npy')
        #d=np.load("map_distances_lvl15_666.npy")
        #print("shape d",np.shape(d))
        #print("max lvl 15 map",np.max(d))


        #sys.exit()

        print("distances loaded")



        map_bg = map[np.logical_and(d > np.log10(8000), d < np.log10(10000))]
        #map_bg = map[np.logical_and(d > np.log10(8000), map<1)]
        #noise = np.nanmean(map_bg[map_bg<np.inf])
        noise = np.nanmean(map_bg)
        #noise=0
        print("noise", noise)

        #map=map[map<1]

        #sys.exit()

        #print("len d",len(d[0,:]))
        #print("min d", np.min(d))
        #print("max d", np.max(d))
        #noise=0 ##for toy model tests

        def show_map():
            dim = 5
            dim = [-dim, dim, -dim, dim]
            plt.imshow(map, cmap="inferno", origin='lower', alpha=1, extent=dim, vmin=-8, vmax=-1.5)
            plt.colorbar()

            xpx = np.linspace(-5, 5, 2000)
            ypx = np.linspace(-5, 5, 2000)

            Xpx, Ypx = np.meshgrid(xpx, ypx)

            F = Xpx ** 2 + Ypx ** 2 - (2024 * (10 / 1e4)) ** 2  # rvir
            rvir = plt.contour(Xpx, Ypx, F, [0], colors='white', linewidths=0.6, alpha=0.9)
            plt.clabel(rvir, rvir.levels, inline=True, fmt="$R_{vir}$", fontsize=10)
            F = Xpx ** 2 + Ypx ** 2 - (5031 * (10 / 1e4)) ** 2  # rzv
            rzv = plt.contour(Xpx, Ypx, F, [0], colors='grey', linewidths=0.6, alpha=0.9)
            plt.clabel(rzv, rzv.levels, inline=True, fmt="$R_{zero\,velocity}$", fontsize=10)
            F = Xpx ** 2 + Ypx ** 2 - (2 * 2024 * (10 / 1e4)) ** 2  # rvir
            drvir = plt.contour(Xpx, Ypx, F, [0], colors='white', linewidths=0.6, alpha=0.9)
            plt.clabel(drvir, drvir.levels, inline=True, fmt="$2R_{vir}$", fontsize=10)
            # plt.scatter(x[i], y[i], alpha=0.9, s=1, c='white')
            plt.show()
            sys.exit()

        def monte_carlo(prop, iteration,noise):
            inf = np.random.uniform(1.6989, 2) #[50,100]kpc
            #inf=1.6989 #for toy model tests
            sup = np.random.uniform(3.602, 3.7781) #[4,6]Mpc
            #sup = np.random.uniform(3.602, 3.69897) #[4,5]Mpc
            #sup = np.random.uniform(3.6989, 3.7781)  # [5,6]Mpc
            #sup = np.random.uniform(3.69, 3.695) ##for toy model tests
            #sup=3.69897 #for toy model tests
            #sup=3.7781
            #print("lim sup",10**sup)
            divider=0.1
            #print("divider",divider)
            n = int((sup - inf) / divider)

            #print("n", n)
            #sys.exit()
            r = np.linspace(inf, sup, n + 1)
            r_cen = np.array([r[i] + 0.5 * (r[i + 1] - r[i]) for i in range(n)])
            rlogbin = np.array([10 ** (r_cen[i]) for i in range(n)])

            meanprof = np.array([np.nanmean(map[np.logical_and(d > r[i], d < r[i + 1])]) for i in range(n)])
            medprof = np.array([np.nanmedian(map[np.logical_and(d > r[i], d < r[i + 1])]) for i in range(n)])

            #####  deproj  ######
            if prop=="P":
                #noise=0
                projp=meanprof-noise

            def f_bg(rim1,ri,rm,rmm1,alpha):
                if alpha==2:
                    #print("r(n-1)",r[n-1])
                    #print("r(n)",r[n])
                    return ((rmm1+rm)/(rim1+ri))*(1-(2/np.pi)*(((np.arccos(ri/rm)-(rim1/ri)*np.arccos(rim1/rm))-(np.sqrt((rm/ri)**2-1)-np.sqrt((rm/ri)**2-(rim1/ri)**2)))/(1-rim1/ri)))

            #if prop=="ne":
            #    print("ne")
                #rm=np.array([1e3*pc*10**r[i] for i in range(n+1)])
                #bg_sub=np.array([f_bg(rm[i],rm[i+1],rm[n],rm[n-1],2) for i in range(n)])
                #print("meanprof",meanprof)
                #print("bg_sub",bg_sub)
                #projp=meanprof*(1-bg_sub)
            #    projp=meanprof
                #print("projp",projp)




            #projp=meanprof
            #print("projp", projp)

            r = np.array([pc * 1e3 * 10 ** r[i] for i in range(n + 1)])

            if prop == "ne":
                projp=meanprof
                #print("projp",projp)
                #print("noise",noise)
                noise/=(22.123*pc*1e6)
                #noise=0
                #print("noise",noise)
                #projp-=noise
                #print("projp",projp)
                #sys.exit()



            @jit(nopython=True)
            def vol_int(rjm1, rj, rim1, ri):
                if rj == ri:
                    v = ((4 * np.pi) / 3) * (ri ** 2 - rim1 ** 2) ** 1.5
                else:
                    parent1=(rj ** 2 - rim1 ** 2)
                    parent2=(rj ** 2 - ri ** 2)
                    parent3=(rjm1 ** 2 - ri ** 2)
                    parent4=(rjm1 ** 2 - rim1 ** 2)
                    if parent1<0:
                        parent1=0
                    if parent2<0:
                        parent2=0
                    if parent3<0:
                        parent3=0
                    if parent4<0:
                        parent4=0
                    #v = ((4 * np.pi) / 3) * ((rj ** 2 - rim1 ** 2) ** 1.5 - (rj ** 2 - ri ** 2) ** 1.5 + (rjm1 ** 2 - ri ** 2) ** 1.5 - (rjm1 ** 2 - rim1 ** 2) ** 1.5)
                    v = ((4 * np.pi) / 3) * (parent1 ** 1.5 - parent2 ** 1.5 + parent3 ** 1.5 - parent4 ** 1.5)

                return v

            deprojp = np.zeros(n)
            rlast = r[n]

            #print("max x",max_x)
            depthlos = 22.12323 * 1e6 * pc
            depth = 2*10**sup *1e3* pc

            deprojp[n - 1] = projp[n - 1]
            vlos=np.pi * (rlast ** 2 - r[n - 1] ** 2) * depth
            #print("vlos",vlos)
            vdeproj=vol_int(r[n - 1], rlast, r[n - 1], rlast)
            #print("vdeproj",vdeproj)
            #deprojp[n-1]=(projp[n-1]*vlos- noise * (vlos-vdeproj))/vdeproj
            ratio = vlos/vdeproj

            @jit(nopython=True)
            def deproj_algo(ratio,deprojp,r,rlast):
                #print("ratio",ratio)
                if (prop=="P" or prop=="T"):
                    deprojp[n-1]*=ratio
                    #print("deprojp[n-1]",deprojp[n - 1])
                if (prop == "ne"):
                    deprojp[n - 1] = (deprojp[n-1]*np.pi * (rlast ** 2 - r[n - 1] ** 2)-noise*(np.pi*(rlast ** 2 - r[n - 1] ** 2)* depthlos-vdeproj)) / vol_int(r[n - 1], rlast, r[n - 1], rlast)
                    #print("proportion",(np.pi*(rlast ** 2 - r[n - 1] ** 2) * depthlos-vdeproj)/vdeproj)
                    #print("deprojp[n-1]",deprojp[n-1])
                    #deprojp[n - 1] *= (np.pi * (rlast ** 2 - r[n - 1] ** 2) )/ (vol_int(r[n - 1], rlast, r[n - 1], rlast)) #formule avant test
                    #sys.exit()

                for i in range(0, n - 1):
                    sumpv = 0
                    sumv = vol_int(r[n - i - 2], r[n - i - 1], r[n - i - 2], r[n - i - 1])
                    for j in range(n - i- 1, n):
                        sumv += vol_int(r[j], r[j+1], r[n - i - 2], r[n - i - 1])
                        sumpv += deprojp[j] * vol_int(r[j], r[j+1], r[n - i - 2], r[n - i - 1])

                    if (prop == "T" or prop == "P"):
                        #deprojp[n - i - 2] = (projp[n - i - 2] * sumv - sumpv) / vol_int(r[n - i - 2], r[n - i - 1],r[n - i - 2], r[n - i - 1])
                        deprojp[n - i - 2] = (projp[n - i - 2] * (np.pi * (r[n - i - 1] ** 2 - r[n - i - 2] ** 2) * depth) - sumpv) / vol_int(r[n - i - 2], r[n - i - 1],r[n - i - 2], r[n - i - 1])
                        #deprojp[n - i - 2] = (projp[n - i - 2] * vol_int(r[n - i - 2], r[n], r[n - i - 2], r[n - i - 1]) - sumpv) / vol_int(r[n - i - 2], r[n - i - 1],r[n - i - 2], r[n - i - 1])
                        #print("vol int",vol_int(r[n - i - 2], r[n], r[n - i - 2], r[n - i - 1]))
                    elif (prop == "ne"):
                        deprojp[n - i - 2] = (projp[n - i - 2] * np.pi * (r[n - i - 1] ** 2 - r[n - i - 2] ** 2) -noise*(np.pi * (r[n - i - 1] ** 2 - r[n - i - 2] ** 2)*depthlos-vol_int(r[n - i - 2], r[n], r[n - i - 2], r[n - i - 1]))- sumpv) / vol_int(r[n - i - 2], r[n - i - 1], r[n - i - 2], r[n - i - 1])
                        #deprojp[n - i - 2] = (projp[n - i - 2] * np.pi * (r[n - i - 1] ** 2 - r[n - i - 2] ** 2) - sumpv) / vol_int(r[n - i - 2], r[n - i - 1], r[n - i - 2], r[n - i - 1]) ##avant test bg
                        #deprojp[n - i - 2] = projp[n - i - 2] * np.pi * (r[n - i - 1] ** 2 - r[n - i - 2] ** 2) / vol_int(r[n - i - 2], r[n - i - 1], r[n - i - 2], r[n - i - 1]) + (0.75*f_bg(r[n-i-1],r[n-i-2],r[n],r[n-1],2)*projp[n-1])/np.sqrt(r[n-i-1]**2-r[n-i-2]**2)
                        #print("fbg",f_bg(r[n-i-1],r[n-i-2],r[n],r[n-1],2))
                        #print("proportion",(np.pi * (r[n - i - 1] ** 2 - r[n - i - 2] ** 2)*depthlos-vol_int(r[n - i - 2], r[n - i - 1], r[n - i - 2], r[n - i - 1]))/vol_int(r[n - i - 2], r[n - i - 1], r[n - i - 2], r[n - i - 1]))
                return deprojp

            deprojp=deproj_algo(ratio,deprojp,r,rlast)

            if (prop=="ne" or prop=="P"):
                deprojp=np.log10(deprojp)
                meanprof=np.log10(meanprof)
                #print("deprojp",deprojp)

            if (prop=="T"):
                #deprojp *= (kb / 1.602e-16)
                deprojp=np.log10(deprojp)

            #print("deprojp",deprojp)

            return_rlogbin = np.zeros(nmax)
            return_rlogbin[0:n] = rlogbin
            return_deprojp = np.zeros(nmax)
            return_deprojp[0:n] = deprojp
            return_proj_prof = np.zeros(nmax)
            return_proj_prof[0:n] = meanprof

            return n, return_rlogbin, return_deprojp, return_proj_prof

        n_it =100
        #nbin = 21
        nmax = nbin + 1
        #nmax=43
        #nbin=42

        r_mc = np.zeros((nmax, n_it))
        prof_mc = np.zeros((nmax, n_it))
        proj_prof_mc = np.zeros((nmax, n_it))
        n_bin = np.zeros(n_it)

        global rlogbin_cen

        #divider=2.1/nbin
        divider = 0.1
        #print("divider",divider)
        #multip= nbin//21
        multip=1
        #print("multip",multip)
        start=18*multip
        #print("start",start)


        rlogbin_cen = np.array([10 ** ((start + i) * divider) for i in range(nbin)])
        #print("rlogbincen",rlogbin_cen)
        #print("nbin",nbin)
        #sys.exit()
        #sys.exit()

        #rlogbin_cen = np.array([10 ** ((72 + i) * 0.025) for i in range(nbin)])
        #rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(nbin)])
        #rlogbin_cen = np.array([10 ** ((36 + i) * 0.05) for i in range(nbin)])
        rlogbin = np.array([10 ** ((17.5 + i) * 0.1) for i in range(nbin+1)])
        print("rlogbincen",rlogbin_cen)
        interp_deproj_prof = np.zeros((nbin,n_it))
        interp_proj_prof = np.zeros((nbin, n_it))

        for i in range(n_it):
            print(i)
            n_bin[i], r_mc[:, i], prof_mc[:, i], proj_prof_mc[:, i] = monte_carlo(prop, i,noise)

            #plt.plot(r_mc[0:int(n_bin[i]), i], prof_mc[0:int(n_bin[i]), i], lw=0.5, alpha=0.8, color='red',ls='dashed',marker='.',markersize=2)#, label='deprojected profile')
            #plt.plot(r_mc[0:int(n_bin[i]), i], proj_prof_mc[0:int(n_bin[i]), i], lw=0.5, alpha=0.8, color='red', ls='dashed',marker='.', markersize=2)  # , label='deprojected profile')


            f_interp_lin = interp1d(r_mc[0:int(n_bin[i]), i], prof_mc[0:int(n_bin[i]), i],fill_value='extrapolate')
            f_interp_lin_proj = interp1d(r_mc[0:int(n_bin[i]), i], proj_prof_mc[0:int(n_bin[i]), i], fill_value='extrapolate')

            #f_interp_cub = interp1d(r_mc[0:int(n_bin[i]), i], prof_mc[0:int(n_bin[i]), i], kind='cubic',fill_value='extrapolate')

            #xinterp=np.linspace(0,7000,num=200)
            #yinterp=f_interp_lin(xinterp)

            #plt.plot(xinterp,yinterp,alpha=0.1,lw=1,color='red')

            interp_deproj_prof[:,i]=[f_interp_lin(rlogbin_cen[i]) for i in range(nbin)]
            interp_proj_prof[:, i] = [f_interp_lin_proj(rlogbin_cen[i]) for i in range(nbin)]

            #np.savetxt("deproj_p_z_3000px_low.txt", prof_mc[0:int(n_bin[i])])
            #np.savetxt("r_deproj_px_tests_low.txt", r_mc[0:int(n_bin[i])])

            #plt.plot(rlogbin_cen, interp_deproj_prof[:,i],lw=0.5, alpha=0.8, color='grey',ls='solid',marker='.',markersize=2)
            #np.savetxt("deproj_tm_mw_21bins_2.txt",prof_mc[0:int(n_bin[i]), i])
            #np.savetxt("r_deproj_tm_mw_21bins_2.txt",r_mc[0:int(n_bin[i]), i])
            #plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            #plt.ylabel("$log_{10}(T[keV])$", size=14)
        #plt.xscale('log')
        #plt.axvline(x=1087, color='grey')
        #plt.text(1087, -7, "$R_{500}$", rotation=90, size=16)
        #plt.axvline(x=2147, color='grey', ls='dashed')
        #plt.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
        #plt.xlabel("R(kpc)", size=16)
        #plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
        #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
        #threedprof = np.loadtxt("3d_prof_toy_model_3.txt")
        #plt.plot(rlogbin_cen, threedprof, marker='.', ls='dashed', alpha=0.8, lw=0.5, label='3d')
        #plt.legend(prop={'size': 16})
        #plt.show()
        #np.savetxt("r_deproj_px_tests.txt",r_mc[0:int(n_bin[i])])
        #sys.exit()

        global mean_deproj_prof
        global std_deproj_prof
        global mean_proj_prof
        global std_proj_prof

        mean_deproj_prof = np.zeros(nbin)
        std_deproj_prof = np.zeros(nbin)
        mean_proj_prof = np.zeros(nbin)
        std_proj_prof = np.zeros(nbin)

        mean_deproj_prof=[np.nanmean(interp_deproj_prof[i,:]) for i in range(nbin)]
        std_deproj_prof=[np.nanstd(interp_deproj_prof[i,:]) for i in range(nbin)]
        mean_proj_prof = [np.nanmean(interp_proj_prof[i, :]) for i in range(nbin)]
        std_proj_prof = [np.nanstd(interp_proj_prof[i, :]) for i in range(nbin)]

        #title=str(nbin)+' bins'
        #print("mean deproj prof",mean_deproj_prof)
        #threed_prof=np.loadtxt("./toy_models/3d_prof_toy_model_3.txt")
        #threed_prof=np.log10(threed_prof)

        #np.savetxt("deprojected_toy_model_3_col_den.txt", mean_deproj_prof)

        #ratio=np.absolute((threed_prof-mean_deproj_prof)/threed_prof)

        #print(ratio)
        #print(np.mean(ratio[0:20]))

        #np.savetxt('ratio_3D_over_deproj_toy_model_3_col_den.txt',ratio)

        #np.savetxt('proj_P_21.txt',mean_proj_prof)

        #proj_P_19=np.loadtxt('proj_P_19.txt')

        #ratio=(mean_proj_prof-proj_P_19)/proj_P_19
        #mean_ration=np.mean(np.absolute(ratio))
        #print("ratio",ratio)
        #print("mean ratio",mean_ratio)

        #plt.plot(rlogbin_cen,threed_prof,label='3D')
        #plt.plot(rlogbin_cen,mean_proj_prof,label='proj 21',m='.',ls='dashed')
        #plt.plot(rlogbin_cen,proj_P_19,label=19,m='.',ls='dashed')
        #plt.xscale('log')
        #plt.legend()
        #plt.show()
        #sys.exit()


        #print("mean_deproj_prof", mean_deproj_prof)

        #left_boundary = np.abs(rlogbin[0:nbin] - rlogbin_cen)
        #right_boundary = np.abs(rlogbin[1:nbin + 1] - rlogbin_cen)

        #np.savetxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_P_fil_100_l_19.txt",mean_deproj_prof)
        #np.savetxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_P_fil_100_l_19.txt",std_deproj_prof)
        #np.savetxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_P_fil_100_l_19.txt",interp_deproj_prof)

        #np.savetxt("./proj+deproj_profiles/fig_dep_p_7_high/mean_deproj_prof_P_x_100_highr_810bgsub.txt", mean_deproj_prof)
        #np.savetxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_prof_P_x_100_highr_810bgsub.txt", std_deproj_prof)
        #"./proj+deproj_profiles/fig_dep_p_7_high/mean_deproj_prof_P_x_100_highr_810bgsub.txt"

        # np.savetxt("./proj+deproj_profiles/mean_deproj_prof_T_z_100_lowr_810bgsub.txt",mean_deproj_prof)
        # np.savetxt("./proj+deproj_profiles/std_deproj_prof_T_z_100_lowr_810bgsub.txt", std_deproj_prof)

        #print("profile saved")
        #print("mean deproj prof",mean_deproj_prof)
        #np.savetxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_fily_h.txt", mean_deproj_prof)
        #np.savetxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_fily_h.txt", std_deproj_prof)

        #np.savetxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_fily_h.txt", mean_proj_prof)
        #np.savetxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_fily_h.txt", std_proj_prof)

        nbin=21

        #np.save("proj_prof_P_lvl15.npy",mean_proj_prof)


        np.save(filout_deproj, mean_deproj_prof)
        np.save(filout_std_deproj, std_deproj_prof)

        print("deproj prof saved")

        rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(nbin)])
        rlogbin_cen_21 = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])
        ne_rad_log = np.load("ne_rad_log_l15_20b.npy")
        std_ne_rad_log = np.load("std_ne_rad_log_l15_20b.npy")
        ne_rad_log_21 = np.load("ne_rad_log.npy")
        std_ne_rad_log_21 = np.load("err_ne_log.npy")
        P_rad_log = np.load("p_rad_log_l15_20b.npy")
        std_P_rad_log = np.load("std_p_rad_log_l15_20b.npy")
        proj_prof_ne_lvl15 = np.load("proj_prof_ne_lvl15.npy")
        proj_prof_P_lvl15 = np.load("proj_prof_P_lvl15.npy")

        #print(len(ne_rad_log_21))
        #sys.exit()
        #plt.scatter(rlogbin_cen[0:20],ne_rad_log,label='3D, lvl 15',s=10)
        #plt.errorbar(rlogbin_cen[0:20],ne_rad_log, yerr=std_ne_rad_log,ls='dashed')
        #plt.scatter(rlogbin_cen[0:20],P_rad_log,s=10)
        #plt.errorbar(rlogbin_cen[0:20],P_rad_log, yerr=std_P_rad_log,ls='dashed',label='3D, lvl 15')
        #plt.scatter(rlogbin_cen,mean_deproj_prof,s=10)
        #plt.errorbar(rlogbin_cen, mean_deproj_prof, yerr=std_deproj_prof, label='deproj',ls='dashed')
        #plt.scatter(rlogbin_cen, mean_proj_prof, s=10)
        #plt.errorbar(rlogbin_cen, mean_proj_prof, yerr=std_proj_prof, label='proj', ls='dashed')
        #plt.plot(rlogbin_cen,proj_prof_P_lvl15,label='lvl 15 proj')

        #plt.xscale('log')
        #plt.legend()
        #plt.show()

        #sys.exit()

        return rlogbin_cen,mean_deproj_prof

    if deproj == 1:
        #start=time.time()
        #print('test')
        rlogbin_cen, mean_deproj_prof = deproj_process(21)
        #rlogbin_cen, mean_deproj_prof = deproj_process(42)
        #rlogbin_cen, mean_deproj_prof = deproj_process(63)
        #plt.legend()
        #plt.show()
        #sys.exit()

        #end=time.time()
        #print('time',end-start)
        #sys.exit()

    if obs_prof == 1:
        print("loading of the observed profiles")

        ###Observed Profiles####

        P_urban = np.loadtxt('./obs_data/P_prof+errb_urban.txt')
        P_planck = np.loadtxt('./obs_data/P_prof+errb_planck.txt')

        # plt.scatter(P_urban[:, 0], P_urban[:, 1], s=7)
        # plt.errorbar(P_urban[:, 0], P_urban[:, 1], xerr=[P_urban[:, 2], P_urban[:, 3]], label='Observation datapoints, Urban+ 2011')
        # plt.scatter(P_planck[:, 0], P_planck[:, 1], s=7)
        # plt.errorbar(P_planck[:, 0], P_planck[:, 1], xerr=[P_planck[:, 2], P_planck[:, 3]], label='Observation datapoints, Planck Collab. 2018')

        ne_urban = np.loadtxt('./obs_data/ne_prof+errb_urban.txt')
        ne_planck = np.loadtxt('./obs_data/ne_prof+errb_planck.txt')
        ne_ghiz = np.loadtxt('./obs_data/ne_prof_ghizzardi.txt')

        # plt.scatter(ne_urban[:, 0], ne_urban[:, 1], s=7)
        # plt.errorbar(ne_urban[:, 0], ne_urban[:, 1], xerr=[ne_urban[:, 2], ne_urban[:, 3]],label='Observation datapoints, Urban+ 2011')
        # plt.scatter(ne_planck[:, 0], ne_planck[:, 1], s=7)
        # plt.errorbar(ne_planck[:, 0], ne_planck[:, 1], xerr=[ne_planck[:, 2], ne_planck[:, 3]],label='Observation datapoints, Planck Collab. 2018')
        # plt.plot(ne_ghiz[:,0],np.log10(ne_ghiz[:,1]),'.',label="Observation datapoints, Ghizzardi 2004")

        T_urban = np.loadtxt('./obs_data/T_prof+errb_urban.txt')

        # plt.scatter(T_urban[:,0],T_urban[:,1])
        # plt.errorbar(T_urban[:,0],T_urban[:,1],xerr=[T_urban[:,2],T_urban[:,3]],yerr=[T_urban[:,4],T_urban[:,5]],label="Projected profile from Urban et al.")

        T_planck = np.loadtxt('./obs_data/T_prof+errb_planck.txt')

        # plt.scatter(T_planck[:,0],T_planck[:,1])
        # plt.errorbar(T_planck[:,0],T_planck[:,1],xerr=[T_planck[:,2],T_planck[:,3]],label='Projected profile from Planck Collab')

    if plot_prof == 1:

        rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(21)])
        rlogbin_cen_old = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
        rlogbin_cen_3d = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

        #### Tests on the electron density deprojected profile ####

        #deproj_x_l_ne = np.loadtxt("./proj+deproj_profiles/mean_deproj_prof_ne_x_100_lowr_810bgsub.txt")
        #deproj_x_l_ne_std = np.loadtxt("./proj+deproj_profiles/std_deproj_prof_ne_x_100_lowr_810bgsub.txt")

        # plt.scatter(rlogbin_cen, deproj_x_l_ne, marker='.', s=80, c='blue')
        # plt.errorbar(rlogbin_cen, deproj_x_l_ne, yerr=deproj_x_l_ne_std, c='blue', ls='dashdot', label="x deprojection, 2048^3 ", alpha=0.8)

        #### Tests on the temperature deprojected profile ####

        #deproj_x_l_T = np.loadtxt("./proj+deproj_profiles/mean_deproj_prof_T_z_100_lowr_810bgsub.txt")
        #deproj_x_l_T_std = np.loadtxt("./proj+deproj_profiles/std_deproj_prof_T_z_100_lowr_810bgsub.txt")

        # plt.scatter(rlogbin_cen, np.log10(deproj_x_l_T), marker='.', s=80, c='blue')
        # plt.errorbar(rlogbin_cen, np.log10(deproj_x_l_T), yerr=deproj_x_l_T_std/(deproj_x_l_T*np.log(10)), c='blue', ls='dashdot', label="z deprojection, 2048^3 ", alpha=0.8)

        print("load profiles")

        ############## Plots for the paper ###################

        def compar_h_l_3d_vs_dep_z_p():# Plot P  3D high, low (in main code), deproj low high /r z

            # low res

            deproj_z_low_P_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/mean_deproj_P_z_100_l.txt")
            deproj_z_low_P_810bgsub_std = np.loadtxt(
                "./proj+deproj_profiles/fig_dep_z_high_low/std_deproj_P_z_100_l.txt")
            lonely_deproj_low = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/lonely_deprojs_P_z_100_l.txt")

            n_it = 100
            for i in range(n_it):
                plt.plot(rlogbin_cen[0:20], lonely_deproj_low[0:20, i], lw=1, alpha=0.03, color='blue')

            # high res

            deproj_z_high_P_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/mean_deproj_P_z_100_h.txt")
            deproj_z_high_P_810bgsub_std = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/std_deproj_P_z_100_h.txt")
            lonely_deproj = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/lonely_deprojs_P_z_100_h.txt")

            n_it = 100
            for i in range(n_it):
                plt.plot(rlogbin_cen[0:20], lonely_deproj[0:20,i], lw=1, alpha=0.03, color='orange')


            plt.scatter(rlogbin_cen[0:20], deproj_z_low_P_810bgsub[0:20],c='blue',s=8)
            plt.errorbar(rlogbin_cen[0:20], deproj_z_low_P_810bgsub[0:20], yerr=deproj_z_low_P_810bgsub_std[0:20] , capsize=2,c='blue',label="Deprojected, $2048^3$, z axis",alpha=0.8)

            plt.scatter(rlogbin_cen[0:20], deproj_z_high_P_810bgsub[0:20], c="orange",s=8)
            plt.errorbar(rlogbin_cen[0:20], deproj_z_high_P_810bgsub[0:20], yerr=deproj_z_high_P_810bgsub_std[0:20],capsize=2, c="orange", label="Deprojected, $8192^3$, z axis", alpha=0.8)

            plt.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            plt.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16,labelbottom=True, labelleft=True)

            #sys.exit()



        def compar_h_l_3d_vs_dep_z_p_ne():# Plot P  3D high, low (in main code), deproj low high /r z

            Plogmed_17, Pstdlogmed_17, Plogmean_17, Pstdlogmean_17, Tlogmed_17, Tstdlogmed_17, Tlogmean_17, Tstdlogmean_17, nelogmed_17, nestdlogmed_17, nelogmean_17, nestdlogmean_17, nlog_17, mlog_17, ndm_17, mdm_17, inf_17, middle_17, sup_17 = load_lograd_dat("lograd_data_lvl17_cleanm1e9.npy")
            Plogmed_c8, Pstdlogmed_c8, Plogmean_c8, Pstdlogmean_c8, Tlogmed_c8, Tstdlogmed_c8, Tlogmean_c8, Tstdlogmean_c8, nelogmed_c8, nestdlogmed_c8, nelogmean_c8, nestdlogmean_c8, nlog_c8, mlog_c8, ndm_c8, mdm_c8, inf_c8, middle_c8, sup_c8 = load_lograd_dat("lograd_data_lvl21_cleanm1e8.5.npy")
            rlogbin_cen_threed = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

            f,(a,b)=plt.subplots(2,1)

            # low res

            deproj_z_low_P_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/mean_deproj_P_z_100_l.txt")
            deproj_z_low_P_810bgsub_std = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/std_deproj_P_z_100_l.txt")
            lonely_deproj_low = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/lonely_deprojs_P_z_100_l.txt")

            n_it = 100
            for i in range(n_it):
                a.plot(rlogbin_cen[0:20], lonely_deproj_low[0:20, i], lw=1, alpha=0.03, color='blue')

            # high res

            deproj_z_high_P_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/mean_deproj_P_z_100_h.txt")
            deproj_z_high_P_810bgsub_std = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/std_deproj_P_z_100_h.txt")
            lonely_deproj = np.loadtxt("./proj+deproj_profiles/fig_dep_z_high_low/lonely_deprojs_P_z_100_h.txt")

            n_it = 100
            for i in range(n_it):
                a.plot(rlogbin_cen[0:20], lonely_deproj[0:20,i], lw=1, alpha=0.03, color='orange')


            a.scatter(rlogbin_cen[0:20], deproj_z_low_P_810bgsub[0:20],c='blue',s=8)
            a.errorbar(rlogbin_cen[0:20], deproj_z_low_P_810bgsub[0:20], yerr=deproj_z_low_P_810bgsub_std[0:20] , capsize=2,c='blue',label="Deprojected, $2048^3$, z axis",alpha=0.8)
            a.scatter(rlogbin_cen[0:20], deproj_z_high_P_810bgsub[0:20], c="orange",s=8)
            a.errorbar(rlogbin_cen[0:20], deproj_z_high_P_810bgsub[0:20], yerr=deproj_z_high_P_810bgsub_std[0:20],capsize=2, c="orange", label="Deprojected, $8192^3$, z axis", alpha=0.8)
            a.scatter(rlogbin_cen_threed, Plogmean_17, s=6, c='blue')
            a.errorbar(rlogbin_cen_threed, Plogmean_17, yerr=Pstdlogmean_17, ls='dotted', label='3D, $2048^3$', alpha=0.7,c='blue')  # 'Smallest grid size: 5.62kpc'
            a.scatter(rlogbin_cen_threed, Plogmean_c8, s=6, c='orange')
            a.errorbar(rlogbin_cen_threed, Plogmean_c8, yerr=Pstdlogmean_c8, ls='dotted', label='3D, $8192^3$', alpha=0.7,c='orange')  # '''Smallest grid size: 0.35kpc
            a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16,labelbottom=True, labelleft=True)
            a.axvline(x=1087, color='grey')
            a.text(1087, -7, "$\mathrm{R_{500}}$", rotation=90, size=16)
            a.axvline(x=2147, color='grey', ls='dashed')
            a.text(2147, -7, "$\mathrm{R_{vir}}$", rotation=90, size=16)
            a.legend(prop={'size': 16})
            a.set_xscale('log')
            a.set_ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)


            # low res

            deproj_z_low_ne_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_z_high_low/mean_deproj_ne_z_100_l.txt")
            deproj_z_low_ne_810bgsub_std = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_z_high_low/std_deproj_ne_z_100_l.txt")
            lonely_deproj_low_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_z_high_low/lonely_deprojs_ne_z_100_l.txt")

            n_it = 100
            for i in range(n_it):
                b.plot(rlogbin_cen[0:20], lonely_deproj_low_ne[0:20, i], lw=1, alpha=0.03, color='blue')

            # high res

            deproj_z_high_ne_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_z_high_low/mean_deproj_ne_z_100_h.txt")
            deproj_z_high_ne_810bgsub_std = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_z_high_low/std_deproj_ne_z_100_h.txt")
            lonely_deproj_high_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_z_high_low/lonely_deprojs_ne_z_100_h.txt")

            n_it = 100
            for i in range(n_it):
                b.plot(rlogbin_cen[0:20], lonely_deproj_high_ne[0:20, i], lw=1, alpha=0.03, color='orange')

            b.scatter(rlogbin_cen[0:20], deproj_z_low_ne_810bgsub[0:20], c='blue', s=8)
            b.errorbar(rlogbin_cen[0:20], deproj_z_low_ne_810bgsub[0:20], yerr=deproj_z_low_ne_810bgsub_std[0:20],capsize=2, c='blue', label="Deprojected, $2048^3$, z axis", alpha=0.8)

            b.scatter(rlogbin_cen[0:20], deproj_z_high_ne_810bgsub[0:20], c="orange", s=8)
            b.errorbar(rlogbin_cen[0:20], deproj_z_high_ne_810bgsub[0:20], yerr=deproj_z_high_ne_810bgsub_std[0:20],capsize=2, c="orange", label="Deprojected, $8192^3$, z axis", alpha=0.8)
            b.scatter(rlogbin_cen_threed, nelogmean_17, s=6, c='blue')
            b.errorbar(rlogbin_cen_threed, nelogmean_17, yerr=nestdlogmean_17, ls='dotted', label='3D, $2048^3$', alpha=0.7,c='blue')  # 'Smallest grid size: 5.62kpc'
            b.scatter(rlogbin_cen_threed, nelogmean_c8, s=6, c='orange')
            b.errorbar(rlogbin_cen_threed, nelogmean_c8, yerr=nestdlogmean_c8, ls='dotted', label='3D, $8192^3$', alpha=0.7,c='orange')  # '''Smallest grid size: 0.35kpc
            b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16,labelbottom=True, labelleft=True)
            b.axvline(x=1087, color='grey')
            b.text(1087, -6, "$\mathrm{R_{500}}$", rotation=90, size=16)
            b.axvline(x=2147, color='grey', ls='dashed')
            b.text(2147, -6, "$\mathrm{R_{vir}}$", rotation=90, size=16)
            b.legend(prop={'size': 16})
            b.set_xlabel("$R$[kpc]", size=16)
            b.set_xscale('log')
            b.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{e}}$[c$\mathrm{m^{-3}}$])", size=16)

            plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()
            print("end")
            sys.exit()



        def P_deproj_7_high():# Plot P deproj 7 projections high + 3D high

            x = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_x_h.txt")
            y = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_y_h.txt")
            z = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_z_h.txt")
            cen = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_MW_h.txt")
            fil = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_fil_h.txt")
            filx = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_filx_h.txt")
            fily = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_fily_h.txt")

            sx = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_x_h.txt")
            sy = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_y_h.txt")
            sz = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_z_h.txt")
            scen = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_MW_h.txt")
            sfil = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_fil_h.txt")
            sfilx = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_filx_h.txt")
            sfily = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_fily_h.txt")

            f, ((a,c),(b,d)) = plt.subplots(2,2,gridspec_kw={'height_ratios':[3,1]})
            a.scatter(rlogbin_cen_3d, three_d_prof, s=6, c='orange')
            a.errorbar(rlogbin_cen_3d,three_d_prof, yerr=std_three_d_prof, ls='dotted', label='3D, $8192^3$', alpha=0.7, c='orange')
            a.scatter(rlogbin_cen[:-1],x[:-1],c='red',marker='.',s=60)
            a.errorbar(rlogbin_cen[:-1],x[:-1],yerr=sx[:-1],c='red',ls='dashed',label="x",alpha=0.8)
            a.scatter(rlogbin_cen[:-1], y[:-1],c='lightgreen',marker='.',s=60)
            a.errorbar(rlogbin_cen[:-1], y[:-1], yerr=sy[:-1],c='lightgreen',ls='dashed',label="y",alpha=0.8)
            a.scatter(rlogbin_cen[:-1], z[:-1],c='skyblue',marker='.',s=60)
            a.errorbar(rlogbin_cen[:-1], z[:-1], yerr=sz[:-1],c='skyblue',ls='dashed',label="z",alpha=0.8)
            a.scatter(rlogbin_cen[:-1], cen[:-1],c='forestgreen',marker='.',s=60)
            a.errorbar(rlogbin_cen[:-1], cen[:-1], yerr=scen[:-1],c='forestgreen',ls='dashed',label="center of the box",alpha=0.8)

            a.axvline(x=1087, color='grey')
            a.text(1087, -1, "$R_{500}$", rotation=90, size=16)
            a.axvline(x=2147, color='grey', ls='dashed')
            a.text(2147, -1, "$R_{vir}$", rotation=90, size=16)
            a.set_xlim(50,6000)
            a.set_ylim(-7.4, -0.3)
            a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            a.set_ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            a.legend()
            a.set_xscale('log')
            # plt.xticks(fontsize=14)
            #a.set_yticks()


            f_interp_lin = interp1d(rlogbin_cen_3d,three_d_prof, fill_value='extrapolate')
            y_interp_3d=f_interp_lin(rlogbin_cen)

            res_x = -(x- y_interp_3d)/y_interp_3d
            res_y = -(y - y_interp_3d) / y_interp_3d
            res_z = -(z - y_interp_3d) / y_interp_3d
            res_cen = -(cen- y_interp_3d) / y_interp_3d

            b.plot(rlogbin_cen[:-1],res_x[:-1],c='red',ls='dashed',label="x",alpha=0.8)
            b.plot(rlogbin_cen[:-1], res_y[:-1],c='lightgreen',ls='dashed',label="y",alpha=0.8)
            b.plot(rlogbin_cen[:-1], res_z[:-1],c='skyblue',ls='dashed',label="z",alpha=0.8)
            b.plot(rlogbin_cen[:-1], res_cen[:-1],c='forestgreen',ls='dashed',label="center",alpha=0.8)

            b.axvline(x=1087, color='grey')
            #b.text(1087, -7, "$R_{500}$", rotation=90, size=16)
            b.axvline(x=2147, color='grey', ls='dashed')
            #b.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
            b.set_xlabel('$R$[kpc]', size=16)
            #plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            b.set_ylabel("Relative difference",size=16)
            #plt.legend(prop={'size': 16})
            b.set_xscale('log')
            b.set_xlim(50,6000)
            b.set_ylim(-0.15, 0.6)
            zerox=np.linspace(50,8000,500)
            zeroy=np.zeros(500)
            b.plot(zerox,zeroy,c='orange',ls='dotted')
            b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            #b.set_xticks()
            #b.set_yticks()
            # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
            # plt.xlim(50,7000)


            c.scatter(rlogbin_cen_3d, three_d_prof, s=6, c='orange')
            c.errorbar(rlogbin_cen_3d, three_d_prof, yerr=std_three_d_prof, ls='dotted', label='3D, $8192^3$', alpha=0.7, c='orange')
            c.scatter(rlogbin_cen[:-1], fil[:-1], c='salmon', marker='.', s=60)
            c.errorbar(rlogbin_cen[:-1], fil[:-1], yerr=sfil[:-1], c='salmon', ls='dashed', label="main filament", alpha=0.8)
            c.scatter(rlogbin_cen[:-1], filx[:-1], c='pink', marker='.', s=60)
            c.errorbar(rlogbin_cen[:-1], filx[:-1], yerr=sfilx[:-1], c='pink', ls='dashed', label="90° rotation around x axis", alpha=0.8)
            c.scatter(rlogbin_cen[:-1], fily[:-1], c='purple', marker='.', s=60)
            c.errorbar(rlogbin_cen[:-1], fily[:-1], yerr=sfily[:-1], c='purple', ls='dashed', label="90° rotation around y axis", alpha=0.8)

            c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True, labelleft=True)
            c.axvline(x=1087, color='grey')
            c.text(1087, -1, "$R_{500}$", rotation=90, size=16)
            c.axvline(x=2147, color='grey', ls='dashed')
            c.text(2147, -1, "$R_{vir}$", rotation=90, size=16)
            c.set_xlim(50, 6000)
            c.set_ylim(-7.4, -0.3)
            # plt.xlabel("R(kpc)", size=16)
            #c.set_ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            c.legend()
            c.set_xscale('log')
            c.yaxis.set_ticklabels([])
            # plt.xticks(fontsize=14)
            # a.set_yticks()

            f_interp_lin = interp1d(rlogbin_cen_3d, three_d_prof, fill_value='extrapolate')
            y_interp_3d = f_interp_lin(rlogbin_cen)

            #res_x = -(deproj_x_h_P - y_interp_3d) / y_interp_3d
            #res_y = -(deproj_y_h_P - y_interp_3d) / y_interp_3d
            #res_z = -(deproj_z_h_P - y_interp_3d) / y_interp_3d
            #res_cen = -(deproj_cen_h_P - y_interp_3d) / y_interp_3d
            res_fil = -(fil - y_interp_3d) / y_interp_3d
            res_filx = -(filx - y_interp_3d) / y_interp_3d
            res_fily = -(fily - y_interp_3d) / y_interp_3d

            # plt.subplot(3,1,3)
            d.plot(rlogbin_cen[:-1], res_filx[:-1], c='salmon', ls='dashed',label="perpendicular to the main filament (rotation around x axis) projection ", alpha=0.8)
            d.plot(rlogbin_cen[:-1], res_fily[:-1], c="pink", ls='dashed', label="perpendicular to the main filament (rotation around y axis) projection", alpha=0.8)
            d.plot(rlogbin_cen[:-1], res_fil[:-1], c='purple', ls='dashed', label="main filament axis projection", alpha=0.8)

            d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            d.axvline(x=1087, color='grey')
            #d.text(1087, -7, "$R_{500}$", rotation=90, size=16)
            d.axvline(x=2147, color='grey', ls='dashed')
            #d.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
            d.set_xlabel('$R$[kpc]', size=16)
            d.yaxis.set_ticklabels([])
            # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            #d.set_ylabel("Relative difference", size=16)
            # plt.legend(prop={'size': 16})
            d.set_xscale('log')
            d.set_xlim(50, 6000)
            d.set_ylim(-0.15, 0.6)
            zerox = np.linspace(50, 8000, 500)
            zeroy = np.zeros(500)
            d.plot(zerox, zeroy, c='orange', ls='dotted')
            # b.set_xticks()
            # b.set_yticks()
            # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
            # plt.xlim(50,7000)
            plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()
            print("end")
            sys.exit()

        def P_deproj_4_high():  # Plot P deproj 7 projections high + 3D high

                x = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_x_h.txt")
                y = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_y_h.txt")
                z = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_z_h.txt")
                cen = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_MW_h.txt")
                fil = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_fil_h.txt")
                filx = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_filx_h.txt")
                fily = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_fily_h.txt")

                sx = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_x_h.txt")
                sy = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_y_h.txt")
                sz = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_z_h.txt")
                scen = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_MW_h.txt")
                sfil = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_fil_h.txt")
                sfilx = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_filx_h.txt")
                sfily = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_fily_h.txt")

                Plogmed_c8, Pstdlogmed_c8, Plogmean_c8, Pstdlogmean_c8, Tlogmed_c8, Tstdlogmed_c8, Tlogmean_c8, Tstdlogmean_c8, nelogmed_c8, nestdlogmed_c8, nelogmean_c8, nestdlogmean_c8, nlog_c8, mlog_c8, ndm_c8, mdm_c8, inf_c8, middle_c8, sup_c8 = load_lograd_dat("lograd_data_lvl21_cleanm1e8.5.npy")

                three_d_prof = Plogmean_c8
                std_three_d_prof = Pstdlogmean_c8

                #print("shape 3D prof", np.shape(three_d_prof))
                #print("shape dep prof", np.shape(x))
                #print("shape rlogbincen_3d",np.shape(rlogbin_cen_3d))

                #sys.exit()

                #print("rlogbin_cen", rlogbin_cen[15])
                #print("cen", cen[15])
                #print("fil", fil[15])
                #print("filx", filx[15])
                #print("fily", fily[15])
                #sys.exit()

                f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [5, 3]})
                #a.scatter(rlogbin_cen_3d, three_d_prof, s=6, c='orange')
                #a.errorbar(rlogbin_cen_3d, three_d_prof, yerr=std_three_d_prof, ls='dotted', label='3D, $8192^3$',alpha=0.7, c='orange')
                #a.scatter(rlogbin_cen[:-1], x[:-1], c='red', marker='.', s=60)
                #a.errorbar(rlogbin_cen[:-1], x[:-1], yerr=sx[:-1], c='red', ls='dashed', label="x", alpha=0.8)
                #a.scatter(rlogbin_cen[:-1], y[:-1], c='lightgreen', marker='.', s=60)
                #a.errorbar(rlogbin_cen[:-1], y[:-1], yerr=sy[:-1], c='lightgreen', ls='dashed', label="y", alpha=0.8)
                #a.scatter(rlogbin_cen[:-1], z[:-1], c='skyblue', marker='.', s=60)
                #a.errorbar(rlogbin_cen[:-1], z[:-1], yerr=sz[:-1], c='skyblue', ls='dashed', label="z", alpha=0.8)
                #a.scatter(rlogbin_cen[:-1], cen[:-1], c='forestgreen', marker='.', s=60)
                #a.errorbar(rlogbin_cen[:-1], cen[:-1], yerr=scen[:-1], c='forestgreen', ls='dashed',label="center of the box", alpha=0.8)

                #a.axvline(x=1087, color='grey')
                #a.text(1087, -1, "$R_{500}$", rotation=90, size=16)
                #a.axvline(x=2147, color='grey', ls='dashed')
                #a.text(2147, -1, "$R_{vir}$", rotation=90, size=16)
                #a.set_xlim(50, 6000)
                #a.set_ylim(-7.4, -0.3)
                #a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
                #a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16,labelbottom=True, labelleft=True)
                #a.set_ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)
                # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
                # plt.ylabel("$log_{10}(T[keV])$", size=14)
                #a.legend()
                #a.set_xscale('log')
                # plt.xticks(fontsize=14)
                # a.set_yticks()

                #f_interp_lin = interp1d(rlogbin_cen_3d, three_d_prof, fill_value='extrapolate')
                #y_interp_3d = f_interp_lin(rlogbin_cen)

                #res_x = -(x - y_interp_3d) / y_interp_3d
                #res_y = -(y - y_interp_3d) / y_interp_3d
                #res_z = -(z - y_interp_3d) / y_interp_3d
                #res_cen = -(cen - y_interp_3d) / y_interp_3d

                #b.plot(rlogbin_cen[:-1], res_x[:-1], c='red', ls='dashed', label="x", alpha=0.8)
                #b.plot(rlogbin_cen[:-1], res_y[:-1], c='lightgreen', ls='dashed', label="y", alpha=0.8)
                #b.plot(rlogbin_cen[:-1], res_z[:-1], c='skyblue', ls='dashed', label="z", alpha=0.8)
                #b.plot(rlogbin_cen[:-1], res_cen[:-1], c='forestgreen', ls='dashed', label="center", alpha=0.8)

                #b.axvline(x=1087, color='grey')
                # b.text(1087, -7, "$R_{500}$", rotation=90, size=16)
                #b.axvline(x=2147, color='grey', ls='dashed')
                # b.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
                #b.set_xlabel('$R$[kpc]', size=16)
                # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
                # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
                # plt.ylabel("$log_{10}(T[keV])$", size=14)
                #b.set_ylabel("Relative difference", size=16)
                # plt.legend(prop={'size': 16})
                #b.set_xscale('log')
                #b.set_xlim(50, 6000)
                #b.set_ylim(-0.15, 0.6)
                #zerox = np.linspace(50, 8000, 500)
                #zeroy = np.zeros(500)
                #b.plot(zerox, zeroy, c='orange', ls='dotted')
                #b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
                #b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16,labelbottom=True, labelleft=True)
                # b.set_xticks()
                # b.set_yticks()
                # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
                # plt.xlim(50,7000)

                c.scatter(rlogbin_cen_3d, three_d_prof, s=6, c='orange')
                c.errorbar(rlogbin_cen_3d, three_d_prof, yerr=std_three_d_prof, ls='dotted', label='3D, $8192^3$',alpha=0.7, c='orange')
                #c.scatter(rlogbin_cen[:-1], fil[:-1], c='blue', marker='.', s=60)
                #c.errorbar(rlogbin_cen[:-1], fil[:-1], yerr=sfil[:-1], c='blue', ls='dotted', label="Fil",alpha=0.8)
                #c.scatter(rlogbin_cen[:-1], filx[:-1], c='green', marker='.', s=60)
                #c.errorbar(rlogbin_cen[:-1], filx[:-1], yerr=sfilx[:-1], c='green', ls='dashed',label="Filx", alpha=0.8)
                #c.scatter(rlogbin_cen[:-1], fily[:-1], c='dimgrey', marker='.', s=60)
                #c.errorbar(rlogbin_cen[:-1], fily[:-1], yerr=sfily[:-1], c='dimgrey', ls='dashdot',label="Fily", alpha=0.8)
                #c.scatter(rlogbin_cen[:-1], cen[:-1], c='red', marker='.', s=60)
                #c.errorbar(rlogbin_cen[:-1], cen[:-1], yerr=scen[:-1], c='red', ls='solid',label="Cen", alpha=0.8)
                c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
                c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16,labelbottom=True, labelleft=True)
                c.set_ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)
                c.axvline(x=1087, color='grey')
                c.text(1087, -2, "$R_{500}$", rotation=90, size=16)
                c.axvline(x=2147, color='grey', ls='dashed')
                c.text(2147, -2, "$R_{vir}$", rotation=90, size=16)
                c.set_xlim(50, 6000)
                c.set_ylim(-7.4, -0.3)
                # plt.xlabel("R(kpc)", size=16)
                # c.set_ylabel("$log_{10}(P[keV/cm^3])$", size=16)
                # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
                # plt.ylabel("$log_{10}(T[keV])$", size=14)
                c.legend()
                c.set_xscale('log')
                #c.yaxis.set_ticklabels([])
                # plt.xticks(fontsize=14)
                # a.set_yticks()

                f_interp_lin = interp1d(rlogbin_cen_3d, three_d_prof, fill_value='extrapolate')
                y_interp_3d = f_interp_lin(rlogbin_cen)

                # res_x = -(deproj_x_h_P - y_interp_3d) / y_interp_3d
                # res_y = -(deproj_y_h_P - y_interp_3d) / y_interp_3d
                # res_z = -(deproj_z_h_P - y_interp_3d) / y_interp_3d
                # res_cen = -(deproj_cen_h_P - y_interp_3d) / y_interp_3d
                res_fil = -(fil - y_interp_3d) / y_interp_3d
                res_filx = -(filx - y_interp_3d) / y_interp_3d
                res_fily = -(fily - y_interp_3d) / y_interp_3d
                res_cen = -(cen - y_interp_3d) / y_interp_3d

                # plt.subplot(3,1,3)
                #d.plot(rlogbin_cen[:-1], res_filx[:-1], c='green', ls='dashed',label="perpendicular to the main filament (rotation around x axis) projection ", alpha=0.8)
                #d.plot(rlogbin_cen[:-1], res_fily[:-1], c="dimgrey", ls='dashdot',label="perpendicular to the main filament (rotation around y axis) projection", alpha=0.8)
                #d.plot(rlogbin_cen[:-1], res_fil[:-1], c='blue', ls='dotted', label="main filament axis projection",alpha=0.8)
                #d.plot(rlogbin_cen[:-1], res_cen[:-1], c='red', ls='solid', label="center", alpha=0.8)
                d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
                d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16,labelbottom=True, labelleft=True)
                d.set_ylabel("Relative difference", size=16)
                d.axvline(x=1087, color='grey')
                # d.text(1087, -7, "$R_{500}$", rotation=90, size=16)
                d.axvline(x=2147, color='grey', ls='dashed')
                # d.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
                d.set_xlabel('$R$[kpc]', size=16)
                #d.yaxis.set_ticklabels([])
                # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
                # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
                # plt.ylabel("$log_{10}(T[keV])$", size=14)
                # d.set_ylabel("Relative difference", size=16)
                # plt.legend(prop={'size': 16})
                d.set_xscale('log')
                d.set_xlim(50, 6000)
                #d.set_ylim()
                d.set_ylim(-0.7366, 0.2648)
                zerox = np.linspace(50, 8000, 500)
                zeroy = np.zeros(500)
                d.plot(zerox, zeroy, c='orange', ls='dotted')
                # b.set_xticks()
                # b.set_yticks()
                # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
                # plt.xlim(50,7000)
                plt.subplots_adjust(wspace=0, hspace=0)
                plt.show()
                print("end")
                sys.exit()



        def ne_deproj_7_high():# Plot ne deproj 7 projections high + 3D high

            x = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_x_h.txt")
            y = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_y_h.txt")
            z = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_z_h.txt")
            cen = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_cen_h.txt")
            fil = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_fil_h.txt")
            filx = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_filx_h.txt")
            fily = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_fily_h.txt")

            sx = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_x_h.txt")
            sy = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_y_h.txt")
            sz = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_z_h.txt")
            scen = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_cen_h.txt")
            sfil = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_fil_h.txt")
            sfilx = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_filx_h.txt")
            sfily = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_fily_h.txt")

            f, ((a,c),(b,d)) = plt.subplots(2,2,gridspec_kw={'height_ratios':[3,1]})
            a.scatter(rlogbin_cen_3d, three_d_prof, s=6, c='orange')
            a.errorbar(rlogbin_cen_3d,three_d_prof, yerr=std_three_d_prof, ls='dotted', label='3D, 8192^3', alpha=0.7, c='orange')
            a.scatter(rlogbin_cen[:-1],x[:-1],c='red',marker='.',s=60)
            a.errorbar(rlogbin_cen[:-1],x[:-1],yerr=sx[:-1],c='red',ls='dashed',label="x",alpha=0.8)
            a.scatter(rlogbin_cen[:-1], y[:-1],c='lightgreen',marker='.',s=60)
            a.errorbar(rlogbin_cen[:-1], y[:-1], yerr=sy[:-1],c='lightgreen',ls='dashed',label="y",alpha=0.8)
            a.scatter(rlogbin_cen[:-1], z[:-1],c='salmon',marker='.',s=60)
            a.errorbar(rlogbin_cen[:-1], z[:-1], yerr=sz[:-1],c='salmon',ls='dashed',label="z",alpha=0.8)
            a.scatter(rlogbin_cen[:-1], cen[:-1],c='forestgreen',marker='.',s=60)
            a.errorbar(rlogbin_cen[:-1], cen[:-1], yerr=scen[:-1],c='forestgreen',ls='dashed',label="center of the box",alpha=0.8)

            a.axvline(x=1087, color='grey')
            a.text(1087, -6, "$R_{500}$", rotation=90, size=16)
            a.axvline(x=2147, color='grey', ls='dashed')
            a.text(2147, -6, "$R_{vir}$", rotation=90, size=16)
            a.set_xlim(50,6000)
            a.set_ylim(-6.4, -2.1)
            a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            a.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{e}}$[c$\mathrm{m^{-3}}$])", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            a.legend()
            a.set_xscale('log')
            # plt.xticks(fontsize=14)
            #a.set_yticks()


            f_interp_lin = interp1d(rlogbin_cen_3d,three_d_prof, fill_value='extrapolate')
            y_interp_3d=f_interp_lin(rlogbin_cen)

            res_x = -(x- y_interp_3d)/y_interp_3d
            res_y = -(y - y_interp_3d) / y_interp_3d
            res_z = -(z - y_interp_3d) / y_interp_3d
            res_cen = -(cen- y_interp_3d) / y_interp_3d

            b.plot(rlogbin_cen[:-1],res_x[:-1],c='red',ls='dashed',label="x",alpha=0.8)
            b.plot(rlogbin_cen[:-1], res_y[:-1],c='lightgreen',ls='dashed',label="y",alpha=0.8)
            b.plot(rlogbin_cen[:-1], res_z[:-1],c='salmon',ls='dashed',label="z",alpha=0.8)
            b.plot(rlogbin_cen[:-1], res_cen[:-1],c='forestgreen',ls='dashed',label="center",alpha=0.8)

            b.axvline(x=1087, color='grey')
            #b.text(1087, -7, "$R_{500}$", rotation=90, size=16)
            b.axvline(x=2147, color='grey', ls='dashed')
            #b.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
            b.set_xlabel("R(kpc)", size=16)
            #plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            b.set_ylabel("Relative difference",size=16)
            #plt.legend(prop={'size': 16})
            b.set_xscale('log')
            b.set_xlim(50,6000)
            b.set_ylim(-0.04, 0.05)
            zerox=np.linspace(50,8000,500)
            zeroy=np.zeros(500)
            b.plot(zerox,zeroy,c='orange',ls='dotted')
            b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            #b.set_xticks()
            #b.set_yticks()
            # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
            # plt.xlim(50,7000)


            c.scatter(rlogbin_cen_3d, three_d_prof, s=6, c='orange')
            c.errorbar(rlogbin_cen_3d, three_d_prof, yerr=std_three_d_prof, ls='dotted', label='3D, 8192^3', alpha=0.7, c='orange')
            c.scatter(rlogbin_cen[:-1], fil[:-1], c='salmon', marker='.', s=60)
            c.errorbar(rlogbin_cen[:-1], fil[:-1], yerr=sfil[:-1], c='salmon', ls='dashed', label="main filament", alpha=0.8)
            c.scatter(rlogbin_cen[:-1], filx[:-1], c='pink', marker='.', s=60)
            c.errorbar(rlogbin_cen[:-1], filx[:-1], yerr=sfilx[:-1], c='pink', ls='dashed', label="90° rotation around x axis", alpha=0.8)
            c.scatter(rlogbin_cen[:-1], fily[:-1], c='purple', marker='.', s=60)
            c.errorbar(rlogbin_cen[:-1], fily[:-1], yerr=sfily[:-1], c='purple', ls='dashed', label="90° rotation around y axis", alpha=0.8)

            c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True, labelleft=True)
            c.axvline(x=1087, color='grey')
            c.text(1087, -6, "$R_{500}$", rotation=90, size=16)
            c.axvline(x=2147, color='grey', ls='dashed')
            c.text(2147, -6, "$R_{vir}$", rotation=90, size=16)
            c.set_xlim(50, 6000)
            c.set_ylim(-6.4, -2.1)
            # plt.xlabel("R(kpc)", size=16)
            #c.set_ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            c.legend()
            c.set_xscale('log')
            c.yaxis.set_ticklabels([])
            # plt.xticks(fontsize=14)
            # a.set_yticks()

            f_interp_lin = interp1d(rlogbin_cen_3d, three_d_prof, fill_value='extrapolate')
            y_interp_3d = f_interp_lin(rlogbin_cen)

            #res_x = -(deproj_x_h_P - y_interp_3d) / y_interp_3d
            #res_y = -(deproj_y_h_P - y_interp_3d) / y_interp_3d
            #res_z = -(deproj_z_h_P - y_interp_3d) / y_interp_3d
            #res_cen = -(deproj_cen_h_P - y_interp_3d) / y_interp_3d
            res_fil = -(fil - y_interp_3d) / y_interp_3d
            res_filx = -(filx - y_interp_3d) / y_interp_3d
            res_fily = -(fily - y_interp_3d) / y_interp_3d

            # plt.subplot(3,1,3)
            d.plot(rlogbin_cen[:-1], res_filx[:-1], c='salmon', ls='dashed',label="perpendicular to the main filament (rotation around x axis) projection ", alpha=0.8)
            d.plot(rlogbin_cen[:-1], res_fily[:-1], c="pink", ls='dashed', label="perpendicular to the main filament (rotation around y axis) projection", alpha=0.8)
            d.plot(rlogbin_cen[:-1], res_fil[:-1], c='purple', ls='dashed', label="main filament axis projection", alpha=0.8)

            d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            d.axvline(x=1087, color='grey')
            #d.text(1087, -7, "$R_{500}$", rotation=90, size=16)
            d.axvline(x=2147, color='grey', ls='dashed')
            #d.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
            d.set_xlabel("R(kpc)", size=16)
            d.yaxis.set_ticklabels([])
            # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            #d.set_ylabel("Relative difference", size=16)
            # plt.legend(prop={'size': 16})
            d.set_xscale('log')
            d.set_xlim(50, 6000)
            d.set_ylim(-0.04, 0.05)
            zerox = np.linspace(50, 8000, 500)
            zeroy = np.zeros(500)
            d.plot(zerox, zeroy, c='orange', ls='dotted')
            # b.set_xticks()
            # b.set_yticks()
            # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
            # plt.xlim(50,7000)
            plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()
            print("end")
            sys.exit()

        def ne_deproj_4_high(): # Plot ne deproj 4 projections high + 3D high

            x = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_x_h.txt")
            y = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_y_h.txt")
            z = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_z_h.txt")
            cen = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_cen_h.txt")
            fil = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_fil_h.txt")
            filx = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_filx_h.txt")
            fily = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_fily_h.txt")

            sx = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_x_h.txt")
            sy = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_y_h.txt")
            sz = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_z_h.txt")
            scen = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_cen_h.txt")
            sfil = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_fil_h.txt")
            sfilx = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_filx_h.txt")
            sfily = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_fily_h.txt")

            #print("rlogbin_cen",rlogbin_cen[15])
            #print("cen",cen[15])
            #print("fil", fil[15])
            #print("filx", filx[15])
            #print("fily", fily[15])
            #sys.exit()

            f, (c,d) = plt.subplots(2,1,gridspec_kw={'height_ratios':[3,1]})
            #a.scatter(rlogbin_cen_3d, three_d_prof, s=6, c='orange')
            #a.errorbar(rlogbin_cen_3d,three_d_prof, yerr=std_three_d_prof, ls='dotted', label='3D, 8192^3', alpha=0.7, c='orange')
            #a.scatter(rlogbin_cen[:-1],x[:-1],c='red',marker='.',s=60)
            #a.errorbar(rlogbin_cen[:-1],x[:-1],yerr=sx[:-1],c='red',ls='dashed',label="x",alpha=0.8)
            #a.scatter(rlogbin_cen[:-1], y[:-1],c='lightgreen',marker='.',s=60)
            #a.errorbar(rlogbin_cen[:-1], y[:-1], yerr=sy[:-1],c='lightgreen',ls='dashed',label="y",alpha=0.8)
            #a.scatter(rlogbin_cen[:-1], z[:-1],c='salmon',marker='.',s=60)
            #a.errorbar(rlogbin_cen[:-1], z[:-1], yerr=sz[:-1],c='salmon',ls='dashed',label="z",alpha=0.8)
            #a.scatter(rlogbin_cen[:-1], cen[:-1],c='forestgreen',marker='.',s=60)
            #a.errorbar(rlogbin_cen[:-1], cen[:-1], yerr=scen[:-1],c='forestgreen',ls='dashed',label="center of the box",alpha=0.8)

            #a.axvline(x=1087, color='grey')
            #a.text(1087, -6, "$R_{500}$", rotation=90, size=16)
            #a.axvline(x=2147, color='grey', ls='dashed')
            #a.text(2147, -6, "$R_{vir}$", rotation=90, size=16)
            #a.set_xlim(50,6000)
            #a.set_ylim(-6.4, -2.1)
            #a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            #a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            #a.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{e}}$[c$\mathrm{m^{-3}}$])", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            #a.legend()
            #a.set_xscale('log')
            # plt.xticks(fontsize=14)
            #a.set_yticks()


            #f_interp_lin = interp1d(rlogbin_cen_3d,three_d_prof, fill_value='extrapolate')
            #y_interp_3d=f_interp_lin(rlogbin_cen)

            #res_x = -(x- y_interp_3d)/y_interp_3d
            #res_y = -(y - y_interp_3d) / y_interp_3d
            #res_z = -(z - y_interp_3d) / y_interp_3d
            #res_cen = -(cen- y_interp_3d) / y_interp_3d

            #b.plot(rlogbin_cen[:-1],res_x[:-1],c='red',ls='dashed',label="x",alpha=0.8)
            #b.plot(rlogbin_cen[:-1], res_y[:-1],c='lightgreen',ls='dashed',label="y",alpha=0.8)
            #b.plot(rlogbin_cen[:-1], res_z[:-1],c='salmon',ls='dashed',label="z",alpha=0.8)
            #b.plot(rlogbin_cen[:-1], res_cen[:-1],c='forestgreen',ls='dashed',label="center",alpha=0.8)

            #b.axvline(x=1087, color='grey')
            #b.text(1087, -7, "$R_{500}$", rotation=90, size=16)
            #b.axvline(x=2147, color='grey', ls='dashed')
            #b.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
            #b.set_xlabel("R(kpc)", size=16)
            #plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            #b.set_ylabel("Relative difference",size=16)
            #plt.legend(prop={'size': 16})
            #b.set_xscale('log')
            #b.set_xlim(50,6000)
            #b.set_ylim(-0.04, 0.05)
            #zerox=np.linspace(50,8000,500)
            #zeroy=np.zeros(500)
            #b.plot(zerox,zeroy,c='orange',ls='dotted')
            #b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            #b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            #b.set_xticks()
            #b.set_yticks()
            # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
            # plt.xlim(50,7000)


            c.scatter(rlogbin_cen_3d, three_d_prof, s=6, c='orange')
            c.errorbar(rlogbin_cen_3d, three_d_prof, yerr=std_three_d_prof, ls='dotted', label='3D, $8192^3$', alpha=0.7, c='orange')
            c.scatter(rlogbin_cen[:-1], fil[:-1], c='blue', marker='.', s=60)
            c.errorbar(rlogbin_cen[:-1], fil[:-1], yerr=sfil[:-1], c='blue', ls='dotted', label="Fil", alpha=0.8)
            c.scatter(rlogbin_cen[:-1], filx[:-1], c='green', marker='.', s=60)
            c.errorbar(rlogbin_cen[:-1], filx[:-1], yerr=sfilx[:-1], c='green', ls='dashed', label="Filx", alpha=0.8)
            c.scatter(rlogbin_cen[:-1], fily[:-1], c='dimgrey', marker='.', s=60)
            c.errorbar(rlogbin_cen[:-1], fily[:-1], yerr=sfily[:-1], c='dimgrey', ls='dashdot', label="Fily", alpha=0.8)
            c.scatter(rlogbin_cen[:-1], cen[:-1],c='red',marker='.',s=60)
            c.errorbar(rlogbin_cen[:-1], cen[:-1], yerr=scen[:-1],c='red',ls='solid',label="Cen", alpha=0.8)


            c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True, labelleft=True)
            c.axvline(x=1087, color='grey')
            c.text(1087, -3.5, "$R_{500}$", rotation=90, size=16)
            c.axvline(x=2147, color='grey', ls='dashed')
            c.text(2147, -3.5, "$R_{vir}$", rotation=90, size=16)
            c.set_xlim(50, 6000)
            c.set_ylim(-6.4, -2.1)
            # plt.xlabel("R(kpc)", size=16)
            c.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{e}}$[c$\mathrm{m^{-3}}$])", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            c.legend()
            c.set_xscale('log')
            #c.yaxis.set_ticklabels([])
            # plt.xticks(fontsize=14)
            # a.set_yticks()

            f_interp_lin = interp1d(rlogbin_cen_3d, three_d_prof, fill_value='extrapolate')
            y_interp_3d = f_interp_lin(rlogbin_cen)

            #res_x = -(deproj_x_h_P - y_interp_3d) / y_interp_3d
            #res_y = -(deproj_y_h_P - y_interp_3d) / y_interp_3d
            #res_z = -(deproj_z_h_P - y_interp_3d) / y_interp_3d
            #res_cen = -(deproj_cen_h_P - y_interp_3d) / y_interp_3d
            res_fil = -(fil - y_interp_3d) / y_interp_3d
            res_filx = -(filx - y_interp_3d) / y_interp_3d
            res_fily = -(fily - y_interp_3d) / y_interp_3d
            res_cen = -(cen - y_interp_3d) / y_interp_3d

            # plt.subplot(3,1,3)
            d.plot(rlogbin_cen[:-1], res_filx[:-1], c='green', ls='dashed',label="perpendicular to the main filament (rotation around x axis) projection ", alpha=0.8)
            d.plot(rlogbin_cen[:-1], res_fily[:-1], c="dimgrey", ls='dashdot', label="perpendicular to the main filament (rotation around y axis) projection", alpha=0.8)
            d.plot(rlogbin_cen[:-1], res_fil[:-1], c='blue', ls='dotted', label="main filament axis projection", alpha=0.8)
            d.plot(rlogbin_cen[:-1], res_cen[:-1],c='red',ls='solid',label="center",alpha=0.8)

            d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            d.axvline(x=1087, color='grey')
            #d.text(1087, -7, "$R_{500}$", rotation=90, size=16)
            d.axvline(x=2147, color='grey', ls='dashed')
            #d.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
            d.set_xlabel("$R$ [kpc]", size=16)
            #d.yaxis.set_ticklabels([])
            # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            d.set_ylabel("Relative difference", size=16)
            # plt.legend(prop={'size': 16})
            d.set_xscale('log')
            d.set_xlim(50, 6000)
            d.set_ylim(-0.04, 0.05)
            zerox = np.linspace(50, 8000, 500)
            zeroy = np.zeros(500)
            d.plot(zerox, zeroy, c='orange', ls='dotted')
            # b.set_xticks()
            # b.set_yticks()
            # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
            # plt.xlim(50,7000)
            plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()
            print("end")
            sys.exit()

        def proj_prof_P_h():
            #print("test 2")
            x = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_x_h.txt")
            y = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_y_h.txt")
            z = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_z_h.txt")
            cen = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_MW_h.txt")
            fil = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_fil_h.txt")
            filx = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_filx_h.txt")
            fily = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_fily_h.txt")

            sx = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_x_h.txt")
            sy = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_y_h.txt")
            sz = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_z_h.txt")
            scen = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_cen_h.txt")
            sfil = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_fil_h.txt")
            sfilx = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_filx_h.txt")
            sfily = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_fily_h.txt")

            #print("profiles loaded")

            f,(a,b)=plt.subplots(1,2)

            a.scatter(rlogbin_cen, x, marker='.', s=80, c="red")
            a.errorbar(rlogbin_cen, x, yerr=sx, label='x', ls='dashed', alpha=0.8, c="red")
            a.scatter(rlogbin_cen, y, marker='.', s=80,c="lightgreen")
            a.errorbar(rlogbin_cen, y, yerr=sy, label='y', ls='dashed', alpha=0.8,c="lightgreen")
            a.scatter(rlogbin_cen, z, marker='.', s=80, c="skyblue")
            a.errorbar(rlogbin_cen, z, yerr=sz, label='z', ls='dashed', alpha=0.8, c="skyblue")
            a.scatter(rlogbin_cen, cen, marker='.', s=80, c="forestgreen")
            a.errorbar(rlogbin_cen, cen, yerr=scen, label='center of the box', ls='dashed', alpha=0.8, c="forestgreen")
            a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            a.set_xscale('log')
            a.axvline(x=1087, color='grey')
            a.text(1087, -6, "$R_{500}$", rotation=90, size=16)
            a.axvline(x=2147, color='grey', ls='dashed')
            a.text(2147, -6, "$R_{vir}$", rotation=90, size=16)
            a.set_xlim(50, 8000)
            a.set_ylim(-7.6,-1.9)
            # plt.xlabel("R(kpc)", size=16)
            a.set_ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)
            a.set_xlabel('$R$[kpc]')
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            a.legend()

            b.scatter(rlogbin_cen, fil, marker='.', s=80,color="salmon")
            b.errorbar(rlogbin_cen, fil, yerr=sfil, label='main filament', ls='dashed', alpha=0.8,color="salmon")
            b.scatter(rlogbin_cen, filx, marker='.', s=80,color="pink")
            b.errorbar(rlogbin_cen, filx, yerr=sfilx, label= "90° rotation around x axis", ls='dashed', alpha=0.8,color="pink")
            b.scatter(rlogbin_cen, fily, marker='.', s=80,color="purple")
            b.errorbar(rlogbin_cen, fily, yerr=sfily, label='90° rotation around y axis', ls='dashed', alpha=0.8,color="purple")
            b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            b.set_xscale('log')
            #b.get_yaxis().set_visible(False)
            b.yaxis.set_ticklabels([])
            b.axvline(x=1087, color='grey')
            b.text(1087, -6, "$R_{500}$", rotation=90, size=16)
            b.axvline(x=2147, color='grey', ls='dashed')
            b.text(2147, -6, "$R_{vir}$", rotation=90, size=16)
            b.set_xlim(50, 8000)
            b.set_ylim(-7.6, -1.9)
            b.set_xlabel('$R$[kpc]')
            # plt.xlabel("R(kpc)", size=16)
            #b.set_ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            b.legend()

            plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()

            sys.exit()

        def proj_prof_P_4_h():
            #print("test 2")
            x = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_x_h.txt")
            y = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_y_h.txt")
            z = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_z_h.txt")
            cen = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_MW_h.txt")
            fil = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_fil_h.txt")
            filx = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_filx_h.txt")
            fily = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/proj_P_fily_h.txt")

            sx = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_x_h.txt")
            sy = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_y_h.txt")
            sz = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_z_h.txt")
            scen = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_cen_h.txt")
            sfil = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_fil_h.txt")
            sfilx = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_filx_h.txt")
            sfily = np.loadtxt("./proj+deproj_profiles/fig_proj_P_7_h/std_proj_P_fily_h.txt")

            #print("profiles loaded")

            #f,(a,b)=plt.subplots(1,2)
            #plt.figure()

            #a.scatter(rlogbin_cen, x, marker='.', s=80, c="red")
            #a.errorbar(rlogbin_cen, x, yerr=sx, label='x', ls='dashed', alpha=0.8, c="red")
            #a.scatter(rlogbin_cen, y, marker='.', s=80,c="lightgreen")
            #a.errorbar(rlogbin_cen, y, yerr=sy, label='y', ls='dashed', alpha=0.8,c="lightgreen")
            #a.scatter(rlogbin_cen, z, marker='.', s=80, c="skyblue")
            #a.errorbar(rlogbin_cen, z, yerr=sz, label='z', ls='dashed', alpha=0.8, c="skyblue")
            #a.scatter(rlogbin_cen, cen, marker='.', s=80, c="forestgreen")
            #a.errorbar(rlogbin_cen, cen, yerr=scen, label='center of the box', ls='dashed', alpha=0.8, c="forestgreen")
            #a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            #a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            #a.set_xscale('log')
            #a.axvline(x=1087, color='grey')
            #a.axvline(x=2147, color='grey', ls='dashed')
            #a.text(2147, -6, "$R_{vir}$", rotation=90, size=16)
            #a.set_xlim(50, 8000)
            #a.set_ylim(-7.6,-1.9)
            # plt.xlabel("R(kpc)", size=16)
            #a.set_ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)
            #a.set_xlabel('$R$[kpc]')
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            #a.legend()

            plt.scatter(rlogbin_cen, fil, marker='.', s=80,color="blue")
            plt.errorbar(rlogbin_cen, fil, yerr=sfil, label='Fil', ls='dotted', alpha=0.8,color="blue")
            plt.scatter(rlogbin_cen, filx, marker='.', s=80,color="green")
            plt.errorbar(rlogbin_cen, filx, yerr=sfilx, label= "Filx", ls='dashed', alpha=0.8,color="green")
            plt.scatter(rlogbin_cen, fily, marker='.', s=80,color="dimgrey")
            plt.errorbar(rlogbin_cen, fily, yerr=sfily, label="Fily", ls='dashdot', alpha=0.8,color="dimgrey")
            plt.scatter(rlogbin_cen, cen, marker='.', s=80, c="red")
            plt.errorbar(rlogbin_cen, cen, yerr=scen, label='Cen', ls='solid', alpha=0.8, c="red")
            plt.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            plt.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            plt.xscale('log')
            #b.get_yaxis().set_visible(False)
            #b.yaxis.set_ticklabels([])
            plt.axvline(x=1087, color='grey')
            plt.text(1087, -3, "$R_{500}$", rotation=90, size=16)
            plt.axvline(x=2147, color='grey', ls='dashed')
            plt.text(2147, -3, "$R_{vir}$", rotation=90, size=16)
            plt.xlim(50, 8000)
            plt.ylim(-7.6, -1.9)
            plt.ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)
            plt.xlabel('$R$[kpc]')
            # plt.xlabel("R(kpc)", size=16)
            #b.set_ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            plt.legend(loc='lower left')

            #plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()

            sys.exit()

        def proj_prof_ne_h():
            x = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_x_h.txt")
            y = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_y_h.txt")
            z = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_z_h.txt")
            cen = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_cen_h.txt")
            fil = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_fil_h.txt")
            filx = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_filx_h.txt")
            fily = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_fily_h.txt")

            sx = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_x_h.txt")
            sy = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_y_h.txt")
            sz = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_z_h.txt")
            scen = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_cen_h.txt")
            sfil = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_fil_h.txt")
            sfilx = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_filx_h.txt")
            sfily = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_fily_h.txt")

            f,(a,b)=plt.subplots(1,2)

            a.scatter(rlogbin_cen, x, marker='.', s=80, c="red")
            a.errorbar(rlogbin_cen, x, yerr=sx, label='x', ls='dashed', alpha=0.8, c="red")
            a.scatter(rlogbin_cen, y, marker='.', s=80,c="lightgreen")
            a.errorbar(rlogbin_cen, y, yerr=sy, label='y', ls='dashed', alpha=0.8,c="lightgreen")
            a.scatter(rlogbin_cen, z, marker='.', s=80, c="salmon")
            a.errorbar(rlogbin_cen, z, yerr=sz, label='z', ls='dashed', alpha=0.8, c="salmon")
            a.scatter(rlogbin_cen, cen, marker='.', s=80, c="forestgreen")
            a.errorbar(rlogbin_cen, cen, yerr=scen, label='center of the box', ls='dashed', alpha=0.8, c="forestgreen")
            a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            a.set_xscale('log')
            a.axvline(x=1087, color='grey')
            a.text(1087, 17.8, "$R_{500}$", rotation=90, size=16)
            a.axvline(x=2147, color='grey', ls='dashed')
            a.text(2147, 17.8, "$R_{vir}$", rotation=90, size=16)
            a.set_xlim(50, 8000)
            a.set_ylim(16.8, 20)
            #a.set_ylim(-7.6,-1.9)
            # plt.xlabel("R(kpc)", size=16)
            #a.set_ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            a.set_xlabel('R(kpc)')
            a.set_ylabel("$log_{10}(n_e[cm^{-2}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            a.legend()

            b.scatter(rlogbin_cen, fil, marker='.', s=80,color="salmon")
            b.errorbar(rlogbin_cen, fil, yerr=sfil, label='main filament', ls='dashed', alpha=0.8,color="salmon")
            b.scatter(rlogbin_cen, filx, marker='.', s=80,color="pink")
            b.errorbar(rlogbin_cen, filx, yerr=sfilx, label= "90° rotation around x axis", ls='dashed', alpha=0.8,color="pink")
            b.scatter(rlogbin_cen, fily, marker='.', s=80,color="purple")
            b.errorbar(rlogbin_cen, fily, yerr=sfily, label='90° rotation around y axis', ls='dashed', alpha=0.8,color="purple")
            b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            b.set_xscale('log')
            #b.get_yaxis().set_visible(False)
            b.yaxis.set_ticklabels([])
            b.axvline(x=1087, color='grey')
            b.text(1087, 17.8, "$R_{500}$", rotation=90, size=16)
            b.axvline(x=2147, color='grey', ls='dashed')
            b.text(2147, 17.8, "$R_{vir}$", rotation=90, size=16)
            b.set_xlim(50, 8000)
            b.set_ylim(16.8, 20)
            #b.set_ylim(-7.6, -1.9)
            b.set_xlabel('R(kpc)')
            # plt.xlabel("R(kpc)", size=16)
            #b.set_ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            b.legend()

            f.suptitle('Projected electron density profiles')

            plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()

            sys.exit()

        def proj_prof_ne_4_h():
            x = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_x_h.txt")
            y = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_y_h.txt")
            z = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_z_h.txt")
            cen = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_cen_h.txt")
            fil = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_fil_h.txt")
            filx = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_filx_h.txt")
            fily = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/proj_ne_fily_h.txt")

            sx = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_x_h.txt")
            sy = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_y_h.txt")
            sz = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_z_h.txt")
            scen = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_cen_h.txt")
            sfil = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_fil_h.txt")
            sfilx = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_filx_h.txt")
            sfily = np.loadtxt("./proj+deproj_profiles/fig_proj_ne_7_h/std_proj_ne_fily_h.txt")

            #f, (a, b) = plt.subplots(1, 2)

            #a.scatter(rlogbin_cen, x, marker='.', s=80, c="red")
            #a.errorbar(rlogbin_cen, x, yerr=sx, label='x', ls='dashed', alpha=0.8, c="red")
            #a.scatter(rlogbin_cen, y, marker='.', s=80, c="lightgreen")
            #a.errorbar(rlogbin_cen, y, yerr=sy, label='y', ls='dashed', alpha=0.8, c="lightgreen")
            #a.scatter(rlogbin_cen, z, marker='.', s=80, c="salmon")
            #a.errorbar(rlogbin_cen, z, yerr=sz, label='z', ls='dashed', alpha=0.8, c="salmon")
            #a.scatter(rlogbin_cen, cen, marker='.', s=80, c="forestgreen")
            #a.errorbar(rlogbin_cen, cen, yerr=scen, label='center of the box', ls='dashed', alpha=0.8, c="forestgreen")
            #a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            #a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            #a.set_xscale('log')
            #a.axvline(x=1087, color='grey')
            #a.text(1087, 17.8, "$R_{500}$", rotation=90, size=16)
            #a.axvline(x=2147, color='grey', ls='dashed')
            #a.text(2147, 17.8, "$R_{vir}$", rotation=90, size=16)
            #a.set_xlim(50, 8000)
            #a.set_ylim(16.8, 20)
            # a.set_ylim(-7.6,-1.9)
            # plt.xlabel("R(kpc)", size=16)
            # a.set_ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            #a.set_xlabel('R(kpc)')
            #a.set_ylabel("$log_{10}(n_e[cm^{-2}])$", size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            #.legend()

            plt.scatter(rlogbin_cen, fil, marker='.', s=80, color="blue")
            plt.errorbar(rlogbin_cen, fil, yerr=sfil, label='Fil', ls='dotted', alpha=0.8, color="blue")
            plt.scatter(rlogbin_cen, filx, marker='.', s=80, color="green")
            plt.errorbar(rlogbin_cen, filx, yerr=sfilx, label="Filx", ls='dashed', alpha=0.8,color="green")
            plt.scatter(rlogbin_cen, fily, marker='.', s=80, color="dimgrey")
            plt.errorbar(rlogbin_cen, fily, yerr=sfily, label='Fily', ls='dashdot', alpha=0.8,color="dimgrey")
            plt.scatter(rlogbin_cen, cen, marker='.', s=80, c="red")
            plt.errorbar(rlogbin_cen, cen, yerr=scen, label='Cen', ls='solid', alpha=0.8, c="red")
            plt.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            plt.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            plt.xscale('log')
            # b.get_yaxis().set_visible(False)
            #plt.yaxis.set_ticklabels([])
            plt.axvline(x=1087, color='grey')
            plt.text(1087, 19.3, "$R_{500}$", rotation=90, size=16)
            plt.axvline(x=2147, color='grey', ls='dashed')
            plt.text(2147, 19.3, "$R_{vir}$", rotation=90, size=16)
            plt.xlim(50, 8000)
            plt.ylim(16.8, 20)
            # b.set_ylim(-7.6, -1.9)
            plt.xlabel('$R$ [kpc]')
            # plt.xlabel("R(kpc)", size=16)
            # b.set_ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            plt.ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{e}}$[c$\mathrm{m^{-2}}$])",size=14)
            # plt.ylabel("$log_{10}(T[keV])$", size=14)
            plt.legend(loc='lower left')

            #f.suptitle('Projected electron density profiles')

            #plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()

            sys.exit()

        def deproj_px_tests():
            r=np.loadtxt("r_deproj_px_tests.txt")
            dkpx=np.loadtxt("deproj_p_z_2000px.txt")
            #dkpxbis = np.loadtxt("deproj_p_z_2000px_2.txt")
            qkpx=np.loadtxt("deproj_p_z_4000px.txt")
            hkpx = np.loadtxt("deproj_p_z_8000px.txt")
            skpx = np.loadtxt("deproj_p_z_16000px.txt")
            douzekpx = np.loadtxt("deproj_p_z_12000px.txt")
            dixkpx = np.loadtxt("deproj_p_z_10000px.txt")

            print(skpx)
            print(r)

            plt.plot(r, dkpx,label="2000px")
            #plt.plot(r, dkpxbis,label="2000px bis")
            plt.plot(r, qkpx, label="4000px (used before)")
            plt.plot(r, hkpx, label="8000px")
            plt.plot(r, dixkpx, label="10000px")
            plt.plot(r, douzekpx, label="12000px")
            plt.plot(r, skpx, label="16000px")

            #plt.legend()
            #plt.show()
            #sys.exit()

        def deproj_px_tests_low():
            r = np.loadtxt("r_deproj_px_tests_low.txt")
            ukpx = np.loadtxt("deproj_p_z_1000px_low.txt")
            uckpx = np.loadtxt("deproj_p_z_1500px_low.txt")
            dkpx = np.loadtxt("deproj_p_z_2000px_low.txt")
            tkpx = np.loadtxt("deproj_p_z_3000px_low.txt")
            #dkpxbis = np.loadtxt("deproj_p_z_2000px_2.txt")
            qkpx = np.loadtxt("deproj_p_z_4000px_low.txt")
            #hkpx = np.loadtxt("deproj_p_z_8000px.txt")
            #skpx = np.loadtxt("deproj_p_z_16000px.txt")
            #douzekpx = np.loadtxt("deproj_p_z_12000px.txt")
            #dixkpx = np.loadtxt("deproj_p_z_10000px.txt")

            #print(skpx)
            #print(r)

            plt.plot(r,ukpx, label="1000px")
            plt.plot(r,uckpx, label="1500px")
            plt.plot(r, dkpx, label="2000px")
            plt.plot(r, tkpx, label="3000px")
            #plt.plot(r, dkpxbis, label="2000px bis")
            plt.plot(r, qkpx, label="4000px")
            #plt.plot(r, hkpx, label="8000px")
            #plt.plot(r, dixkpx, label="10000px")
            #plt.plot(r, douzekpx, label="12000px")
            #plt.plot(r, skpx, label="16000px")

        def compar_h_l_3d_vs_dep_fil_p_ne():# Plot P  3D high, low (in main code), deproj low high /r fil

            Plogmed_17, Pstdlogmed_17, Plogmean_17, Pstdlogmean_17, Tlogmed_17, Tstdlogmed_17, Tlogmean_17, Tstdlogmean_17, nelogmed_17, nestdlogmed_17, nelogmean_17, nestdlogmean_17, nlog_17, mlog_17, ndm_17, mdm_17, inf_17, middle_17, sup_17 = load_lograd_dat("lograd_data_lvl17_cleanm1e9.npy")
            Plogmed_c8, Pstdlogmed_c8, Plogmean_c8, Pstdlogmean_c8, Tlogmed_c8, Tstdlogmed_c8, Tlogmean_c8, Tstdlogmean_c8, nelogmed_c8, nestdlogmed_c8, nelogmean_c8, nestdlogmean_c8, nlog_c8, mlog_c8, ndm_c8, mdm_c8, inf_c8, middle_c8, sup_c8 = load_lograd_dat("lograd_data_lvl21_cleanm1e8.5.npy")
            Plogmed_19, Pstdlogmed_19, Plogmean_19, Pstdlogmean_19, Tlogmed_19, Tstdlogmed_19, Tlogmean_19, Tstdlogmean_19, nelogmed_19, nestdlogmed_19, nelogmean_19, nestdlogmean_19, nlog_19, mlog_19, ndm_19, mdm_19, inf_19, middle_19, sup_19 = load_lograd_dat("lograd_data_lvl19_cleanm1e9.npy")
            rlogbin_cen_threed = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

            f,(a,b)=plt.subplots(2,1)

            # low res

            #deproj_z_low_P_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_P_fil_100_l.txt")
            #deproj_z_low_P_810bgsub_std = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_P_fil_100_l.txt")
            #lonely_deproj_low = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_P_fil_100_l.txt")

            #n_it = 100
            #for i in range(n_it):
            #    a.plot(rlogbin_cen[0:20], lonely_deproj_low[0:20, i], lw=1, alpha=0.03, color='blue')

            # low res lvl 19

            deproj_z_low_P_810bgsub_19 = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_P_fil_100_l_19.txt")
            deproj_z_low_P_810bgsub_std_19 = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_P_fil_100_l_19.txt")
            lonely_deproj_low_19 = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_P_fil_100_l_19.txt")

            n_it = 100
            for i in range(n_it):
                a.plot(rlogbin_cen[0:20], lonely_deproj_low_19[0:20, i], lw=1, alpha=0.03, color='blue')

            # high res

            deproj_z_high_P_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_P_fil_100_h.txt")
            deproj_z_high_P_810bgsub_std = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_P_fil_100_h.txt")
            lonely_deproj = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_P_fil_100_h.txt")

            n_it = 100
            for i in range(n_it):
                a.plot(rlogbin_cen[0:20], lonely_deproj[0:20,i], lw=1, alpha=0.03, color='orange')

            #a.scatter(rlogbin_cen_threed, Plogmean_17, s=6, c='blue')
            #a.errorbar(rlogbin_cen_threed, Plogmean_17, yerr=Pstdlogmean_17, ls='dotted', label='3D, $2048^3$', alpha=0.7, c='blue')  # 'Smallest grid size: 5.62kpc'
            a.scatter(rlogbin_cen_threed, Plogmean_19, s=6, c='blue')
            a.errorbar(rlogbin_cen_threed, Plogmean_19, yerr=Pstdlogmean_19, ls='dotted', label='3D, $2048^3$',alpha=0.7, c='blue')  # 'Smallest grid size: 5.62kpc'
            a.scatter(rlogbin_cen_threed, Plogmean_c8, s=6, c='orange')
            a.errorbar(rlogbin_cen_threed, Plogmean_c8, yerr=Pstdlogmean_c8, ls='dotted', label='3D, $8192^3$', alpha=0.7, c='orange')  # '''Smallest grid size: 0.35kpc
            #a.scatter(rlogbin_cen[0:20], deproj_z_low_P_810bgsub[0:20],c='blue',s=8)
            #a.errorbar(rlogbin_cen[0:20], deproj_z_low_P_810bgsub[0:20], yerr=deproj_z_low_P_810bgsub_std[0:20] , capsize=2,c='blue',label="Fil, $2048^3$",alpha=0.8)
            a.scatter(rlogbin_cen[0:20], deproj_z_low_P_810bgsub_19[0:20], c='blue', s=8)
            a.errorbar(rlogbin_cen[0:20], deproj_z_low_P_810bgsub_19[0:20], yerr=deproj_z_low_P_810bgsub_std_19[0:20],capsize=2, c='blue', label="Fil, $2048^3$", alpha=0.8)
            a.scatter(rlogbin_cen[0:20], deproj_z_high_P_810bgsub[0:20], c="orange",s=8)
            a.errorbar(rlogbin_cen[0:20], deproj_z_high_P_810bgsub[0:20], yerr=deproj_z_high_P_810bgsub_std[0:20],capsize=2, c="orange", label="Fil, $8192^3$", alpha=0.8)
            a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16,labelbottom=True, labelleft=True)
            a.axvline(x=1087, color='grey')
            a.text(1087, -2, "$\mathrm{R_{500}}$", rotation=90, size=16)
            a.axvline(x=2147, color='grey', ls='dashed')
            a.text(2147, -2, "$\mathrm{R_{vir}}$", rotation=90, size=16)
            a.legend(prop={'size': 16})
            a.set_xscale('log')
            a.set_ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)


            # low res

            #deproj_z_low_ne_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_ne_fil_100_l.txt")
            #deproj_z_low_ne_810bgsub_std = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_ne_fil_100_l.txt")
            #lonely_deproj_low_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_ne_fil_100_l.txt")

            #n_it = 100
            #for i in range(n_it):
            #    b.plot(rlogbin_cen[0:20], lonely_deproj_low_ne[0:20, i], lw=1, alpha=0.03, color='blue')

            # low res, lvl 19

            deproj_z_low_ne_810bgsub_19= np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_ne_fil_100_l_19.txt")
            deproj_z_low_ne_810bgsub_std_19 = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_ne_fil_100_l_19.txt")
            lonely_deproj_low_ne_19 = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_ne_fil_100_l_19.txt")

            n_it = 100
            for i in range(n_it):
                b.plot(rlogbin_cen[0:20], lonely_deproj_low_ne_19[0:20, i], lw=1, alpha=0.03, color='blue')

            # high res

            deproj_z_high_ne_810bgsub = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_ne_fil_100_h.txt")
            deproj_z_high_ne_810bgsub_std = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_ne_fil_100_h.txt")
            lonely_deproj_high_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_ne_fil_100_h.txt")

            n_it = 100
            for i in range(n_it):
                b.plot(rlogbin_cen[0:20], lonely_deproj_high_ne[0:20, i], lw=1, alpha=0.03, color='orange')

            #b.scatter(rlogbin_cen_threed, nelogmean_17, s=6, c='blue')
            #b.errorbar(rlogbin_cen_threed, nelogmean_17, yerr=nestdlogmean_17, ls='dotted', label='3D, $2048^3$',alpha=0.7, c='blue')  # 'Smallest grid size: 5.62kpc'
            b.scatter(rlogbin_cen_threed, nelogmean_19, s=6, c='blue')
            b.errorbar(rlogbin_cen_threed, nelogmean_19, yerr=nestdlogmean_19, ls='dotted', label='3D, $2048^3$', alpha=0.7, c='blue')  # 'Smallest grid size: 5.62kpc'
            b.scatter(rlogbin_cen_threed, nelogmean_c8, s=6, c='orange')
            b.errorbar(rlogbin_cen_threed, nelogmean_c8, yerr=nestdlogmean_c8, ls='dotted', label='3D, $8192^3$', alpha=0.7, c='orange')  # '''Smallest grid size: 0.35kpc
            #b.scatter(rlogbin_cen[0:20], deproj_z_low_ne_810bgsub[0:20], c='blue', s=8)
            #b.errorbar(rlogbin_cen[0:20], deproj_z_low_ne_810bgsub[0:20], yerr=deproj_z_low_ne_810bgsub_std[0:20],capsize=2, c='blue', label="Fil, $2048^3$", alpha=0.8)
            b.scatter(rlogbin_cen[0:20], deproj_z_low_ne_810bgsub_19[0:20], c='blue', s=8)
            b.errorbar(rlogbin_cen[0:20], deproj_z_low_ne_810bgsub_19[0:20], yerr=deproj_z_low_ne_810bgsub_std_19[0:20],capsize=2, c='blue', label="Fil, $2048^3$", alpha=0.8)
            b.scatter(rlogbin_cen[0:20], deproj_z_high_ne_810bgsub[0:20], c="orange", s=8)
            b.errorbar(rlogbin_cen[0:20], deproj_z_high_ne_810bgsub[0:20], yerr=deproj_z_high_ne_810bgsub_std[0:20],capsize=2, c="orange", label="Fil, $8192^3$", alpha=0.8)
            b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16,labelbottom=True, labelleft=True)
            b.axvline(x=1087, color='grey')
            b.text(1087, -3, "$\mathrm{R_{500}}$", rotation=90, size=16)
            b.axvline(x=2147, color='grey', ls='dashed')
            b.text(2147, -3, "$\mathrm{R_{vir}}$", rotation=90, size=16)
            #b.legend(prop={'size': 16})
            b.set_xlabel("$R$[kpc]", size=16)
            b.set_xscale('log')
            b.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{e}}$[c$\mathrm{m^{-3}}$])", size=16)

            plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()
            print("end")
            sys.exit()

        def compar_3D_vs_dep_fil():

            Plogmed_17, Pstdlogmed_17, Plogmean_17, Pstdlogmean_17, Tlogmed_17, Tstdlogmed_17, Tlogmean_17, Tstdlogmean_17, nelogmed_17, nestdlogmed_17, nelogmean_17, nestdlogmean_17, nlog_17, mlog_17, ndm_17, mdm_17, inf_17, middle_17, sup_17 = load_lograd_dat(
                "lograd_data_lvl17_cleanm1e9.npy")
            Plogmed_c8, Pstdlogmed_c8, Plogmean_c8, Pstdlogmean_c8, Tlogmed_c8, Tstdlogmed_c8, Tlogmean_c8, Tstdlogmean_c8, nelogmed_c8, nestdlogmed_c8, nelogmean_c8, nestdlogmean_c8, nlog_c8, mlog_c8, ndm_c8, mdm_c8, inf_c8, middle_c8, sup_c8 = load_lograd_dat(
                "lograd_data_lvl21_cleanm1e8.5.npy")
            rlogbin_cen_threed = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

            #f, (a, b) = plt.subplots(2, 1)

            # low res

            deproj_z_low_P_810bgsub = np.loadtxt(
                "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_P_fil_100_l.txt")
            deproj_z_low_P_810bgsub_std = np.loadtxt(
                "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_P_fil_100_l.txt")
            lonely_deproj_low = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_P_fil_100_l.txt")

            #n_it = 100
            #for i in range(n_it):
            #    plt.plot(rlogbin_cen[0:20], lonely_deproj_low[0:20, i], lw=1, alpha=0.03, color='blue')

            # high res

            deproj_z_high_P_810bgsub = np.loadtxt(
                "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_P_fil_100_h.txt")
            deproj_z_high_P_810bgsub_std = np.loadtxt(
                "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_P_fil_100_h.txt")
            lonely_deproj = np.loadtxt("./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_P_fil_100_h.txt")

            n_it = 100
            for i in range(n_it):
                plt.plot(rlogbin_cen[0:20], lonely_deproj[0:20, i], lw=1, alpha=0.03, color='orange')

            #plt.scatter(rlogbin_cen_threed, Plogmean_17, s=6, c='blue')
            #plt.errorbar(rlogbin_cen_threed, Plogmean_17, yerr=Pstdlogmean_17, ls='dotted', label='3D, $2048^3$',alpha=0.7, c='blue')  # 'Smallest grid size: 5.62kpc'
            plt.scatter(rlogbin_cen_threed, Plogmean_c8, s=6, c='orange')
            plt.errorbar(rlogbin_cen_threed, Plogmean_c8, yerr=Pstdlogmean_c8, ls='dotted', label='3D, $8192^3$',alpha=0.7, c='orange')  # '''Smallest grid size: 0.35kpc
            #a.scatter(rlogbin_cen[0:20], deproj_z_low_P_810bgsub[0:20], c='blue', s=8)
            #a.errorbar(rlogbin_cen[0:20], deproj_z_low_P_810bgsub[0:20], yerr=deproj_z_low_P_810bgsub_std[0:20],capsize=2, c='blue', label="Fil, $2048^3$", alpha=0.8)
            plt.scatter(rlogbin_cen[0:20], deproj_z_high_P_810bgsub[0:20], c="orange", s=8)
            plt.errorbar(rlogbin_cen[0:20], deproj_z_high_P_810bgsub[0:20], yerr=deproj_z_high_P_810bgsub_std[0:20],capsize=2, c="orange", label="Fil, $8192^3$", alpha=0.8)
            plt.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            plt.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
            plt.axvline(x=1087, color='grey')
            plt.text(1087, -2, "$\mathrm{R_{500}}$", rotation=90, size=16)
            plt.axvline(x=2147, color='grey', ls='dashed')
            plt.text(2147, -2, "$\mathrm{R_{vir}}$", rotation=90, size=16)
            plt.legend(prop={'size': 16})
            plt.xscale('log')
            plt.ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])", size=16)
            plt.xlabel('R (kpc)')

            # low res

            #deproj_z_low_ne_810bgsub = np.loadtxt(
            #    "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_ne_fil_100_l.txt")
            #deproj_z_low_ne_810bgsub_std = np.loadtxt(
            #    "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_ne_fil_100_l.txt")
            #lonely_deproj_low_ne = np.loadtxt(
            #    "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_ne_fil_100_l.txt")

            #n_it = 100
            #for i in range(n_it):
            #    b.plot(rlogbin_cen[0:20], lonely_deproj_low_ne[0:20, i], lw=1, alpha=0.03, color='blue')

            # high res

            #deproj_z_high_ne_810bgsub = np.loadtxt(
            #    "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/mean_deproj_ne_fil_100_h.txt")
            #deproj_z_high_ne_810bgsub_std = np.loadtxt(
            #    "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/std_deproj_ne_fil_100_h.txt")
            #lonely_deproj_high_ne = np.loadtxt(
            #    "./proj+deproj_profiles/fig_dep_p_ne_h_l_fil/lonely_deprojs_ne_fil_100_h.txt")

            #n_it = 100
            #for i in range(n_it):
            #    b.plot(rlogbin_cen[0:20], lonely_deproj_high_ne[0:20, i], lw=1, alpha=0.03, color='orange')

            #b.scatter(rlogbin_cen_threed, nelogmean_17, s=6, c='blue')
            #b.errorbar(rlogbin_cen_threed, nelogmean_17, yerr=nestdlogmean_17, ls='dotted', label='3D, $2048^3$',
            #           alpha=0.7, c='blue')  # 'Smallest grid size: 5.62kpc'
            #b.scatter(rlogbin_cen_threed, nelogmean_c8, s=6, c='orange')
            #b.errorbar(rlogbin_cen_threed, nelogmean_c8, yerr=nestdlogmean_c8, ls='dotted', label='3D, $8192^3$',
            #           alpha=0.7, c='orange')  # '''Smallest grid size: 0.35kpc
            #b.scatter(rlogbin_cen[0:20], deproj_z_low_ne_810bgsub[0:20], c='blue', s=8)
            #b.errorbar(rlogbin_cen[0:20], deproj_z_low_ne_810bgsub[0:20], yerr=deproj_z_low_ne_810bgsub_std[0:20],
            #           capsize=2, c='blue', label="Fil, $2048^3$", alpha=0.8)
            #b.scatter(rlogbin_cen[0:20], deproj_z_high_ne_810bgsub[0:20], c="orange", s=8)
            #b.errorbar(rlogbin_cen[0:20], deproj_z_high_ne_810bgsub[0:20], yerr=deproj_z_high_ne_810bgsub_std[0:20],
            #           capsize=2, c="orange", label="Fil, $8192^3$", alpha=0.8)
            #b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            #b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
            #              labelleft=True)
            #b.axvline(x=1087, color='grey')
            #b.text(1087, -3, "$\mathrm{R_{500}}$", rotation=90, size=16)
            #b.axvline(x=2147, color='grey', ls='dashed')
            #b.text(2147, -3, "$\mathrm{R_{vir}}$", rotation=90, size=16)
            #b.legend(prop={'size': 16})
            #b.set_xlabel("$R$[kpc]", size=16)
            #b.set_xscale('log')
            #b.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{e}}$[c$\mathrm{m^{-3}}$])", size=16)

            #plt.subplots_adjust(wspace=0, hspace=0)
            plt.show()
            print("end")
            sys.exit()

        #deproj_px_tests_low()

        #proj_prof_ne_h()

        #proj_prof_P_h()

        #compar_h_l_3d_vs_dep_z()

        P_deproj_4_high()

        #proj_prof_ne_4_h()

        #ne_deproj_4_high()

        #compar_h_l_3d_vs_dep_fil_p_ne()

        #compar_3D_vs_dep_fil()

        #print("test")

        #proj_prof_P_h()

        #compar_h_l_3d_vs_dep_z_p_ne()


    sys.exit()


def toy_model():
    @jit(nopython=True)
    def creation(npx):
        n = npx ** 3
        cen = 0.5 * (npx * 10)
        rad = 0.5 * cen
        bins=np.linspace(0,cen,100)
        print("bins",bins)
        sphere = np.zeros((5, n))
        print("created")

        for i in range(npx):
            print(i)
            for j in range(npx):
                for k in range(npx):
                    sphere[2, i * npx ** 2 + j * npx + k] = i * 10 + 5
                    sphere[1, i * npx ** 2 + j * npx + k] = j * 10 + 5
                    sphere[0, i * npx ** 2 + j * npx + k] = k * 10 + 5
                    sphere[3, i * npx ** 2 + j * npx + k] = np.sqrt(
                        (sphere[0, i * npx ** 2 + j * npx + k] - cen) ** 2 + (
                                    sphere[1, i * npx ** 2 + j * npx + k] - cen) ** 2 + (
                                    sphere[2, i * npx ** 2 + j * npx + k] - cen) ** 2)
                    #if (sphere[3, i * npx ** 2 + j * npx + k] < cen):
                        #sphere[4, i * npx ** 2 + j * npx + k] = 1

        for i in range(99):
            print(i)
            cond=np.logical_and(sphere[3,:]>bins[i],sphere[3,:]<bins[i+1])
            sphere[4,:][cond]=100-i
        return sphere

        # sphere[1,:]=[(i//npx)*5-10*(i//(npx*10)) for i in range(n)]

        # print(sphere[1,:])

    ### sphere creation and saving process ###

    #start=time.time()
    #sphere=creation(1000)
    #end=time.time()
    #print("time:",end-start)

    #print("toy model initialized")
    #np.save("sphere_toy_100-1.npy", sphere)
    #print("toy model saved")
    #sys.exit()

    ### Plotting the sphere in 3D ###

    def plot_sphere():
        sphere = creation(50)

        fig = plt.figure()
        ax = plt.axes(projection='3d')
        ax.scatter3D(sphere[0, :][sphere[4, :] == 1], sphere[1, :][sphere[4, :] == 1], sphere[2, :][sphere[4, :] == 1],
                     s=2, c='black')
        plt.show()

        sys.exit()

        # plot_sphere()

    ### Computing 3D radial profile ###

    def three_dim_profile():

        sphere = np.load("./toy_models/sphere_toy_1e5-1e-5.npy")

        print("File loaded")

        n = 21
        rad_prof = np.zeros(n)
        #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
        rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(21)])

        rlog = np.log10(sphere[3, :])

        for i in range(0, n):
            print(i)
            #cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
            cond = np.logical_and(rlog > (i + 17.5) * 0.1, rlog < (i + 18.5) * 0.1)
            rad_prof[i] = np.mean(sphere[4, :][cond])

        print(rad_prof)
        np.savetxt("./toy_models/3d_prof_toy_model_3.txt",rad_prof)
        plt.plot(rlogbin_cen, rad_prof)
        plt.show()
        sys.exit()

    #three_dim_profile()
    #sys.exit()

    ##### Creating the map ####

    def create_toy_model_map():
        #n = 1000
        #sphere = np.zeros((5, n))
        sphere = np.load("sphere_toy_1e5-1e-5.npy")

        print("File loaded")

        map=np.zeros((1000,1000))
        weights=np.zeros((1000,1000))

        sphere[0:3,:]/=10
        #sphere[0:3,:]=sphere[0:3,:].astype(int)


        #print("len sphere",len(sphere[0,:]))
        #sys.exit()
        #@jit('f8[:,:](f8[:,:])')

        @jit(nopython=True)
        def map_loop(map,sphere,weights):
            for i in range(len(sphere[0,:])):
                #print(i)
                if(i%1e6==0):
                    print(i)
                x=int(sphere[0,i])
                y=int(sphere[1,i])
                map[x,y] += sphere[4,i]*(pc*1e4)**3
                weights[x,y] += (pc*1e4)**3
            map[:,:]/=weights[:,:]

            #for i in range(1000):
            #    print(i)
            #    for j in range(1000):
            #        cond = np.logical_and( sphere[0, :]== np.float32(i), sphere[1, :] == np.float32(j) )
            #        map[i,j]=np.sum(sphere[4,:][cond])

            return map

        map_sphere=map_loop(map,sphere,weights)

        np.save("sphere_toy_map_weighted_mean_1e5-1e-5.npy", map_sphere)


        print(map)

        plt.imshow(map,cmap='Greys')
        plt.colorbar()
        plt.show()

    #create_toy_model_map()
    #sys.exit()


    def create_disk(npx):
        n = npx ** 2
        cen = 0.5 * (npx * 5)
        rad = 0.5 * cen
        print(rad)
        disk = np.zeros((4, n))
        map=np.zeros((npx,npx))
        print("array created")
        for i in range(npx):
            print(i)
            for j in range(npx):
                disk[1, i * npx + j] = j * 5 + 2.5
                disk[0, i * npx + j] = i * 5 + 2.5
                disk[2, i * npx + j] = np.sqrt((disk[0, i * npx + j] - cen) ** 2 + (disk[1, i * npx + j] - cen) ** 2)
                if (disk[2, i * npx + j] < rad):
                    disk[3, i * npx + j] = 1
                    map[i,j]=1
        #print("x",disk[1,:])
        return map

    #map=create_disk(4000)

    #np.save("sphere_toy_weighted_projection.npy",map)
    #print(map)
    #plt.imshow(map,cmap='Greys')
    #plt.colorbar()
    #plt.show()

    #map = np.load('sphere_toy_map_column_density.npy')

    #plt.plot(map[499,:])
    #plt.show()

    #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
    #threedprof=np.loadtxt("3d_prof_toy_model_2.txt")
    #plt.plot(rlogbin_cen,threedprof,marker='.',ls='dashed',alpha=0.8,lw=0.5,label='3d')

    #r_deprojprof_21=np.loadtxt("r_deproj_P_z_h_21bins.txt")
    #deprojprof_21=np.loadtxt("deproj_P_z_h_21bins.txt")
    #plt.plot(r_deprojprof_21,deprojprof_21,marker='.',ls='dashed',alpha=0.8,lw=0.5,label='21 bins')

    #r_deprojprof_42 = np.loadtxt("r_deproj_P_z_h_42bins.txt")
    #deprojprof_42 = np.loadtxt("deproj_P_z_h_42bins.txt")
    #plt.plot(r_deprojprof_42, deprojprof_42,marker='.',ls='dashed',alpha=0.8,lw=0.5,label='42 bins')

    #r_deprojprof_84 = np.loadtxt("r_deproj_P_z_h_84bins.txt")
    #deprojprof_84 = np.loadtxt("deproj_P_z_h_84bins.txt")
    #plt.plot(r_deprojprof_84, deprojprof_84, marker='.', ls='dashed', alpha=0.8, lw=0.5, label='84 bins')

    #r_deprojprof_210 = np.loadtxt("r_deproj_toy_model_2_210bins_mwmap.txt")
    #deprojprof_210 = np.loadtxt("deproj_toy_model_2_210bins_mwmap.txt")
    #plt.plot(r_deprojprof_210, deprojprof_210,marker='.',ls='dashed',alpha=0.8,lw=0.5,label='210 bins')

    three_dim_profile()

    plt.axvline(x=1087, color='grey')
    plt.text(1087, -7, "$R_{500}$", rotation=90, size=16)
    plt.axvline(x=2147, color='grey', ls='dashed')
    plt.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
    plt.xlabel("R(kpc)", size=16)
    plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)


    plt.xscale('log')

    #plt.show()
    #sys.exit()

    rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
    threedprof = np.loadtxt("3d_prof_toy_model_2.txt")
    plt.plot(rlogbin_cen, threedprof, marker='.', ls='dashed', alpha=0.8, lw=0.5, label='3d')

    "deproj_tm_mw_21bins_2.txt"

    r_deprojprof_21 = np.loadtxt("r_deproj_tm_mw_21bins_2.txt")
    deprojprof_21 = np.loadtxt("deproj_tm_mw_21bins_2.txt")
    plt.plot(r_deprojprof_21, deprojprof_21, marker='.', ls='dashed', alpha=0.8, lw=0.5, label='21 bins')

    r_deprojprof_42 = np.loadtxt("r_deproj_tm_mw_42bins_2.txt")
    deprojprof_42 = np.loadtxt("deproj_tm_mw_42bins_2.txt")
    plt.plot(r_deprojprof_42, deprojprof_42, marker='.', ls='dashed', alpha=0.8, lw=0.5, label='42 bins')

    r_deprojprof_84 = np.loadtxt("r_deproj_tm_mw_84bins_2.txt")
    deprojprof_84 = np.loadtxt("deproj_tm_mw_84bins_2.txt")
    plt.plot(r_deprojprof_84, deprojprof_84, marker='.', ls='dashed', alpha=0.8, lw=0.5, label='84 bins')

    #r_deprojprof_210 = np.loadtxt("r_deproj_toy_model_2_210bins_mwmap.txt")
    #deprojprof_210 = np.loadtxt("deproj_toy_model_2_210bins_mwmap.txt")
    #plt.plot(r_deprojprof_210, deprojprof_210, marker='.', ls='dashed', alpha=0.8, lw=0.5, label='210 bins')

    plt.legend()
    plt.show()
    sys.exit()

def gianfagna_overplot():
    data=np.loadtxt('gianfagna_plot.txt')
    r=data[:,0]
    b=data[:,1]
    plt.plot(r,b)
    datal = np.loadtxt('gianfagna_plot_lerrb.txt')
    r_lerrb = datal[:, 0]
    lerrb = datal[:, 1]
    plt.plot(r_lerrb,lerrb)

    datah = np.loadtxt('gianfagna_plot_herrb.txt')
    r_herrb = datah[:, 0]
    herrb = datah[:, 1]
    plt.plot(r_herrb, herrb)

    bsz=np.loadtxt('bsz_virgo_3D_h.txt')
    rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
    r500=1087
    rbsz=[rlogbin_cen[i]/r500 for i in range(len(rlogbin_cen))]
    bsz=1-bsz
    plt.plot(rbsz,bsz)
    plt.xlim(0.2,2)
    plt.ylim(-0.7,0.4)
    plt.show()

def los_distrib(file):

    plot=1
    if plot==1:
        mass_MW=np.load("./los_distrib/mass_distrib_MW.npy")
        mass_z = np.load("./los_distrib/mass_distrib_z.npy")
        mass_fil = np.load("./los_distrib/mass_distrib_fil.npy")
        mass_filx = np.load("./los_distrib/mass_distrib_filx.npy")
        mass_fily = np.load("./los_distrib/mass_distrib_fily.npy")

        p_MW=np.load("./los_distrib/p_distrib_MW.npy")
        p_z = np.load("./los_distrib/p_distrib_z.npy")
        p_fil = np.load("./los_distrib/p_distrib_fil.npy")
        p_filx = np.load("./los_distrib/p_distrib_filx.npy")
        p_fily = np.load("./los_distrib/p_distrib_fily.npy")

        bins_MW = np.load("./los_distrib/bins_distrib_MW.npy")
        bins_z = np.load("./los_distrib/bins_distrib_z.npy")
        bins_fil = np.load("./los_distrib/bins_distrib_fil.npy")
        bins_filx = np.load("./los_distrib/bins_distrib_filx.npy")
        bins_fily = np.load("./los_distrib/bins_distrib_fily.npy")

        bins_MW+=2307.6298965778637
        bins_z += 2307.6298965778637
        bins_fil += 2307.6298965778637
        bins_filx += 2307.6298965778637
        bins_fily += 2307.6298965778637

        #print("mass_fil",mass_fil)
        #print("mass_filx",mass_filx)
        #print("mass_fily",mass_fily)
        #sys.exit()


        f,(a,b)=plt.subplots(2,1)


        #a.plot(bins_z, mass_z, label='z',ls='dashed',marker="o",ms=4,color='skyblue')
        a.plot(bins_fil[1:38], mass_fil[1:38], label='Fil',ls='dotted',marker="o",ms=4,color='blue')
        a.plot(bins_filx[2:38], mass_filx[2:38], label='Filx',ls='dashed',marker="o",ms=4,color='green')
        a.plot(bins_fily, mass_fily, label='Fily',ls='dashdot',marker="o",ms=4,color='dimgrey')
        a.plot(bins_MW[3:37], mass_MW[3:37], label='Cen', ls='solid', marker="o", ms=4,color='red')
        a.set_ylabel("lo$\mathrm{g_{10}}$($M[\mathrm{M}_{\odot}]$)")
        a.legend()
        a.set_yscale('log')
        a.axvline(x=2147, color='grey', ls='dashed')
        a.text(2147, 10**(13.2), "$R_{vir}$", rotation=90, size=16)
        a.axvline(x=-2147, color='grey', ls='dashed')
        a.text(-2147, 10 ** (13.2), "$R_{vir}$", rotation=90, size=16)
        a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
        a.set_xlim(-16000,16000)

        #b.plot(bins_z, p_z, label='z',ls='dashed',marker="o",ms=4,color='skyblue')
        b.plot(bins_fil[:38], p_fil[:38], label='fil',ls='dotted',marker="o",ms=4,color='blue')
        b.plot(bins_filx, p_filx, label='filx',ls='dashed',marker="o",ms=4,color='green')
        b.plot(bins_fily, p_fily, label='fily',ls='dashdot',marker="o",ms=4,color='dimgrey')
        b.plot(bins_MW, p_MW, label='Cen', ls='solid', marker="o", ms=4, color='red')
        b.set_ylabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$])")
        b.set_xlabel("Distance to the center of the cluster (in kpc)")
        b.axvline(x=2147, color='grey', ls='dashed')
        b.text(2147, 10 ** (-3), "$R_{vir}$", rotation=90, size=16)
        b.axvline(x=-2147, color='grey', ls='dashed')
        b.text(-2147, 10 ** (-3), "$R_{vir}$", rotation=90, size=16)
        #b.legend()
        b.set_yscale('log')
        b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
        b.set_xlim(-16000, 16000)

        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()
        sys.exit()

    h = FortranFile(file, 'r')
    ncell = h.read_ints()
    n_e = h.read_reals()
    t = h.read_reals()
    p = h.read_reals()

    p /= 10
    p /= 1.602 * 10 ** (-10)
    p *= (0.76 / 0.864)

    x = h.read_reals()
    y = h.read_reals()
    z = h.read_reals()

    vx = h.read_reals()
    vy = h.read_reals()
    vz = h.read_reals()
    m = h.read_reals()

    print("min z",np.amin(z))
    print("max z",np.amax(z))
    #sys.exit()

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

    print("zcen",z_cen)
    #sys.exit()

    r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2)# + (z - z_cen) ** 2)

    bins=np.linspace(np.amin(z),np.amax(z),41)
    print("bins",bins)
    bins_cen=np.array([bins[i]+0.5*(bins[i+1]-bins[i]) for i in range(40)])
    print("bins_cen",bins_cen)
    #sys.exit()
    mass_dist=np.zeros(40)
    p_dist=np.zeros(40)

    for i in range(40):
        print("i",i)
        #cond=np.logical_and(z>bins[i],np.logical_and(z<bins[i+1],r<1000))
        cond = np.logical_and(z > bins[i], np.logical_and(z < bins[i + 1], r < 2147))
        mass_dist[i]=np.sum(m[cond])
        p_dist[i]=np.mean(p[cond])

    mtot=np.sum(mass_dist)
    print("mtot",mtot)

    r3d = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)
    mvir=np.sum(m[r3d<2147])

    print("mvir",mvir)

    menv=mtot-mvir

    print("menv",menv)


    #plt.plot(bins_cen,mass_dist)
    #np.save("./los_distrib/mass_distrib_fil.npy", mass_dist)
    #np.save("./los_distrib/p_distrib_fil.npy",p_dist)
    #np.save("./los_distrib/bins_distrib_fil.npy",bins_cen)
    #print("distributions saved")
    #plt.show()
    sys.exit()


def gian_bias_overplot():
    kay12=[0.78,0.73,0.83]
    battaglia13=[0.83,0.73,0.93]
    biffi16=[0.905,0.89,0.92]
    mccarthy16=[0.86,0.8,0.92]
    martizzi16=[0.87,0.82,0.92]
    lebrun17=[0.77,0.72,0.82]
    gupta17=[0.81,0.66,0.90]
    henson17=[0.92,0.87,0.97]
    pearce20=[0.86,0.81,0.91]
    ansarifard20=[0.91,0.82,0.99]
    barnes20=[0.89,0.88,0.9]
    gianfagna21=[0.86,0.76,0.99]

    mean_sims=np.array([0.78,0.83,0.905,0.86,0.87,0.77,0.81,0.92,0.86,0.91,0.89,0.86])
    mean_all_sims=np.mean(mean_sims)
    std_all_sims=np.std(mean_sims)

    print("mean all sims",mean_all_sims)
    print("std all sims",std_all_sims)
    #sys.exit()

    x=np.array([i for i in range(12)])

    plt.errorbar(0,kay12[0],yerr=0.05,c='black')
    plt.scatter(1,battaglia13[0],c='black')
    plt.errorbar(1,battaglia13[0],yerr=0.1,c='black')
    plt.scatter(2,biffi16[0],c='black')
    plt.errorbar(2,biffi16[0],yerr=0.015,c='black')
    plt.scatter(3,mccarthy16[0],c='black')
    plt.errorbar(3,mccarthy16[0],yerr=0.06,c='black')
    plt.errorbar(4,martizzi16[0],yerr=0.05,c='black')
    plt.errorbar(5,lebrun17[0],yerr=0.05,c='black')
    plt.scatter(6,gupta17[0],c='black')
    plt.errorbar(6,0.78,yerr=0.12,c='black')
    plt.errorbar(7,henson17[0],yerr=0.05,c='black')
    plt.errorbar(8,pearce20[0],yerr=0.05,c='black')
    plt.scatter(9,ansarifard20[0],c='black')
    plt.errorbar(9,0.905,yerr=0.085,c='black')
    plt.scatter(10,barnes20[0],c='black')
    plt.errorbar(10,barnes20[0],yerr=0.01,c='black')
    plt.scatter(11,gianfagna21[0],c='black')
    plt.errorbar(11,0.875,yerr=0.115,c='black')

    thisworkr500=[1.68,1.84,2.370,3.255,3.968]
    #thisworkrvir=[1.019,0.888,0.93,1.23,1.57]

    thisworkr500fit=[1.63,2.28,2.332,2.629,3.639]
    #thisworkrvirfit=[1.114,0.89,0.985,1.47,2.14]

    plt.scatter(12,thisworkr500[0],c='orange',marker='s',label='3D',s=60)
    plt.scatter(12, thisworkr500[1],c='red',marker='s',label='Cen',s=60)
    plt.scatter(12, thisworkr500[2],c='blue',marker='s',label='Fil')
    plt.scatter(12, thisworkr500[3],c='green',marker='s',label='Filx')
    plt.scatter(12, thisworkr500[4],c='dimgrey',marker='s',label='Fily')
    plt.scatter(13,thisworkr500fit[0],c='orange',marker='D',label='3D, fit',s=60)
    plt.scatter(13, thisworkr500fit[1],c='red',marker='D',label='Cen, fit',s=60)
    plt.scatter(13, thisworkr500fit[2],c='blue',marker='D',label='Fil, fit')
    plt.scatter(13, thisworkr500fit[3],c='green',marker='D',label='Filx, fit')
    plt.scatter(13, thisworkr500fit[4],c='dimgrey',marker='D',label='Fily, fit')

    #plt.scatter(13, thisworkrvir[0], label='3D',c='orange',marker='+')
    #plt.scatter(13, thisworkrvir[1], label='Cen',c='forestgreen',marker='+')
    #plt.scatter(13, thisworkrvir[2], label='Fil',c='skyblue',marker='+')
    #plt.scatter(13, thisworkrvir[3], label='Filx',c='red',marker='+')
    #plt.scatter(13, thisworkrvir[4], label='Fily',c='purple',marker='+')
    #plt.scatter(13, thisworkrvirfit[0], label='3D fit', c='orange',marker='x')
    #plt.scatter(13, thisworkrvirfit[1], label='Cen fit', c='forestgreen',marker='x')
    #plt.scatter(13, thisworkrvirfit[2], label='Fil fit', c='skyblue',marker='x')
    #plt.scatter(13, thisworkrvirfit[3], label='Filx fit', c='red',marker='x')
    #plt.scatter(13, thisworkrvirfit[4], label='Fily fit', c='purple',marker='x')

    #axes = plt.gca()
    #axes.xaxis.set_ticks(range(14))

    plt.xticks(np.arange(0,14,1), ['Kay (2012)', 'Battaglia (2013)', 'Biffi (2016)','McCarthy (2016)','Martizzi (2016)','Le Brun (2017)','Gupta (2017)','Henson (2017)','Pearce (2020)','Ansarifard (2020)','Barnes (2020)','Gianfagna (2021)','Lebeau (2024), no fit','Lebeau (2024), fit'], rotation=80)  # Set text labels.

    un=np.array([1 for i in range(16)])
    planck=np.array([0.58 for i in range(16)])
    x=np.arange(-1,15,1)
    plt.plot(x,un,ls='dashed',color='grey')
    plt.plot(x,planck,ls='dashed',color='blue')
    planckl=planck-0.04
    planckh=planck+0.04
    plt.fill_between(x,planckl,planckh,color='lightblue',alpha=0.8)
    plt.xlim(-1,14)
    plt.ylabel("(1-b)")

    plt.legend(ncol=2)


    plt.show()
    sys.exit()

def intmass_bias_relation():

    mMW=[96403289847181.02,65952198105929.91] #total mass along the los, mass within the virial radius
    mfily=[79143384713901.45,65952179152461.164]
    mfilx=[84453590114594.7,65952177498901.086]
    mfil=[93518464153593.05,65952187481220.086]

    menv=np.zeros(4)
    menv[0]=mMW[0]-mMW[1]
    menv[1] = mfil[0] - mfil[1]
    menv[2] = mfilx[0] - mfilx[1]
    menv[3] = mfily[0] - mfily[1]

    rvir_bias=np.array([0.888,0.93,1.23,1.57])
    rvir_ne=np.array([-4.640888638337122,-4.6562768811586475,-4.670521918194915,-4.769833978415295])
    rvir_p=np.array([-4.304150293975828,-4.312503439003375,-4.179733344144367,-4.160287202238739])

    fig,ax=plt.subplots(1,3)
    ax[0].scatter(rvir_bias,menv,c=['forestgreen','skyblue','red','purple'])
    ax[0].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    ax[0].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    ax[0].set_ylabel('Foreground and background mass $[M_{\odot}]$')
    ax[0].set_xlabel('(1-b)')
    #axis = plt.gca()
    #axis.get_yaxis().set_visible(False)
    ax[1].scatter(rvir_ne,menv,c=['forestgreen','skyblue','red','purple'])
    ax[1].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    ax[1].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    ax[1].set_xlabel("lo$\mathrm{g_{10}}$($P$[keV.c$\mathrm{m^{-3}}$]) at $R_{vir}$")
    ax[1].set_yticklabels([])
    ax[2].scatter(rvir_p[0],menv[0],c='forestgreen',label="Virgo-center of the box axis")
    ax[2].scatter(rvir_p[1], menv[1], c='skyblue', label="Main filament")
    ax[2].scatter(rvir_p[2], menv[2], c='red', label="Perpendicular (x axis rotation")
    ax[2].scatter(rvir_p[3], menv[3], c='purple', label="Perpendicular (y axis rotation")
    ax[2].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    ax[2].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    ax[2].set_xlabel("lo$\mathrm{g_{10}}$($n_{\mathrm{e}}$[c$\mathrm{m^{-3}}$]) at $R_{vir}$")
    ax[2].set_yticklabels([])
    ax[2].legend()
    fig.suptitle("Integrated mass influence on bias,pressure and electron density at the virial radius")
    plt.subplots_adjust(wspace=0, hspace=0)

    plt.show()



    sys.exit()

def beta_model(r,ngas0,rc,beta):
    return ngas0/(1+(r/rc)**2)**(1.5*beta)

def log_beta_model(r,ngas0,rc,beta):
    return np.log10(ngas0)-1.5*beta*np.log10(1+(r/rc)**2)

def alpha_model(r,a,b,c):
    return 1-a*(1+np.exp(-((r/1087)/b)**c))


#### Project 2 on Virgo : splashback radius ######

def offset_virgo():
    h=np.loadtxt("HighRes/list_halo_251.dat_js_nocontam_high_res")
    x_v = 0.48461068
    y_v = 0.50809848
    z_v = 0.49687076

    x_v = (x_v - 0.5) * (unit_l / 3.08567758128E21)
    y_v = (y_v - 0.5) * (unit_l / 3.08567758128E21)
    z_v = (z_v - 0.5) * (unit_l / 3.08567758128E21)

    #sys.exit()

    x=h[:,3]
    y=h[:,4]
    z=h[:,5]
    m=h[:,7]
    id=h[:,0]
    sub=h[:,1]

    x = (x - 0.5) * (unit_l / 3.08567758128E21)
    y = (y - 0.5) * (unit_l / 3.08567758128E21)
    z = (z - 0.5) * (unit_l / 3.08567758128E21)

    r=np.sqrt((x-x_v)**2+(y-y_v)**2+(z-z_v)**2)
    rvir=2147
    rzv=5031
    cond=np.logical_and(r<rvir,id!=753)

    print("len x",len(x))
    print("len x[cond]",len(x[cond]))
    print("m[cond]",m[cond])
    print("id[cond]",id[cond])
    #print("sub[cond]",sub[cond])

    x_com = np.sum(x[cond]*m[cond])/np.sum(m[cond])
    y_com = np.sum(y[cond]*m[cond])/np.sum(m[cond])
    z_com = np.sum(z[cond]*m[cond])/np.sum(m[cond])

    print("x com",x_com,"y com",y_com,"z com",z_com)
    print("x_v",x_v,"y_v",y_v,"z_v",z_v)

    offset=np.sqrt((x_com-x_v)**2+(y_com-y_v)**2+(z_com-z_v)**2)

    print("offset", offset)

    sys.exit()

def relaxedness():

    def substructure():
        rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
        mtot=np.loadtxt("radial_mtot_virgo.txt")
        mhydro=np.loadtxt("radial_mhydro_virgo.txt")
        mdm=np.loadtxt("radial_mdm_virgo.txt")
        halos=np.loadtxt("HighRes/list_halo_251.dat_js_nocontam_high_res")
        gals=np.loadtxt("HighRes/list_gal_251.dat_js_nocontam_high_res")

        mhalos=halos[:, 7]
        x_halos=halos[:, 3]
        y_halos = halos[:, 4]
        z_halos = halos[:, 5]
        rvirhalos=halos[:,6]


        mgal = gals[:, 2]
        x_gals = gals[:, 3]
        y_gals = gals[:, 4]
        z_gals = gals[:, 5]
        #rvirhalos = halos[:, 6]
        m_halo_gal = gals[:,19]

        x_virgo = 0.48461068
        y_virgo = 0.50809848
        z_virgo = 0.49687076

        x_virgo = (x_virgo - 0.5) * (unit_l / 3.08567758128E21)
        y_virgo = (y_virgo - 0.5) * (unit_l / 3.08567758128E21)
        z_virgo = (z_virgo - 0.5) * (unit_l / 3.08567758128E21)

        x_halos = (x_halos - 0.5) * (unit_l / 3.08567758128E21)
        y_halos = (y_halos - 0.5) * (unit_l / 3.08567758128E21)
        z_halos = (z_halos - 0.5) * (unit_l / 3.08567758128E21)

        r_halos = np.sqrt((x_halos-x_virgo)**2+(y_halos-y_virgo)**2+(z_halos-z_virgo)**2)

        x_gals = (x_gals - 0.5) * (unit_l / 3.08567758128E21)
        y_gals = (y_gals - 0.5) * (unit_l / 3.08567758128E21)
        z_gals = (z_gals - 0.5) * (unit_l / 3.08567758128E21)

        r_gals = np.sqrt((x_gals - x_virgo) ** 2 + (y_gals - y_virgo) ** 2 + (z_gals - z_virgo) ** 2)

        #print(r_gals[1:10])
        #sys.exit()


        #print("rhalos",r_halos[1:10])

        print("rlogbincen",rlogbin_cen[39])
        #sys.exit()

        #plt.hist2d(np.log10(mhalos),r_halos,bins=10,range=[[8,14],[0,30000]])
        #plt.colorbar()
        #plt.show()
        #sys.exit()

        cond=np.logical_and(r_halos<rlogbin_cen[39],halos[:,0]!=753)
        msubdm_halos=np.sum(mhalos[cond])


        print('nbr tot mhalos in list',len(mhalos))
        print('nbr mhalos in rzv',len(mhalos[cond]))

        print("nbr tot gal in list", len(mgal))
        print("nbr gal in rzv",len(r_gals[r_gals<5309]))

        msubdm_gal=np.sum(mgal[r_gals<5309])
        #msubdm_gal = np.sum(m_halo_gal[r_gals < 2113])

        print("msub dm halos",msubdm_halos)
        print("msub dm gal",msubdm_gal)
        print("mdm",np.sum(mdm[0:39]))
        print("mgas",np.sum(mhydro[1:39]))
        print("mtot",mtot[39])
        print("fsub (dm only)",(msubdm_halos)/np.sum(mdm[1:39]))

        sys.exit()

        plt.plot(rlogbin_cen,mdm,label='dm')
        plt.plot(rlogbin_cen,mhydro,label='hydro')
        plt.plot(rlogbin_cen,mtot,label='tot')
        plt.legend()
        plt.show()

        sys.exit()




        print("msub",msubdm)

        print("hydro")
        h = FortranFile("/data/cluster/tlebeau/virgo/virgo_xyz_hydro_l21.dat", 'r')

        ncell = h.read_ints()

        n_e = h.read_reals()
        t = h.read_reals()
        p = h.read_reals()
        x = h.read_reals()
        y = h.read_reals()
        z = h.read_reals()
        vx = h.read_reals()
        vy = h.read_reals()
        vz = h.read_reals()
        m = h.read_reals()
        lvl = h.read_reals()

        r = np.sqrt((x - x_virgo) ** 2 + (y - y_virgo) ** 2 + (z - z_virgo) ** 2)


        #print('mhalos',mhalos[0])

        print("mtot",mtot[31])
        print("rlogbincen",rlogbin_cen[31])

        fsub=msubdm/mdm[31]

        print("fsub",fsub)

        return fsub

    #min=[-11333.597029470018,5965.924483248105,- 2306.2781628350303]
    #com=[- 11348.715637024923,5972.151245937696, - 2307.6298965778637]

    #offset=np.sqrt((com[0]-min[0])**2+(com[1]-min[1])**2+(com[2]-min[2])**2)

    #print("offset",offset)

    #sys.exit()

    d = FortranFile("virgo_xyz_dm_high_res.dat", 'r')

    print('fichier dm ouvert')

    ncell = d.read_ints()
    print("n dm cell", ncell)

    #x_min,y_min,z_min=ftp.f90_to_py.find_minimum_potential(ncell)

    #print("minimum potential:",x_min,y_min,z_min)


    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076
    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

    print("pos cen",x_cen,y_cen,z_cen)

    #sys.exit()

    x_com = -11653.577688278487
    y_com = 6274.5095544073174
    z_com = -2197.2118388121430

    print("pos com",x_com,y_com,z_com)

    x_min = -11333.73767517459
    y_min = 5964.07901937338
    z_min = -2305.151571664472



    #min recalculé en partant du nouveau com (1000 it, 100kpc box, obtient, à -105, dist de 7.6 kpc entre 2:
    x_min_2 = -11331.41853712389
    y_min_2 = 5959.040924353213
    z_min_2 = -2303.6152589129856

    dist = np.sqrt((x_min - x_min_2) ** 2 + (y_min - y_min_2) ** 2 + (z_min - z_min_2) ** 2)

    print("dist", dist)

    #sys.exit()




    #print("min pos",x_min,y_min,z_min)


    offset = np.sqrt((x_min - x_com)**2+(y_min-y_com)**2+(z_min-z_com)**2)

    print("offset from com",offset)

    delta_r=np.abs(offset)/5031

    print("delta_r",delta_r)

    #sys.exit()

    #T=0.0

    rlim=5031
    #rlim=2147
    limbox=5000

    #T = ftp.f90_to_py.kinetic_energy(ncell,0,rlim)

    #print("T",T)

    T= 1.4438629488841602E+057

    #n_sub_box=100

    #sub_box = np.zeros((27,4))

    #print(sub_box)

    #sys.exit()


    #U = ftp.f90_to_py.potential_energy(ncell,0,n_sub_box,limbox,rlim)

    #print("sub_boxes",sub_box)

    #sys.exit()

    #print(sub_boxes[:, 0][sub_boxes[:, 3] > 0])
    #print(sub_boxes[:, 1][sub_boxes[:, 3] > 0])
    #print(sub_boxes[:, 2][sub_boxes[:, 3] > 0])

    #sys.exit()

    #fig = plt.figure()
    #ax = plt.axes(projection='3d')
    #ax.scatter3D(sub_boxes[:, 0][sub_boxes[:, 3] > 0], sub_boxes[:, 1][sub_boxes[:, 3] > 0], sub_boxes[:, 2][sub_boxes[:, 3] > 0], s=2, c='black')
    #ax.scatter3D(Virgo[0], Virgo[1], Virgo[2], s=150, c='red')
    #ax.scatter3D(MW[0], MW[1], MW[2], s=80, c='blue')

    #ax.set_xlim(xl, xu)
    #ax.set_ylim(yl, yu)
    #ax.set_zlim(zl, zu)

    #plt.show()

    #print("U",U)

    #sys.exit()

    #eta=(2*T)/np.abs(U)

    eta = 1.5383602004927706
    vir_equ = 0.5383602004927706

    print("eta",eta)

    #vir_equ=np.abs(eta-1)

    print("vir equ param (|eta-1|)", vir_equ)

    #sys.exit()

    f_sub=0.0392164

    print("f_sub",f_sub)

    #delta_r=0.0911591

    #print("delta_r",delta_r)

    chi_ds=np.sqrt(3/((delta_r/0.07)**2+(f_sub/0.1)**2+(vir_equ/0.15)**2))

    print("chi_ds",chi_ds)

    sys.exit()

    fsub=substructure()

def ellipticity():
    #x,y,z,r=dm("virgo_xyz_dm_high_res.dat")

    #diff_eval_list=np.array([0.31777235178745245, 1.434403858899405, 0.491930708095702, 0.3546105151546014, 0.3780877419548838, 0.6964458733228085, 0.6991998297414608, 0.44418301832059914, 0.21884305133306517, 0.26904592399213184, 0.1718530797792341, 0.18234448877879947, 0.784248124787916, 0.7806889911879787, 0.6396385095435444, 0.2578728701721484, 0.16840773751160537, 0.5527721279036398, 0.13863143594610586, 0.0747332115852549, 0.03755466240115134, 0.04295258897923681, 0.08790624784203552, 0.2282841195340218, 0.13518309672964576, 0.03319683949713034, 0.06800935295313194, 0.06168031331503401, 0.3930799130896694, 0.7224733309140753, 0.43770267500152676, 0.18781840161733163, 0.3479128603728534, 0.5032939415340697, 2.9362865048553033, 0.6328203727005259, 0.23045430628064822, 0.07101710501566752, 0.30917483648912975, 0.1282986335253933, 0.3282838920105202, 0.13303813914104637, 0.444636683156177, ])

    #plt.plot(diff_eval_list)
    #plt.show()
    #sys.exit()


    d = FortranFile("virgo_xyz_dm_low_res.dat", 'r')

    #print('fichier dm ouvert')

    ncell = d.read_ints()
    #x = d.read_reals()
    #y = d.read_reals()
    #z = d.read_reals()

    #print("fichier lu")

    #print("n dm cell", ncell)

    x,y,z,m,vx,vy,vz = ftp.f90_to_py.read_dm(ncell)

    #print('x[0]',x[0])

    def read_hydro():
        file = "/data/cluster/tlebeau/virgo/virgo_xyz_hydro_l19_low_gal_clean_m1e9.dat"
        h = FortranFile(file, 'r')
        ncell = h.read_ints()
        n_e = h.read_reals()
        t = h.read_reals()
        p = h.read_reals()
        xh = h.read_reals()
        yh = h.read_reals()
        zh = h.read_reals()

        return xh,yh,zh

    xh,yh,zh = read_hydro()

    pos_mat_hydro = np.array([xh, yh, zh])



    Virgo = np.array([0.48461068, 0.50809848, 0.49687076])

    #x = x * (3.08567758128E21 / unit_l) + 0.5
    #y = y * (3.08567758128E21 / unit_l) + 0.5
    #z = z * (3.08567758128E21 / unit_l) + 0.5

    Virgo = (Virgo - 0.5)/(3.08567758128E21 / unit_l)

    print("Virgo",Virgo)

    #sys.exit()

    x[0] = Virgo[0]
    y[0] = Virgo[1]
    z[0] = Virgo[2]

    print("x[0]",x[0])

    print("data loaded from F90 fct")

    #print("x",x)

    #sys.exit()



    #mass_tensor = np.asfortranarray(np.zeros((3,3)))
    mass_tensor = np.zeros((3,3))
    #mass_tensor = np.array(mass_tensor, dtype='f8', order='F')

    #print(mass_tensor.iscontiguous())

    #print("mass tensor before function", mass_tensor)
    r200=2147
    rvir=2024
    #r200=2238
    r500=1087

    rlim=rvir

    d=np.sqrt(x**2+y**2+z**2)
    dlog=np.log10(d)

    #m_cumul_dm=np.zeros(21)

    #for i in range(21):
        #cond = np.logical_and(dlog > (i + 35) * 0.05, dlog < (i + 36) * 0.05)
        #rlim=10 ** ((18 + i) * 0.1)
        #print(i,'rlim ',rlim)
        #rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(21)])
        #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
        #m_cumul_dm[i]=np.sum(m[d<rlim])

    #print("msumdm",m_cumul_dm)
    #np.save("m_cumul_dm_21.npy",m_cumul_dm)
    #sys.exit()


    #plt.hist(m[d<r200],range=[2.2e7,2.6e7])
    #plt.show()

    #print("m",m)
    #sys.exit()


    a=1
    b=1
    c=1

    a*=rlim
    b*=rlim
    c*=rlim

    ell=(x/a)**2+(y/b)**2+(z/c)**2

    print("ell",ell)
    print("len(ell)",len(ell))

    #print(len(m[ell<1]))
    #print(len(x[ell < 1]))
    #print(len(m))
    #sys.exit()
    #npart=len(m[ell<1])
    #m500=npart*2.4285e7

    #print("m200",m500)
    mrlim=np.sum(m[ell<1])
    print("mass from dm parts with ellipse equ",np.sum(m[ell<1]))
    #print("m200 from dm parts with sphere equ", np.sum(m[d < r200]))
    #sys.exit()


    #315711797086777.1
    #2516023067145000.0
    #2516080049343350.0
    #2516080049343350.0
    #315711797086777.1

    #572414473885160.6
    #625263282155120.1

    #print("counter",len(x[ell<1]))

    #sys.exit()

    mass_tensor[0, 0] = np.sum(x[ell < 1] * x[ell < 1])
    mass_tensor[0, 1] = np.sum(x[ell < 1] * y[ell < 1])
    mass_tensor[0, 2] = np.sum(x[ell < 1] * z[ell < 1])
    mass_tensor[1, 2] = np.sum(y[ell < 1] * z[ell < 1])
    mass_tensor[1, 1] = np.sum(y[ell < 1] * y[ell < 1])
    mass_tensor[2, 2] = np.sum(z[ell < 1] * z[ell < 1])

    mass_tensor[1,0]=mass_tensor[0,1]
    mass_tensor[2,0]=mass_tensor[0,2]
    mass_tensor[2,1]=mass_tensor[1,2]


    #mass_tensor = ftp.f90_to_py.dm_mass_tensor(ncell)

    print("mass_tensor",mass_tensor)
    #print("atest",atest)

    #sys.exit()

    #print("mass tensor estimation")

    #mass_tensor[0,0] = np.sum(x[r<rlim]*x[r<rlim])
    #mass_tensor[1,0] = mass_tensor[0,1]
    #mass_tensor[0,2] = np.sum(x[r<rlim]*z[r<rlim])
    #mass_tensor[2, 0] = mass_tensor[0, 2]
    #mass_tensor[1,2] = np.sum(y[r<rlim]*z[r<rlim])
    #mass_tensor[2, 1] = mass_tensor[1, 2]
    #mass_tensor[1,1] = np.sum(y[r<rlim]*y[r<rlim])
    #mass_tensor[2,2] = np.sum(z[r<rlim]*z[r<rlim])

    #mass_tensor=[[19191486323786680,-10194655567328394,3839036541015190.0],[-10194655567328394,19191486345386736,19191486313189372],[3839036541015190,19191486313189372,19191486328985876]]

    #print("mass tensor",mass_tensor)

    #sys.exit()

    eval,evect=np.linalg.eig(mass_tensor)

    print("eigenvalues",eval)

    print("eigenvector",evect)

    p_mat=evect.T

    p_mat_inv=np.linalg.inv(p_mat)

    pos_mat=np.array([x,y,z])
    #print("pos_mat[:,0]",pos_mat[:,0])
    #sys.exit()

    print("p_mat",p_mat)
    print("p_mat_inv",p_mat_inv)
    print("test p_mat",np.dot(p_mat,p_mat_inv))
    print("pos_mat",pos_mat)

    interm=np.dot(pos_mat.T,p_mat)
    pos_mat_new=np.dot(p_mat_inv,interm.T)

    interm_hydro = np.dot(pos_mat_hydro.T, p_mat)
    pos_mat_hydro_new = np.dot(p_mat_inv, interm_hydro.T)

    print("matrix pos in new coord",pos_mat_new)

    diff_eval_1 = 1
    diff_eval_2 = 1
    diff_eval_3 = 1

    j=0

    while((np.abs(diff_eval_1)>0.01 or np.abs(diff_eval_2)>0.01 or np.abs(diff_eval_3)>0.01) and j<50):
        #print("j",j)
        j += 1

        eval_old=eval

        a = eval[0]/eval[0]
        b = eval[1]/eval[0]
        c = eval[2]/eval[0]

        #fact = 5e2 #works for high res ?
        fact = 1e4 #test for low res

        a *= fact
        b *= fact
        c *= fact

        #print("a,b,c,",a,b,c)

        diff=1
        i=0
        red_test = 0
        delta_factor = 2e2


        while(np.abs(diff)>0.01 and i<100):
            #print("i",i)
            i += 1
            m_tot = 0
            ell = (pos_mat_new[0,:] / a) ** 2 + (pos_mat_new[1,:] / b) ** 2 + (pos_mat_new[2,:] / c) ** 2
            #print("ell",ell)
            #print("len(ell)",len(ell))
            ell=np.array(ell)
            m_tot = np.sum(m[ell<1])
            diff=(mrlim-m_tot)/mrlim
            #print("m_tot",m_tot)
            #print('i',i,"diff", diff,"mtot","{:.2e}".format(m_tot),"mrlim","{:.2e}".format(mrlim))
            #sys.exit()
             #10 works for high res ?

            if (np.abs(diff)<0.05 and red_test == 0 ) :
                delta_factor /= 2
                #print("delta factor division: delta_factor=",delta_factor)
                #print('i',i,"diff", diff,"mtot","{:.2e}".format(m_tot),"mrlim","{:.2e}".format(mrlim))
                red_test = 1
            if (np.abs(diff)<0.04 and red_test == 1 ) :
                delta_factor /= 2
                #print("delta factor division: delta_factor=",delta_factor)
                #print('i',i,"diff", diff,"mtot","{:.2e}".format(m_tot),"mrlim","{:.2e}".format(mrlim))
                red_test = 2
            if (np.abs(diff)<0.03 and red_test == 2 ) :
                delta_factor /= 2
                #print("delta factor division: delta_factor=",delta_factor)
                #print('i',i,"diff", diff,"mtot","{:.2e}".format(m_tot),"mrlim","{:.2e}".format(mrlim))
                red_test = 3
            if (np.abs(diff)<0.02 and red_test == 3 ) :
                delta_factor /= 2
                #print("delta factor division: delta_factor=",delta_factor)
                #print('i',i,"diff", diff,"mtot","{:.2e}".format(m_tot),"mrlim","{:.2e}".format(mrlim))
                red_test = 4

            if diff<0 :
                fact -=delta_factor
            else :
                fact +=delta_factor


            #print("fact",fact)

            a = ( eval[0] / eval[0] ) * fact
            b = ( eval[1] / eval[0] ) * fact
            c = ( eval[2] / eval[0] ) * fact

            #print("a,b,c",a,b,c)

        #print("i", i)
        print('i', i, "diff", diff, "mtot", "{:.2e}".format(m_tot), "mrlim", "{:.2e}".format(mrlim),"fact",fact,"coeffs",a,b,c)
        print("Virgo pos", pos_mat_new[:, 0])

        mass_tensor = np.zeros((3, 3))

        x = pos_mat_new[0,:]
        y = pos_mat_new[1,:]
        z = pos_mat_new[2,:]

        mass_tensor[0, 0] = np.sum(x[ell < 1] * x[ell < 1])
        mass_tensor[0, 1] = np.sum(x[ell < 1] * y[ell < 1])
        mass_tensor[0, 2] = np.sum(x[ell < 1] * z[ell < 1])
        mass_tensor[1, 2] = np.sum(y[ell < 1] * z[ell < 1])
        mass_tensor[1, 1] = np.sum(y[ell < 1] * y[ell < 1])
        mass_tensor[2, 2] = np.sum(z[ell < 1] * z[ell < 1])

        mass_tensor[1, 0] = mass_tensor[0, 1]
        mass_tensor[2, 0] = mass_tensor[0, 2]
        mass_tensor[2, 1] = mass_tensor[1, 2]

        eval, evect = np.linalg.eig(mass_tensor)


        #print("eval",eval)

        #sys.exit()

        eval = np.sqrt(eval)

        diff_eval = np.sqrt(((eval_old[0]-eval[0])/eval_old[0])**2 + ((eval_old[1]-eval[1])/eval_old[1])**2 + ((eval_old[2]-eval[2])/eval_old[2])**2 )

        diff_eval_1 =(eval_old[0] - eval[0]) / eval_old[0]
        diff_eval_2 = (eval_old[1] - eval[1]) / eval_old[1]
        diff_eval_3 = (eval_old[2] - eval[2]) / eval_old[2]

        print("j",j,"diff eval : tot",diff_eval,"eval_1", diff_eval_1,"eval_2", diff_eval_2,"eval_3", diff_eval_3)


        if (np.abs(diff_eval_1) > 0.01 or np.abs(diff_eval_2) > 0.01 or np.abs(diff_eval_3) > 0.01):
            p_mat = evect.T

            p_mat_inv = np.linalg.inv(p_mat)

            pos_mat = np.array([x, y, z])

            interm = np.dot(pos_mat.T, p_mat)
            pos_mat_new = np.dot(p_mat_inv, interm.T)

            interm_hydro = np.dot(pos_mat_hydro.T, p_mat)
            pos_mat_hydro_new = np.dot(p_mat_inv, interm_hydro.T)

            print("rotation")

            # print('eval',eval)



        #print()
        #print()
        #print()

    if (j<50):
        print('convergence reached, old eigen values:', eval_old)
        print('convergence reached, eigen values:', eval)
        print('pos_mat_new',pos_mat_new)
        np.save("dm_pos_low_ellip.npy",pos_mat_new)
        np.save("hydro_pos_low_ellip.npy", pos_mat_hydro_new)
        print("Virgo pos", pos_mat_new[:,0])
        pos_mat_new[:,0] = pos_mat_new[:,0] * (3.08567758128E21 / unit_l) + 0.5
        print("Virgo pos", pos_mat_new[:, 0])

    else :
        print('iteration limit reached')

    #sys.exit()



    tau=np.sum(eval)

    epsilon=(np.max(eval)-np.min(eval))/(2*tau)

    print("epsilon",epsilon)

    sys.exit()


def velocity_structure_function(file):
    h = FortranFile(file, 'r')
    map = []
    map = h.read_reals()
    px = int(np.sqrt(len(map)))
    print("len",px)
    map = np.reshape(map, (px, px))

    map_test = map[5730:9996 , 5730:9996]
    mini_map_test = map[7827:7899 , 7827:7899]

    def plot_map_test():
        def show_radii():
            dim = 11.0615
            xpx = np.linspace(-dim, dim, 4000)
            ypx = np.linspace(-dim, dim, 4000)

            Xpx, Ypx = np.meshgrid(xpx, ypx)

            # F = (Xpx-gal_pos[i,0])**2 + (Ypx-gal_pos[i,1])**2 - (r200dm[i]*(10/1e4))**2
            # F = (Xpx - x[i]) ** 2 + (Ypx - y[i]) ** 2 - (r200dm[i] * (10 / 1e4)) ** 2

            F = Xpx ** 2 + Ypx ** 2 - (2024 * (10 / 1e4)) ** 2  # rvir
            rvir = plt.contour(Xpx, Ypx, F, [0], colors='black', linewidths=2, alpha=0.9)
            plt.clabel(rvir, rvir.levels, inline=True, fmt="$R_{vir}$", fontsize=20)

            F = Xpx ** 2 + Ypx ** 2 - (5031 * (10 / 1e4)) ** 2  # rzv
            rzv = plt.contour(Xpx, Ypx, F, [0], colors='black', ls='dashed', linewidths=2, alpha=0.9)
            plt.clabel(rzv, rzv.levels, inline=True, fmt="$R_{zv}$", fontsize=20)

        fig, ax = plt.subplots()
        dim = 11.0615
        #dim = 3
        dim = [-dim, dim, -dim, dim]
        im = ax.imshow(map, cmap="seismic", origin='lower', alpha=1,vmin=-350,vmax=350, extent=dim)  # , vmin=-800, vmax=800)
        #show_radii()
        cb = fig.colorbar(im, ax=ax)
        ax.set_xlabel("x [Mpc]")
        ax.set_ylabel("y [Mpc]")
        titre="Velocity map along the Cen los"
        plt.title(titre)
        show_radii()

        cb.set_label('km/s', size='large')

        plt.show()

        sys.exit()


    def compute_vsf(map):
        r_log_bin = np.array([10 ** ((20 + i) * 0.05) for i in range(40)])
        delta_v=np.zeros()

        pos_x = 0
        pos_y = 0

        d = np.array([[np.log10(np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 1.40655) for i in range(max_x)] for j in range(max_y)])


    plot_map_test()

def hydro_ellipsoid(file, t_cut, mean_med):
    print('hydro')
    print(file)
    h = FortranFile(file, 'r')

    ncell = h.read_ints()
    #nline = h.read_ints()
    nline=[1,1]
    nline=int(nline[0])
    print("ncell", ncell)
    print("nline",nline)
    #ncell=np.fromfile(file,dtype=np.int)
    #print("ncell",ncell)
    #n_e=np.fromfile(file,dtype=np.float64)
    #print("ne",n_e)
    #sys.exit()
    n_e = []
    #print("ne",n_e)

    for i in range(0,nline):
        n_e_line=h.read_reals()
        n_e=np.concatenate((n_e,n_e_line))
        print("len ne",len(n_e))

    #plt.hist(n_e, bins=100)
    #plt.xscale('log')
    #plt.yscale('log')
    #plt.show()
    #sys.exit()

    print("t")
    t = []
    for i in range(0, nline):
        t_line = h.read_reals()
        t = np.concatenate((t, t_line))

    #plt.hist(t,bins=100)
    #plt.xscale('log')
    #plt.yscale('log')
    #plt.show()
    #sys.exit()

    print("p")
    p = []
    for i in range(0, nline):
        p_line = h.read_reals()
        p = np.concatenate((p, p_line))

    #plt.hist(p, bins=100)
    #plt.xscale('log')
    #plt.yscale('log')
    #plt.show()
    #sys.exit()

    print("x")
    x = []
    for i in range(0, nline):
        x_line = h.read_reals()
        x = np.concatenate((x, x_line))

    #print("x len",len(x))
    #print("xmin",np.min(x))
    #print("xmax",np.max(x))
    #plt.hist(x)
    #plt.show()
    #sys.exit()

    print('y')
    y = []
    for i in range(0, nline):
        y_line = h.read_reals()
        y = np.concatenate((y, y_line))

    print("ymin", np.min(y))
    print("ymax", np.max(y))

    #ys.exit()

    print("z")
    z = []
    for i in range(0, nline):
        z_line = h.read_reals()
        z = np.concatenate((z, z_line))

    print("zmin", np.min(z))
    print("zmax", np.max(z))

    #sys.exit()

    print("vx")
    vx = []
    for i in range(0, nline):
        vx_line = h.read_reals()
        vx = np.concatenate((vx, vx_line))

    print("vy")
    vy = []
    for i in range(0, nline):
        vy_line = h.read_reals()
        vy = np.concatenate((vy, vy_line))

    print("vz")
    vz = []
    for i in range(0, nline):
        vz_line = h.read_reals()
        vz = np.concatenate((vz, vz_line))

    print("m")
    m = []
    for i in range(0, nline):
        m_line = h.read_reals()
        m = np.concatenate((m, m_line))

    print("lvl")
    lvl = []
    for i in range(0, nline):
        lvl_line = h.read_reals()
        lvl = np.concatenate((lvl, lvl_line))

    m_cumul_ba = np.zeros(21)

    #loading positions of low res data after rotations:

    pos = np.load("hydro_pos_low_ellip.npy")
    # print(np.shape(pos))
    # print(pos)
    x = pos[0, :]
    y = pos[1, :]
    z = pos[2, :]
    print("x", x,'len',len(x))
    #plt.hist(z,bins=100)
    #plt.show()
    #sys.exit()

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)


    #x_cen = -11813.83189592
    #y_cen = - 2978.21061948
    #z_cen = - 4620.46862286

    #Test values from histograms of positions

    x_cen = -11016
    y_cen = 6100
    z_cen = -3200


    #print("x_cen",x_cen)
    #sys.exit()

    r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)
    #r = np.sqrt(x ** 2 + y** 2 + z** 2) #the data are not centered on virgo position like above but on [0,0,0] ??


    for i in range(0, 21):
        #print(i)

        # cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
        # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
        #cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))
        #m_sum_log = m[cond]
        rlim = 10 ** ((18 + i) * 0.1)
        #print(i, 'rlim ', rlim)
        # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
        m_cumul_ba[i] = np.sum(m[r < rlim])

    #print("msumbar", m_cumul_ba)
    #np.save("m_cumul_ba_21.npy", m_cumul_ba)

    #sys.exit()

    @jit(nopython=True)
    def change_units(x, y, z, p, n_e, t, m,vx,vy,vz,lvl):
        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        #x_cen = -11813.83189592
        #y_cen = - 2978.21061948
        #z_cen = - 4620.46862286

        x_cen = -11016
        y_cen = 6100
        z_cen = -3200

        r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)
        #r = np.sqrt(x** 2 + y** 2 + z** 2)

        # r=np.array(r)

        # n_e *= 1E6 / 0.864
        n_e /= 0.864
        # plt.hist(np.log10(n_e),bins=100,range=[-3,7])
        # plt.show()
        # sys.exit()
        p /= 10
        p /= 1.602 * 10 ** (-10)
        p *= (0.76 / 0.864)
        # print("P",p)
        print("nb part", len(n_e))

        # m_no_cut = m
        # r_no_cut = r

        if t_cut == 1:
            lim = 0
            cond = np.logical_and(t > 1E5, n_e > 0)
            n_e2 = n_e[cond]
            p = p[cond]
            r = r[cond]
            m = m[cond]
            t = t[cond]
            x = x[cond]
            vx = vx[cond]
            vy = vy[cond]
            vz = vz[cond]
            lvl=lvl[cond]
            n_e = n_e2

        if t_cut == 2:
            cond = np.logical_and(t > 1E7, n_e > 0)
            n_e2 = n_e[cond]
            p = p[cond]
            r = r[cond]
            m = m[cond]
            t = t[cond]
            n_e = n_e2

        print("nb part after cut", len(n_e))

        t *= kb / 1.602e-16

        K=t/n_e**(2/3)

        rho=n_e*me*1e3

        vx*=1e6
        vy*=1e6
        vz*=1e6 #comprendre pk j'avais mis *1e6 et pk ça a l'air de marcher (plutôt que *1e5 qui permettrait de passer de km/s à cm/s)

        rlog = np.log10(r)
        plog = np.log10(p)
        tlog = np.log10(t)
        ne_log = np.log10(n_e)
        klog = np.log10(K)

        return x, y, z, plog, ne_log, tlog, m, rlog, klog, rho,vx,vy,vz,lvl

    # start=time.time()
    x, y, z, plog, ne_log, tlog, m, rlog, klog, rho,vx,vy,vz,lvl = change_units(x, y, z, p, n_e, t, m,vx,vy,vz,lvl)

    #r=10**rlog
    #plt.hist2d(r,lvl,bins=[20,6],range=[[0,300],[16,21]])
    #plt.hist(lvl[r<100])

    #plt.colorbar()
    #plt.show()

    #sys.exit()

    # print("r",rlog)

    # end=time.time()
    # print("time change units",end-start)
    # sys.exit()

    # print("p",p[0:10])
    # ptest=n_e*t
    # print("n_e*T",ptest[0:10])
    # ratio=p/ptest
    # print("ratio", ratio[0:10])

    # sys.exit()

    # plt.hist2d(r,lvl,bins=[2000,8])
    # plt.colorbar()
    # plt.xscale('log')
    # plt.show()

    # print(len(rlog))
    # print(lvl)
    # print(len(lvl))

    # print("exit")
    # sys.exit()

    # t_rad = np.zeros(400)
    # ne_rad = np.zeros(400)
    # ne_rad_std = np.zeros(400)
    # p_rad = np.zeros(400)
    # m_rad = np.zeros(400)
    # n_rad = np.zeros(400)

    def normal_scale():
        for i in range(400):
            print(i)
            cond = np.logical_and(r > i * 10, r < (i + 1) * 10)
            t_sum = t[cond]
            m_sum = m[cond]
            if np.sum(m_sum) > 0:
                t_rad[i] = np.sum(t_sum * m_sum) / np.sum(m_sum)
            else:
                t_rad[i] = np.nan
            ne_rad[i] = np.median(n_e[cond])
            p_rad[i] = np.median(p[cond])
            # m_rad[i]=np.sum(m_sum)
            m_rad[i] = np.sum(m_no_cut[np.logical_and(r_no_cut > i * 10, r_no_cut < (i + 1) * 10)])
            n_rad[i] = len(m_sum)
            # print(n_rad)
            # nb=int(n_rad[i]*0.5)
            # print("nb",nb)
            # med=np.zeros(100)
            # if(nb>1):
            #    for j in range(100):
            #        #print(j)
            #        med[j]=np.median(resample(n_e[cond],n_samples=nb))
            #
            #        ne_rad_std[i]=np.std(med)
            #    else:
            #        ne_rad_std[i]=0

    # normal_scale()

    # print("n_e[cond]",n_e[cond])
    # nbs=resample(n_e[cond],n_samples=10)
    # print("nbs",nbs)
    # print(ne_rad_std)

    # for i in range(5,395):
    #    T_smooth[i]=np.median(t_rad[i-5:i+5])
    #    ne_smooth[i]=np.mean(ne_rad[i-10:i+10])
    #    P_smooth[i]=np.mean(p_rad[i-10:i+10])

    # for i in range(-20,50):
    #    clog=np.logical_and(rlog>i*0.1,rlog<(i+1)*0.1)
    #    t_sum_log=tlog[~clog]
    #    m_sum_log=m[~clog]
    #    p_rad_log[i+20]=np.median(plog[~clog])
    #    t_rad_log[i+20]=np.sum(t_sum_log*m_sum_log)/np.sum(m_sum_log)
    #    ne_rad_log[i+20]=np.median(ne_log[~clog])
    # @jit(nopython=True)
    def log_scale():
        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076
        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        #x_cen = -11813.83189592
        #y_cen = - 2978.21061948
        #z_cen = - 4620.46862286

        x_cen = -11016
        y_cen = 6100
        z_cen = -3200

        n = 40
        p_rad_log = np.zeros(n)
        t_rad_log = np.zeros(n)
        ne_rad_log = np.zeros(n)
        n_log = np.zeros(n)
        m_rad_log = np.zeros(n)
        err_p = np.zeros(n)
        err_ne = np.zeros(n)
        err_t = np.zeros(n)

        p_turb = np.zeros(n)
        err_pturb = np.zeros(n)

        k_rad_log = np.zeros(n)
        err_k = np.zeros(n)

        print("med_mean=", mean_med)

        #m_cumul_ba=np.zeros(40)

        for i in range(0, n):
            print(i)

            #cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
            # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
            cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))
            m_sum_log = m[cond]
            #rlim = 10 ** ((35.5 + i) * 0.05)
            #print(i, 'rlim ', rlim)
            # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
            #m_cumul_ba[i] = np.sum(m[r < rlim])


            # print('test')
            if mean_med == 1:
                # print('test 1')
                p_sum_log = plog[cond]
                ne_sum_log = ne_log[cond]
                t_sum_log = tlog[cond]
                k_sum_log = klog[cond]


                # print('test 1.5')
                # print("msumlog",m_sum_log)
                # print("psumlog",p_sum_log)
                p_rad_log[i] = np.sum(p_sum_log * m_sum_log) / np.sum(m_sum_log)
                # print('test 2')
                ne_rad_log[i] = np.sum(ne_sum_log * m_sum_log) / np.sum(m_sum_log)
                # print('test 3')
                t_rad_log[i] = np.sum(t_sum_log * m_sum_log) / np.sum(m_sum_log)
                # print('test 4')
                err_ne[i] = np.sqrt(np.sum(m_sum_log * (ne_sum_log - ne_rad_log[i]) ** 2) / np.sum(m_sum_log))
                err_t[i] = np.sqrt(np.sum(m_sum_log * (t_sum_log - t_rad_log[i]) ** 2) / np.sum(m_sum_log))
                err_p[i] = np.sqrt(np.sum(m_sum_log * (p_sum_log - p_rad_log[i]) ** 2) / np.sum(m_sum_log))

                k_rad_log[i] = np.sum(k_sum_log * m_sum_log) / np.sum(m_sum_log)
                err_k[i] = np.sqrt(np.sum(m_sum_log * (k_sum_log - k_rad_log[i]) ** 2) / np.sum(m_sum_log))

                vxmean = np.mean(vx[cond])
                vymean = np.mean(vy[cond])
                vzmean = np.mean(vz[cond])
                sigmax = np.sum(m_sum_log * (vx[cond] - vxmean) ** 2) / np.sum(m_sum_log)
                sigmay = np.sum(m_sum_log * (vy[cond] - vymean) ** 2) / np.sum(m_sum_log)
                sigmaz = np.sum(m_sum_log * (vz[cond] - vzmean) ** 2) / np.sum(m_sum_log)
                sigmatot=sigmax+sigmay+sigmaz
                rhomean=np.sum(rho[cond] * m_sum_log) / np.sum(m_sum_log)

                p_turb[i]=rhomean*sigmatot



            elif (mean_med == 2):
                t_rad_log[i] = np.median(tlog[cond])
                p_rad_log[i] = np.median(plog[cond])
                ne_rad_log[i] = np.median(ne_log[cond])

                err_ne[i] = np.median(np.abs(ne_log[cond] - ne_rad_log[i]))
                err_p[i] = np.median(np.abs(plog[cond] - p_rad_log[i]))
                err_t[i] = np.median(np.abs(tlog[cond] - t_rad_log[i]))

            else:
                print('test 0')
                p_rad_log[i] = np.median(plog[cond])
                ne_rad_log[i] = np.median(ne_log[cond])

                t_sum_log = tlog[cond]
                t_rad_log[i] = np.sum(t_sum_log * m_sum_log) / np.sum(m_sum_log)

                err_ne[i] = np.median(np.abs(ne_log[cond] - ne_rad_log[i]))
                err_p[i] = np.median(np.abs(plog[cond] - p_rad_log[i]))
                err_t[i] = np.sqrt(np.sum(m_sum_log * (t_sum_log - t_rad_log[i]) ** 2) / np.sum(m_sum_log))
            n_log[i] = len(m_sum_log)
            m_rad_log[i] = np.sum(m_sum_log)
            print(len(m_sum_log))

        #print("msumbar", m_cumul_ba)
        #np.save("m_cumul_ba.npy", m_cumul_ba)

        #sys.exit()

        print("p_turb", p_turb)
        p_turb /= 10
        p_turb /= 1.602 * 10 ** (-10)
        p_turb = np.log10(p_turb)
        print("p_turb log", p_turb)
        #sys.exit()

        return p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_ne, err_p, err_t, err_k,p_turb

    def test():
        p_rad_log = np.array(
            [np.median(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
        ne_rad_log = np.array(
            [np.median(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
        n_log = np.array([len(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
        m_rad_log = np.array(
            [np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
        t_rad_log = np.array([np.sum(tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * m[
            np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) / np.sum(
            m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])

        mad_ne_log = np.array(
            [np.median(np.abs(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - ne_rad_log[i]))
             for i in range(40)])
        mad_plog = np.array(
            [np.median(np.abs(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - p_rad_log[i])) for
             i in range(40)])
        w_std_plog = np.array([np.sqrt(np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * (
                tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - t_rad_log[i]) ** 2) / np.sum(
            m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)])) for i in range(40)])

        return p_rad_log, t_rad_log, ne_rad_log, m_rad_log, n_log, mad_ne_log, mad_plog, w_std_plog

    # start=time.time()
    p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_nelog, err_plog, err_tlog, err_klog,p_turb = log_scale()

    rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

    ptot=10**p_rad_log+10**p_turb
    alpha=(10**p_turb)/ptot
    plt.scatter(rlogbin_cen, p_rad_log, s=6, c='blue')
    plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted', label='$2048^3$', alpha=0.7, c='blue')
    plt.xscale('log')
    plt.show()
    #np.save("alpha.npy",alpha)
    sys.exit()

    # end=time.time()
    # print("durée:",end-start)

    #rratio=rlogbin_cen/1087
    #krad=np.array([10**k_rad_log[i] for i in range(len(k_rad_log))])

    #rad_data = np.zeros((2, 40))
    #rad_data[0,:]=krad
    #rad_data[1,:]=krad*err_klog
    #np.save("K_prof_high",rad_data)

    #plt.plot(rratio,10**p_turb/(10**p_rad_log))
    #plt.scatter(rlogbin_cen, krad, s=6, c='green',label='Entropy')
    #plt.errorbar(rlogbin_cen, krad, yerr=krad*err_klog, ls='dotted', label='3D, 8192^3', alpha=0.7, c='orange')
    #plt.scatter(rlogbin_cen, p_rad_log, s=6, c='orange')
    #plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted',label='Rescaled data (lvl=15, low res)', alpha=0.7, c='orange')
    #plt.scatter(rlogbin_cen,np.log10(10**p_rad_log+10**p_turb),label='P_tot',s=6,c='blue')
    #plt.xscale('log')
    #plt.yscale('log')
    # plt.yscale('log')
    #plt.axvline(x=1087, color='grey')
    #plt.text(1087, 2.75, "$R_{500}$", rotation=90, size=16)
    #plt.axvline(x=2147, color='grey', ls='dashed')
    #plt.text(2147, 2.75, "$R_{vir}$", rotation=90, size=16)
    #plt.xlabel("R(kpc)", size=16)
    #plt.ylabel('$log_{10}(K[keV.cm^{2}])$')
    #plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
    #plt.legend(prop={'size': 16})
    #plt.show()

    #sys.exit()

    # return t_rad, ne_rad, p_rad, m_rad, n_rad, p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, ne_rad_std, mad_ne_log, mad_plog, w_std_plog
    return p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, err_nelog, err_plog, err_tlog,

def radial_gal_vel():
    gal=np.loadtxt("/data/cluster/byopic/SIMS/VirgoClone/HighRes/list_gal_251.dat_js_nocontam")

    cond = np.logical_and(gal[:, 3] > 0.46, np.logical_and(gal[:, 3] < 0.51, np.logical_and(gal[:, 4] > 0.48, np.logical_and(gal[:, 4] < 0.53, np.logical_and(gal[:, 5] > 0.47,gal[:,5] < 0.52)))))
    x_gal = gal[:, 3][cond]
    # print("xgal",x_gal)
    # sys.exit()
    y_gal = gal[:, 4][cond]
    z_gal = gal[:, 5][cond]

    x_gal = (x_gal - 0.5) * (unit_l / 3.08567758128E21)
    y_gal = (y_gal - 0.5) * (unit_l / 3.08567758128E21)
    z_gal = (z_gal - 0.5) * (unit_l / 3.08567758128E21)

    vx_gal = gal[:, 6][cond]
    vy_gal = gal[:, 7][cond]
    vz_gal = gal[:, 8][cond]

    vx_gal -= -509.1301
    vy_gal -= 228.9488
    vz_gal -= -131.9249

    #plt.hist(vx_gal,bins=100)
    #plt.show()
    #sys.exit()

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)


    r = np.sqrt((x_gal - x_cen) ** 2 + (y_gal - y_cen) ** 2 + (z_gal - z_cen) ** 2)

    # v_pec = np.sqrt(vx_gal**2 + vy_gal**2 + vz_gal**2)

    # H0 = cosmo.H(0).to_value('km/s/Mpc')

    H0 = 67.74

    # print(H0)

    # sys.exit()

    x_gal_0 = x_gal - x_cen
    y_gal_0 = y_gal - y_cen
    z_gal_0 = z_gal - z_cen

    #plt.hist(x_gal_0)
    #plt.show()
    #sys.exit()

    v_pec = (x_gal_0 * vx_gal + y_gal_0 * vy_gal + z_gal_0 * vz_gal)/r
    v_rad = v_pec + H0 * r * 1e-3

    #plt.hist(v_rad)
    #plt.show()

    #print(r)

    #sys.exit()

    rlog = np.log10(r)

    n = 80

    v_rad_mean = np.zeros(n)
    v_rad_std = np.zeros(n)

    n_gal = np.zeros(n)

    rvir = 2147

    zero = np.zeros(n)

    vol_shells = np.zeros(n)

    gal_density = np.zeros(n)

    v_disp = np.zeros(n)

    for i in range(0, n):
        print(i)

        #cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
        cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025) #new binning

        #cond = np.logical_and(rlog > (i + 92) * 0.025,np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x_gal_0>0,np.logical_and(y_gal_0<0,z_gal_0<0))))

        vol_shells[i] = (4/3)*np.pi*((10**((i + 93) * 0.025))**3 - (10**((i + 92) * 0.025))**3)

        v_rad_mean[i] = np.mean(v_rad[cond])
        v_rad_std[i] = np.std(v_rad[cond])
        n_gal[i] = len(v_rad[cond])

        gal_density[i] = n_gal[i]/vol_shells[i]

        vx_mean = np.mean(vx_gal[cond])
        vy_mean = np.mean(vy_gal[cond])
        vz_mean = np.mean(vz_gal[cond])

        v_disp[i] = np.sqrt(np.sum((vx_gal[cond]-vx_mean)**2+(vy_gal[cond]-vy_mean)**2+(vz_gal[cond]-vz_mean)**2)/(3*len(vx_gal[cond])))




    print("ngal",n_gal)

    #print("v_rad_log",v_rad_log)
    #print("n_gal",n_gal)
    #print("vol_shells",vol_shells)

    grad_v_rad_mean = np.gradient(v_rad_mean)
    grad2_v_rad_log = np.gradient(grad_v_rad_mean)

    #grad_gal_den = np.gradient(gal_density)
    log_gal_den = np.log10(gal_density)
    grad_log_gal_den = np.gradient(log_gal_den)

    #np.save("/data/cluster/tlebeau/virgo/sectors_study/splashback/v_rad_mean_sect5.npy",v_rad_mean)
    #np.save("/data/cluster/tlebeau/virgo/sectors_study/splashback/v_rad_std_sect5.npy", v_rad_std)

    v_rad_mean_all = np.load("/data/cluster/tlebeau/virgo/sectors_study/splashback/v_rad_mean_all.npy")
    v_rad_std_all = np.load("/data/cluster/tlebeau/virgo/sectors_study/splashback/v_rad_std_all.npy")
    v_rad_mean_sect1 = np.load("/data/cluster/tlebeau/virgo/sectors_study/splashback/v_rad_mean_sect1.npy")
    v_rad_std_sect1 = np.load("/data/cluster/tlebeau/virgo/sectors_study/splashback/v_rad_std_sect1.npy")
    v_rad_mean_sect5 = np.load("/data/cluster/tlebeau/virgo/sectors_study/splashback/v_rad_mean_sect5.npy")
    v_rad_std_sect5 = np.load("/data/cluster/tlebeau/virgo/sectors_study/splashback/v_rad_std_sect5.npy")


    #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(45)])

    #other binning : start at 100kpc, finish at 10Mpc, need more bins


    rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

    #plt.plot(rlogbin_cen/rvir, v_rad_log,ls="dotted",marker='.')
    #plt.plot(rlogbin_cen / rvir, grad_v_rad_log, ls="dotted", marker='.')

    zeros = np.zeros(n)
    minus_ones = - np.ones(n)

    log_gal_den = np.log10(gal_density)

    b = 0.025
    grad_log_gal_den = np.gradient(log_gal_den,b)



    def plot_gal_den():
        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        c.plot(rlogbin_cen / rvir, log_gal_den, label="Galaxy density", ls="dotted", marker='.',c='black')

        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        # c.axvline(x=1087, color='grey')
        # c.text(1087, -2, "$R_{500}$", rotation=90, size=16)
        # c.axvline(x=2147, color='grey', ls='dashed')
        # c.text(2147, -2, "$R_{vir}$", rotation=90, size=16)
        c.set_xlim(0.3, 10)
        #c.set_title("Dark matter density profiles")
        # c.set_ylim(-6.4, -2.1)
        # plt.xlabel("R(kpc)", size=16)
        c.set_ylabel(" $log_{10}(n_{gal}[kpc^{-3}])$", size=16)  ###code à copier ds plot : $log_{10}(n_{gal}[kpc^{-3}])$

        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        #c.legend()
        c.set_xscale('log')
        c.set_xticks([])
        c.set_title("Galaxies density")
        # c.yaxis.set_ticklabels([])
        # plt.xticks(fontsize=14)
        # a.set_yticks()

        # d.plot(rlogbin_cen/rvir, grad_log_den_dm, ls="dotted", marker='.', c='black')

        d.plot(rlogbin_cen / rvir, grad_log_gal_den, label="Galaxy density", ls="dotted", marker='.',c='black')

        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)

        #d.axvline(x=1, color='grey', label='$R_{vir}$=2147kpc', ls='dashed')
        #d.axvline(x=1.439, color='black', label="All: $R_{sb}\sim$3090kpc", ls='dashed')
        #d.axvline(x=2.026, color='red', label="Sector 1: $R_{sb}\sim$4350kpc", ls='dashed')
        #d.axvline(x=1.705, color='purple', label="Sector 5: $R_{sb}\sim$3660kpc ?", ls='dashed')

        # d.axvline(x=1087, color='grey')
        # d.text(1087, -7, "$R_{500}$", rotation=90, size=16)
        # d.axvline(x=2147, color='grey', ls='dashed')
        # d.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
        # d.set_xlabel("$R$ [kpc]", size=16)
        d.set_xlabel("$R/R_{vir}$", size=16)
        # d.yaxis.set_ticklabels([])
        # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        d.set_ylabel("grad", size=16)  # $\frac{dlog_{10}(n_{gal})}{dlog_{10}(r)}$
        # plt.legend(prop={'size': 16})
        d.set_xscale('log')
        d.set_xlim(0.3, 10)
        d.set_ylim(-14.5, 7)
        #d.legend()
        zerox = np.linspace(50, 8000, 500)
        zeroy = np.zeros(500)
        # d.plot(zerox, zeroy, c='orange', ls='dotted')
        # b.set_xticks()

        # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
        # plt.xlim(50,7000)
        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()
        print("end")
        sys.exit()

    #plot_gal_den()

    #plt.plot(rlogbin_cen/rvir,v_disp/v_rad_mean,label="Velocity dispersion",ls="dotted",marker='.')


    #plt.scatter(rlogbin_cen / rvir, v_rad_mean, s=6, c='black')
    #plt.errorbar(rlogbin_cen / rvir, v_rad_mean, yerr=v_rad_std, ls="dotted", c='black')

    plt.plot(rlogbin_cen, v_rad_mean_all, c='black', alpha=0.7, ls="dashed",label="all galaxies",marker='.')
    plt.scatter(rlogbin_cen, v_rad_mean_all, s=6, c='black',alpha=0.7)
    plt.errorbar(rlogbin_cen, v_rad_mean_all, yerr=v_rad_std_all, ls="dotted", c='black',label="all galaxies",alpha=0.7)

    #plt.plot(rlogbin_cen / rvir, v_rad_mean_sect1, c='blue', alpha=0.7, ls="dashed",label="galaxies in sector 1",marker='.')
    #plt.scatter(rlogbin_cen / rvir, v_rad_mean_sect1, s=6, c='blue',alpha=0.7)
    #plt.errorbar(rlogbin_cen / rvir, v_rad_mean_sect1, yerr=v_rad_std_sect1, ls="dotted", c='blue', label="galaxies in sector 1",alpha=0.7)

    #plt.plot(rlogbin_cen / rvir, v_rad_mean_sect5, c='green', alpha=0.7,ls="dashed",label="galaxies in sector 5",marker='.')
    #plt.scatter(rlogbin_cen / rvir, v_rad_mean_sect5, s=6, c='green',alpha=0.7)
    #plt.errorbar(rlogbin_cen / rvir, v_rad_mean_sect5, yerr=v_rad_std_sect5, ls="dotted", c='green',label="galaxies in sector 5",alpha=0.7)

    #plt.plot(rlogbin_cen / rvir, zeros, ls="dashed", color='grey')
    #plt.plot(rlogbin_cen / rvir, minus_ones, ls="dashed", color='grey')
    plt.xlabel("R [kpc]", size=16)
    plt.ylabel("$v_{rad}$ [km.$\mathrm{s^{-1}}$]", size=16)
    plt.title("Galaxies radial velocities")
    plt.axhline(y=0,color='grey',ls="dashed")
    plt.axvline(x=8000, color="blue",label="$R_{ta}$",ls='solid')
    plt.text(8000,-1000,"$R_{ta}=R_{zv}$",color='blue')
    plt.axvline(x=4500, color="red", label="$R_{id}$", ls='solid')
    plt.text(2500, -1000, "$R_{id}=R_{v_{min}}$", color='red')
    plt.axvspan(4500,8000,alpha=0.5,color='blue')
    plt.text(4600,-1500, "Depletion \n region",color='black')
    #plt.text(2.17, -2, "$R_{500}$", rotation=90, size=16)
    #plt.axvline(x=3.7, color='red', ls='solid',label="$R_{turn}$")
    #plt.text(2147, -2, "$R_{vir}$", rotation=90, size=16)
    #plt.plot(rlogbin_cen / rvir, n_gal, ls="dotted", marker='.')

    #plt.plot(rlogbin_cen/rvir,zero,ls="dashed",color='grey')

    #plt.legend()

    plt.xscale('log')
    #plt.xlim(0.1,11)
    #plt.ylim(-1e3,1.5e4)
    plt.show()

    sys.exit()

def r_splb_dm():
    def plot_dm_den():

        n = 90
        rvir = 2147
        r200m = 2895
        rcar = r200m
        # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(n)])
        rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

        log_den_dm_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_all.npy')
        grad_log_den_dm_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_all.npy')

        log_den_dm_sec1 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec1.npy')
        grad_log_den_dm_sec1 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec1.npy')

        log_den_dm_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec5.npy')
        grad_log_den_dm_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec5.npy')

        log_den_dm_sec8 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec8.npy')
        grad_log_den_dm_sec8 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec8.npy')

        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        # c.plot(rlogbin_cen, log_den_dm_all, ls="dotted", marker='.',color="black",label="all")
        # c.plot(rlogbin_cen, log_den_dm_sec4, ls="dotted", marker='.', color="red", label="sector 4")
        # c.plot(rlogbin_cen, log_den_dm_sec5, ls="dotted", marker='.', color="purple", label="sector 5")

        # c.plot(rlogbin_cen/rvir, log_den_dm, ls="dotted", marker='.',c='black')

        c.plot(rlogbin_cen / rcar, log_den_dm_all, ls="dotted", marker='.', color="black", label="Full Material")
        c.plot(rlogbin_cen / rcar, log_den_dm_sec5, ls="dotted", marker='.', color="red", label="Filament Material")
        c.plot(rlogbin_cen / rcar, log_den_dm_sec8, ls="dotted", marker='.', color="blue", label="Collapsing Material")
        c.plot(rlogbin_cen / rcar, log_den_dm_sec1, ls="dotted", marker='.', color="green", label="Outflowing Material")

        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=18, labelbottom=True,
                      labelleft=True)
        # c.axvline(x=1087, color='grey')
        # c.text(1087, -2, "$R_{500}$", rotation=90, size=16)
        # c.axvline(x=2147, color='grey', ls='dashed')
        # c.text(2147, -2, "$R_{vir}$", rotation=90, size=16)
        c.set_xlim(0.3, 10)
        #c.set_title("Dark matter density profiles")
        # c.set_ylim(-6.4, -2.1)
        # plt.xlabel("R(kpc)", size=16)
        c.set_ylabel("dlogrho/dlogr", size=18)  ###code à copier ds plot : $log_{10}(\rho_{DM}[M_{\odot}/kpc^3])$
        c.axvline(x=1, color='grey', ls='dashed')
        c.axvline(x=1.505, color='green', ls='dashed')
        c.axvline(x=1.19, color='blue', ls='dashed')

        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        c.legend()
        c.set_xscale('log')
        c.set_xticks([])
        # c.yaxis.set_ticklabels([])
        # plt.xticks(fontsize=14)
        # a.set_yticks()

        # d.plot(rlogbin_cen/rvir, grad_log_den_dm, ls="dotted", marker='.', c='black')

        d.plot(rlogbin_cen / rcar, grad_log_den_dm_all, ls="dotted", marker='.', color="black") #, label="all")
        d.plot(rlogbin_cen / rcar, grad_log_den_dm_sec1, ls="dotted", marker='.', color="green") #, label="sector 1")
        d.plot(rlogbin_cen / rcar, grad_log_den_dm_sec5, ls="dotted", marker='.', color="red") #, label="sector 5")
        d.plot(rlogbin_cen / rcar, grad_log_den_dm_sec8, ls="dotted", marker='.', color="blue") #, label="sector 8")

        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=18, labelbottom=True,labelleft=True)

        d.axvline(x=1, color='grey', label='$R_{200m}$', ls='dashed')
        d.axvline(x=1.19, color='blue', label="$R_{sp,collapsing\,material}$", ls='dashed')
        d.axvline(x=1.505, color='green', label="$R_{sp,outflowing\,material}$", ls='dashed')

        #d.axvline(x=2.026, color='red', label="Sector 1: $R_{sb}\sim$4350kpc", ls='dashed')
        #d.axvline(x=1.705, color='purple', label="Sector 5: $R_{sb}\sim$3660kpc ?", ls='dashed')

        # d.axvline(x=1087, color='grey')
        # d.text(1087, -7, "$R_{500}$", rotation=90, size=18)
        # d.axvline(x=2147, color='grey', ls='dashed')
        # d.text(2147, -7, "$R_{vir}$", rotation=90, size=18)
        # d.set_xlabel("$R$ [kpc]", size=18)
        d.set_xlabel("$R/R_{200m}$", size=18)
        # d.yaxis.set_ticklabels([])
        # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=18)
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        d.set_ylabel("grad", size=18)  # $\frac{dlog_{10}(\rho_{DM})}{dlog_{10}(r)}$
        # plt.legend(prop={'size': 16})
        d.set_xscale('log')
        d.set_xlim(0.3, 10)
        d.set_ylim(-14, 8)
        d.legend()
        zerox = np.linspace(50, 8000, 500)
        zeroy = np.zeros(500)
        # d.plot(zerox, zeroy, c='orange', ls='dotted')
        # b.set_xticks()

        # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
        # plt.xlim(50,7000)
        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()
        print("end")
        sys.exit()

    plot_dm_den()


    file_name='/data/cluster/tlebeau/virgo/virgo_xyz_dm_high_res.dat'
    d = FortranFile(file_name, 'r')

    #print('fichier dm ouvert')

    ncell = d.read_ints()
    #x = d.read_reals()
    #y = d.read_reals()
    #z = d.read_reals()

    #print("fichier lu")

    #print("n dm cell", ncell)

    x,y,z,m,vx,vy,vz = ftp.f90_to_py.read_dm(ncell,file_name)

    print('data loaded')

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

    #print("x_cen",x_cen,'y_cen',y_cen,'z_cen',z_cen)
    #sys.exit()



    r = np.sqrt(x ** 2 + y ** 2 + z ** 2)  #data already centered in f2py code




    rlog = np.log10(r)

    #plt.hist(r,bins=100)
    #plt.show()
    #sys.exit()

    n = 90

    den_dm = np.zeros(n)

    vol_shells = np.zeros(n)

    #@njit
    def loop(n,vol_shells,den_dm):

        for i in range(0, n):
            print(i)

            #cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)

        #cond = np.logical_and(rlog > (i + 35) * 0.05,np.logical_and(rlog < (i + 36) * 0.05, np.logical_and(x < 0, np.logical_and(y > 0, z > 0))))

            #cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)  # new binning

            cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > 0,np.logical_and(y > 0,z > 0))))

            #vol_shells[i] = (4 / 3) * np.pi * ((10 ** ((i + 36) * 0.05)) ** 3 - (10 ** ((i + 35) * 0.05)) ** 3)

            vol_shells[i] = ((4 / 3) * np.pi * ((10 ** ((i + 93) * 0.025)) ** 3 - (10 ** ((i + 92) * 0.025)) ** 3))/8 #divided by 8 because only take 1 of the 8 sectors

            den_dm[i] = np.sum(m[cond])/vol_shells[i]

        return den_dm, vol_shells

    #start = time.time()

    den_dm,vol_shells = loop(n,vol_shells, den_dm)

    #end = time.time()

    #print("time:",end-start)

    #sys.exit()


    #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(n)])
    rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

    log_den_dm = np.log10(den_dm)

    b = 0.025

    rvir=2147

    grad_log_den_dm = np.gradient(log_den_dm,b)

    np.save('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec8.npy',log_den_dm)
    np.save('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec8.npy', grad_log_den_dm)

    sys.exit()

    #print("profiles saved")

    #plt.plot(rlogbin_cen,log_den_dm, ls="dotted", marker='.')
    #plt.xscale("log")
    #plt.show()





    #print("x",x)
    sys.exit()

def r_splb_gas():

    def plot_bar_den():

        log_den_bar_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_all.npy')
        grad_log_den_bar_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_all.npy')

        log_den_bar_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_sec5.npy')
        grad_log_den_bar_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_sec5.npy')

        log_den_bar_sec1 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_sec1.npy')
        grad_log_den_bar_sec1 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_sec1.npy')

        log_den_bar_sec8 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_sec8.npy')
        grad_log_bar_sec_8 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_sec8.npy')




        n=90

        # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(n)])
        rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

        rvir=2147
        r200m = 2895
        r_car = r200m

        #log_den_dm_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_all.npy')
        #grad_log_den_dm_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_all.npy')

        #log_den_dm_sec4 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec4.npy')
        #grad_log_den_dm_sec4 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec4.npy')

        #log_den_dm_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec5.npy')
        #grad_log_den_dm_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec5.npy')

        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        #c.plot(rlogbin_cen/rvir, log_den_bar, ls="dotted", marker='.',c="black")
        c.plot(rlogbin_cen/r_car, log_den_bar_all, ls="dotted", marker='.',color="black",label="Full Material")
        c.plot(rlogbin_cen / r_car, log_den_bar_sec5, ls="dotted", marker='.', color="red", label="Filament Material")
        c.plot(rlogbin_cen/r_car, log_den_bar_sec8, ls="dotted", marker='.', color="blue", label="Collapsing Material")
        c.plot(rlogbin_cen / r_car, log_den_bar_sec1, ls="dotted", marker='.', color="green", label="Outflowing Material")
        c.axvline(x=1.689, color='green', ls='dashed')
        c.axvline(x=1.3456, color='blue', ls='dashed')

        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=18, labelbottom=True,
                      labelleft=True)
        #c.axvline(x=1087, color='grey')
        #c.text(1087, -3.5, "$R_{500}$", rotation=90, size=18)
        #c.axvline(x=2147, color='grey', ls='dashed')
        #c.text(2147, -3.5, "$R_{vir}$", rotation=90, size=18)
        c.set_xlim(0.3,10)
        #c.set_ylim(-6.4, -2.1)
        # plt.xlabel("R(kpc)", size=18)
        #c.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{DM}}$[M_{\odot}.$\mathrm{kpc^{-3}}$])", size=18)
        c.set_ylabel("$log_{10}(rho_{bar}[M_{\odot}/kpc^3])$", size=18) #code à copier ds plot : $log_{10}(\rho_{bar}[M_{\odot}/kpc^3])$
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        c.legend()
        c.set_xscale('log')
        #c.set_title("Baryons density profiles (including galaxies)")
        c.xaxis.set_ticklabels([])
        # plt.xticks(fontsize=14)
        # a.set_yticks()

        #d.plot(rlogbin_cen/rvir, grad_log_den_bar, ls="dotted", marker='.',c="black")
        d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="black")
        d.plot(rlogbin_cen / r_car, grad_log_den_bar_sec1, ls="dotted", marker='.', c="green")
        d.plot(rlogbin_cen / r_car, grad_log_den_bar_sec5, ls="dotted", marker='.', c="red")
        d.plot(rlogbin_cen / r_car, grad_log_bar_sec_8, ls="dotted", marker='.', c="blue")
        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=18, labelbottom=True,
                      labelleft=True)
        c.axvline(x=1, color='grey',ls='dashed')
        # d.text(1087, -7, "$R_{500}$", rotation=90, size=18)
        #d.axvline(x=2147, color='grey', ls='dashed')
        # d.text(2147, -7, "$R_{vir}$", rotation=90, size=18)
        #d.set_xlabel("$R$ [kpc]", size=18)
        d.set_xlabel("$R/R_{200m}$", size=18)
        # d.yaxis.set_ticklabels([])
        # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=18)
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        d.set_ylabel("$dlog_{10}(rho_{bar})/log_{10}(r)$", size=18) #code à copier ds plot : $\frac{dlog_{10}(\rho_{bar})}{dlog_{10}(r)}$
        # plt.legend(prop={'size': 16})

        d.axvline(x=1, color='grey', label='$R_{200m}$', ls='dashed')
        #d.axvline(x=1.605, color='black', label="All: $R_{sb}\sim$3450kpc", ls='dashed')
        d.axvline(x=1.3456, color='blue', label="$R_{sp,collapsing\,material}$", ls='dashed') #"$R_{sp,spherical\,collapse}\sim$3.9Mpc"
        d.axvline(x=1.689, color='green',label="$R_{sp,outflowing\,material}$",ls='dashed') #"$R_{sp,relaxed}\sim$4.9Mpc"


        d.set_xscale('log')
        d.set_xlim(0.3, 10)
        d.set_ylim(-10,2.5)
        zerox = np.linspace(50, 8000, 500)
        zeroy = np.zeros(500)
        d.legend()
        #d.plot(zerox, zeroy, c='orange', ls='dotted')
        # b.set_xticks()
        # b.set_yticks()
        # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
        # plt.xlim(50,7000)
        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()
        print("end")
        sys.exit()

    plot_bar_den()


    #file_name="/data/cluster/tlebeau/virgo/virgo_xyz_hydro_l19_gal_clean_m1e8.5.dat"
    file_name = "/data/cluster/tlebeau/virgo/virgo_xyz_hydro_l21.dat"
    h = FortranFile(file_name, 'r')

    ncell = h.read_ints()

    n_e = h.read_reals()
    t = h.read_reals()
    p = h.read_reals()
    x = h.read_reals()
    y = h.read_reals()
    z= h.read_reals()
    vx = h.read_reals()
    vy = h.read_reals()
    vz = h.read_reals()
    m = h.read_reals()
    lvl = h.read_reals()

    print('data loaded')

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

    #print("x",x)

    #print("x_cen",x_cen,'y_cen',y_cen,'z_cen',z_cen)
    #sys.exit()



    r = np.sqrt( (x-x_cen) ** 2 + (y-y_cen) ** 2 + (z-z_cen) ** 2)




    rlog = np.log10(r)

    #plt.hist(r,bins=100)
    #plt.show()
    #sys.exit()

    n = 90

    den_bar = np.zeros(n)

    vol_shells = np.zeros(n)

    #@njit
    def loop(n,vol_shells,den_bar):

        for i in range(0, n):
            print(i)

            #cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)

        #cond = np.logical_and(rlog > (i + 35) * 0.05,np.logical_and(rlog < (i + 36) * 0.05, np.logical_and(x < 0, np.logical_and(y > 0, z > 0))))

            #cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)  # new binning
            cond = np.logical_and(rlog > (i + 92) * 0.025,np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x>x_cen,np.logical_and(y>y_cen,z>z_cen))))  # new binning

            #vol_shells[i] = (4 / 3) * np.pi * ((10 ** ((i + 36) * 0.05)) ** 3 - (10 ** ((i + 35) * 0.05)) ** 3)

            #vol_shells[i] = (4 / 3) * np.pi * ((10 ** ((i + 93) * 0.025)) ** 3 - (10 ** ((i + 92) * 0.025)) ** 3)

            vol_shells[i] = ((4 / 3) * np.pi * ((10 ** ((i + 93) * 0.025)) ** 3 - (10 ** ((i + 92) * 0.025)) ** 3))/8 #Quand prend 1 secteur sur 8

            den_bar[i] = np.sum(m[cond])/vol_shells[i]

        return den_bar, vol_shells

    #start = time.time()

    den_bar,vol_shells = loop(n,vol_shells, den_bar)

    #end = time.time()

    #print("time:",end-start)

    #sys.exit()


    #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(n)])
    rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

    log_den_bar = np.log10(den_bar)

    b = 0.025

    rvir=2147

    grad_log_den_bar = np.gradient(log_den_bar,b)

    np.save('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_sec8.npy',log_den_bar)
    np.save('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_sec8.npy', grad_log_den_bar)

    print("profiles saved")

    #plt.plot(rlogbin_cen,log_den_bar, ls="dotted", marker='.')
    #plt.xscale("log")
    #plt.show()

    sys.exit()



    #print("x",x)
    sys.exit()


def r_splb_all():

    log_den_bar_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_all.npy')
    grad_log_den_bar_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_all.npy')
    log_den_dm_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_all.npy')
    grad_log_den_dm_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_all.npy')

    log_den_bar_rel = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_sec1.npy')
    grad_log_den_bar_rel = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_sec1.npy')
    log_den_dm_rel = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec1.npy')
    grad_log_den_dm_rel = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec1.npy')

    log_den_bar_fil = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_sec5.npy')
    grad_log_den_bar_fil = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_sec5.npy')
    log_den_dm_fil = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec5.npy')
    grad_log_den_dm_fil = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec5.npy')

    log_den_bar_spher = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_sec8.npy')
    grad_log_den_bar_spher = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_sec8.npy')
    log_den_dm_spher = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec8.npy')
    grad_log_den_dm_spher = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec8.npy')

    b = 0.025

    log_den_dm_bar_all = np.zeros(len(log_den_bar_all))
    log_den_dm_bar_all = np.log10(10**log_den_bar_all + 10**log_den_dm_all)
    grad_log_den_dm_bar_all = np.gradient(log_den_dm_bar_all,b)

    log_den_dm_bar_rel = np.zeros(len(log_den_bar_rel))
    log_den_dm_bar_rel = np.log10(10**log_den_bar_rel + 10**log_den_dm_rel)
    grad_log_den_dm_bar_rel = np.gradient(log_den_dm_bar_rel,b)

    log_den_dm_bar_fil = np.zeros(len(log_den_bar_fil))
    log_den_dm_bar_fil = np.log10(10**log_den_bar_fil + 10**log_den_dm_fil)
    grad_log_den_dm_bar_fil = np.gradient(log_den_dm_bar_fil,b)

    log_den_dm_bar_spher = np.zeros(len(log_den_bar_spher))
    log_den_dm_bar_spher = np.log10(10**log_den_bar_spher + 10**log_den_dm_spher)
    grad_log_den_dm_bar_spher = np.gradient(log_den_dm_bar_spher,b)

    rvir = 2147

    n = 90

    rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

    r200m = 2895
    r_car = r200m

    def plot_den():

        #log_den_bar_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_all.npy')
        #grad_log_den_bar_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_all.npy')

        #log_den_bar_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_sec5.npy')
        #grad_log_den_bar_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_sec5.npy')

        #log_den_bar_sec1 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_bar_sec1.npy')
        #grad_log_den_bar_sec1 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_bar_sec1.npy')




        n=90

        # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(n)])
        rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

        rvir=2147
        r200m = 2895
        r_car = r200m

        #log_den_dm_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_all.npy')
        #grad_log_den_dm_all = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_all.npy')

        #log_den_dm_sec4 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec4.npy')
        #grad_log_den_dm_sec4 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec4.npy')

        #log_den_dm_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/log_den_dm_sec5.npy')
        #grad_log_den_dm_sec5 = np.load('/data/cluster/tlebeau/virgo/sectors_study/splashback/grad_log_den_dm_sec5.npy')

        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        #c.plot(rlogbin_cen/rvir, log_den_bar, ls="dotted", marker='.',c="black")
        c.plot(rlogbin_cen/r_car, log_den_dm_all, ls="dotted", marker='.',color="black",label="DM")


        #c.plot(rlogbin_cen/r_car, log_den_bar_all, ls="dotted", marker='.', color="green", label="baryons")
        #c.plot(rlogbin_cen/r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkgreen", label="DM+baryons")

        #c.plot(rlogbin_cen / r_car, log_den_bar_all, ls="dotted", marker='.', color="blue", label="baryons")
        #c.plot(rlogbin_cen / r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkblue", label="DM+baryons")

        #c.plot(rlogbin_cen / r_car, log_den_bar_all, ls="dotted", marker='.', color="red", label="baryons")
        #c.plot(rlogbin_cen / r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkred", label="DM+baryons")

        c.plot(rlogbin_cen / r_car, log_den_bar_all, ls="dotted", marker='.', color="grey", label="baryons")
        c.plot(rlogbin_cen / r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkgrey", label="DM+baryons")

        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=18, labelbottom=True,
                      labelleft=True)
        #c.axvline(x=1087, color='grey')
        #c.text(1087, -3.5, "$R_{500}$", rotation=90, size=18)
        #c.axvline(x=2147, color='grey', ls='dashed')
        #c.text(2147, -3.5, "$R_{vir}$", rotation=90, size=18)
        c.set_xlim(0.3,10)
        #c.set_ylim(-6.4, -2.1)
        # plt.xlabel("R(kpc)", size=18)
        #c.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{DM}}$[M_{\odot}.$\mathrm{kpc^{-3}}$])", size=18)
        c.set_ylabel("$log_{10}(rho[M_{\odot}/kpc^3])$", size=18) #code à copier ds plot : $log_{10}(\rho[M_{\odot}/kpc^3])$
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        c.legend()
        c.set_xscale('log')
        #c.set_title("Density profiles comparison, spherical collapse sector")
        #c.set_title("Density profiles comparison, matter infall from filament sector")
        c.set_title("Density profiles comparison, full box")
        c.xaxis.set_ticklabels([])

        #Relaxed sector
        #c.axvline(x=1.505, color='darkgreen', ls='dashed', gapcolor="black",dashes=[4, 4])
        #c.axvline(x=1.685, color='green', ls='dashed')

        #Spherical collapse sector
        #c.axvline(x=1.19, color='black', ls='dashed', gapcolor="darkblue",dashes=[4, 4])
        #c.axvline(x=1.3456, color='blue', ls='dashed')

        # Matter infall from filament sector
        #c.axvline(x=1.505, color='darkred', ls='dashed', gapcolor="black", dashes=[4, 4])
        #c.axvline(x=1.685, color='red', ls='dashed')

        # plt.xticks(fontsize=14)
        # a.set_yticks()

        #d.plot(rlogbin_cen/rvir, grad_log_den_bar, ls="dotted", marker='.',c="black")
        d.plot(rlogbin_cen / r_car, grad_log_den_dm_all, ls="dotted", marker='.', c="black")

        #d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="green")
        #d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkgreen")

        #d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="blue")
        #d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkblue")

        #d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="red")
        #d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkred")

        d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="grey")
        d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkgrey")

        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=18, labelbottom=True,
                      labelleft=True)
        d.axvline(x=1087, color='grey')
        # d.text(1087, -7, "$R_{500}$", rotation=90, size=18)
        #d.axvline(x=2147, color='grey', ls='dashed')
        # d.text(2147, -7, "$R_{vir}$", rotation=90, size=18)
        #d.set_xlabel("$R$ [kpc]", size=18)
        d.set_xlabel("$R/R_{200m}$", size=18)
        # d.yaxis.set_ticklabels([])
        # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=18)
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        d.set_ylabel("$dlog_{10}(rho_{bar})/log_{10}(r)$", size=18) #code à copier ds plot : $\frac{dlog_{10}(\rho)}{dlog_{10}(r)}$
        # plt.legend(prop={'size': 16})

        d.axvline(x=1, color='grey', label='$R_{200m}$', ls='dashed')

        ##sector 1
        #d.axvline(x=2.025, color='orange', label="DM(+baryons): $R_{sb}\sim$4350kpc", ls='dashed',gapcolor="green",dashes=[4, 4])
        #d.axvline(x=2.267, color='blue',label="Baryons: $R_{sb}\sim$4890kpc",ls='dashed')

        ##full box
        #d.axvline(x=1.431, color='orange', label="DM(+baryons): $R_{sb}\sim$3090kpc", ls='dashed',gapcolor="green",dashes=[4, 4])
        #d.axvline(x=1.606, color='blue',label="Baryons: $R_{sb}\sim$3450kpc",ls='dashed')

        ##sector 5

        #Relaxed sector
        #d.axvline(x=1.505, color='darkgreen', label="$R_{sp_{DM(+bar)}}$", ls='dashed',gapcolor="black",dashes=[4, 4])
        #d.axvline(x=1.685, color='green',label="$R_{sp_{bar}}$",ls='dashed')

        #Spherical collapse
        #d.axvline(x=1.19, color='darkblue', label="$R_{sp_{DM(+bar)}}$", ls='dashed', gapcolor="black",dashes=[4, 4])
        #d.axvline(x=1.3456, color='blue', label="$R_{sp_{bar}}$", ls='dashed')

        # Matter infall from filament sector
        #d.axvline(x=1.505, color='darkred', label="$R_{sp_{DM(+bar)}}$", ls='dashed', gapcolor="black", dashes=[4, 4])
        #d.axvline(x=1.685, color='red', label="$R_{sp_{bar}}$", ls='dashed')

        d.set_xscale('log')
        d.set_xlim(0.3, 10)
        #d.set_ylim(-13.4,5.2) ##sector 1
        #d.set_ylim(-12.3, 8) ##full box
        d.set_ylim(-17.5, 11)  ##sector 5

        zerox = np.linspace(50, 8000, 500)
        zeroy = np.zeros(500)
        d.legend()
        #d.plot(zerox, zeroy, c='orange', ls='dotted')
        # b.set_xticks()
        # b.set_yticks()
        # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
        # plt.xlim(50,7000)
        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()
        print("end")
        sys.exit()

    def plot_den_rel_spher():
        f, ((a, c), (b, d)) = plt.subplots(2, 2)

        a.plot(rlogbin_cen / r_car, log_den_dm_spher, ls="solid", marker='.', color="black", label="DM",ms=6)

        # c.plot(rlogbin_cen/r_car, log_den_bar_all, ls="dotted", marker='.', color="green", label="baryons")
        # c.plot(rlogbin_cen/r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkgreen", label="DM+baryons")

        a.plot(rlogbin_cen / r_car, log_den_bar_spher, ls="dashed", marker='.', color="dodgerblue", label="gas",ms=6)
        a.plot(rlogbin_cen / r_car, log_den_dm_bar_spher, ls="dotted", marker='.', color="darkblue", label="DM+gas",ms=6)

        # c.plot(rlogbin_cen / r_car, log_den_bar_all, ls="dotted", marker='.', color="red", label="baryons")
        # c.plot(rlogbin_cen / r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkred", label="DM+baryons")

        #c.plot(rlogbin_cen / r_car, log_den_bar_all, ls="dotted", marker='.', color="grey", label="baryons")
        #c.plot(rlogbin_cen / r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkgrey", label="DM+baryons")

        a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        # c.axvline(x=1087, color='grey')
        # c.text(1087, -3.5, "$R_{500}$", rotation=90, size=16)
        # c.axvline(x=2147, color='grey', ls='dashed')
        # c.text(2147, -3.5, "$R_{vir}$", rotation=90, size=16)
        a.set_xlim(0.3, 4.9)
        a.set_ylim(-0.2, 5)
        # c.set_ylim(-6.4, -2.1)
        # plt.xlabel("R(kpc)", size=16)
        # c.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{DM}}$[M_{\odot}.$\mathrm{kpc^{-3}}$])", size=16)
        a.set_ylabel(r"$log_{10}(\rho~[M_{\odot}~kpc^{-3}])$", size=16)  # code à copier ds plot : $log_{10}(\rho[M_{\odot}/kpc^3])$
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        a.legend()
        a.set_xscale('log')
        # c.set_title("Density profiles comparison, spherical collapse sector")
        # c.set_title("Density profiles comparison, matter infall from filament sector")
        a.set_title("Collapsing Material")
        a.xaxis.set_ticklabels([])

        a.axvline(x=1, color='grey', ls='solid')
        a.axvline(x=1.3456, color='dodgerblue', ls='dashed')
        a.axvline(x=1.19, color='darkblue', ls='dotted')

        # Relaxed sector
        # c.axvline(x=1.505, color='darkgreen', ls='dashed', gapcolor="black",dashes=[4, 4])
        # c.axvline(x=1.685, color='green', ls='dashed')

        # Spherical collapse sector
        # c.axvline(x=1.19, color='black', ls='dashed', gapcolor="darkblue",dashes=[4, 4])
        # c.axvline(x=1.3456, color='blue', ls='dashed')

        # Matter infall from filament sector
        # c.axvline(x=1.505, color='darkred', ls='dashed', gapcolor="black", dashes=[4, 4])
        # c.axvline(x=1.685, color='red', ls='dashed')

        # plt.xticks(fontsize=14)
        # a.set_yticks()

        # d.plot(rlogbin_cen/rvir, grad_log_den_bar, ls="dotted", marker='.',c="black")
        b.plot(rlogbin_cen / r_car, grad_log_den_dm_spher, ls="solid", marker='.', c="black",ms=6)

        # d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="green")
        # d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkgreen")

        b.plot(rlogbin_cen / r_car, grad_log_den_bar_spher, ls="dashed", marker='.', c="dodgerblue",ms=6)
        b.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_spher, ls="dotted", marker='.', c="darkblue",ms=6)

        # d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="red")
        # d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkred")

        #d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="grey")
        #d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkgrey")

        b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        #b.axvline(x=1087, color='grey')
        # d.text(1087, -7, "$R_{500}$", rotation=90, size=16)
        # d.axvline(x=2147, color='grey', ls='dashed')
        # d.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
        # d.set_xlabel("$R$ [kpc]", size=16)
        b.set_xlabel("$R/R_{200m}$", size=16)
        # d.yaxis.set_ticklabels([])
        # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        b.set_ylabel(r"$\frac{dlog_{10}(\rho)}{dlog_{10}(r)}$", size=16)  # code à copier ds plot : $\frac{dlog_{10}(\rho)}{dlog_{10}(r)}$
        # plt.legend(prop={'size': 16})

        #b.axvline(x=1, color='grey', label='$R_{200m}$', ls='dashed')

        ##sector 1
        # d.axvline(x=2.025, color='orange', label="DM(+baryons): $R_{sb}\sim$4350kpc", ls='dashed',gapcolor="green",dashes=[4, 4])
        # d.axvline(x=2.267, color='blue',label="Baryons: $R_{sb}\sim$4890kpc",ls='dashed')

        ##full box
        # d.axvline(x=1.431, color='orange', label="DM(+baryons): $R_{sb}\sim$3090kpc", ls='dashed',gapcolor="green",dashes=[4, 4])
        # d.axvline(x=1.606, color='blue',label="Baryons: $R_{sb}\sim$3450kpc",ls='dashed')

        ##sector 5

        # Relaxed sector
        # d.axvline(x=1.505, color='darkgreen', label="$R_{sp_{DM(+bar)}}$", ls='dashed',gapcolor="black",dashes=[4, 4])
        # d.axvline(x=1.685, color='green',label="$R_{sp_{bar}}$",ls='dashed')

        # Spherical collapse
        # d.axvline(x=1.19, color='darkblue', label="$R_{sp_{DM(+bar)}}$", ls='dashed', gapcolor="black",dashes=[4, 4])
        # d.axvline(x=1.3456, color='blue', label="$R_{sp_{bar}}$", ls='dashed')

        # Matter infall from filament sector
        # d.axvline(x=1.505, color='darkred', label="$R_{sp_{DM(+bar)}}$", ls='dashed', gapcolor="black", dashes=[4, 4])
        # d.axvline(x=1.685, color='red', label="$R_{sp_{bar}}$", ls='dashed')

        b.set_xscale('log')
        b.set_xlim(0.3, 4.9)
        # d.set_ylim(-13.4,5.2) ##sector 1
        # d.set_ylim(-12.3, 8) ##full box
        b.set_ylim(-15, 13)  ##sector 5

        zerox = np.linspace(50, 8000, 500)
        zeroy = np.zeros(500)

        b.axvline(x=1, color='grey', label='$R_{200m}$', ls='solid')
        b.axvline(x=1.3456, color='dodgerblue', label="$R_{sp,gas}$", ls='dashed')
        b.axvline(x=1.19, color='darkblue', label="$R_{sp,DM}$", ls='dotted')

        b.legend()



        # d.plot(zerox, zeroy, c='orange', ls='dotted')
        # b.set_xticks()
        # b.set_yticks()
        # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
        # plt.xlim(50,7000)



        c.plot(rlogbin_cen / r_car, log_den_dm_rel, ls="solid", marker='.', color="black", label="DM",ms=6)
        c.plot(rlogbin_cen/r_car, log_den_bar_rel, ls="dashed", marker='.', color="orange", label="gas",ms=6)
        c.plot(rlogbin_cen/r_car, log_den_dm_bar_rel, ls="dotted", marker='.', color="orangered", label="DM+gas",ms=6)

        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        # c.axvline(x=1087, color='grey')
        # c.text(1087, -3.5, "$R_{500}$", rotation=90, size=16)
        # c.axvline(x=2147, color='grey', ls='dashed')
        # c.text(2147, -3.5, "$R_{vir}$", rotation=90, size=16)
        c.set_xlim(0.3, 4.9)
        c.set_ylim(-0.2, 5)

        c.axvline(x=1, color='grey', ls='solid')
        c.axvline(x=1.689, color='orange', ls='dashed')
        c.axvline(x=1.505, color='orangered', ls='dotted')
        # c.set_ylim(-6.4, -2.1)
        # plt.xlabel("R(kpc)", size=16)
        # c.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{DM}}$[M_{\odot}.$\mathrm{kpc^{-3}}$])", size=16)
        #a.set_ylabel("$log_{10}(rho[M_{\odot}/kpc^3])$",size=16)  # code à copier ds plot : $log_{10}(\rho[M_{\odot}/kpc^3])$
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        c.legend(loc="upper right")
        c.set_xscale('log')
        # c.set_title("Density profiles comparison, spherical collapse sector")
        # c.set_title("Density profiles comparison, matter infall from filament sector")
        c.set_title("Outflowing material")
        c.xaxis.set_ticklabels([])
        c.yaxis.set_ticklabels([])



        d.plot(rlogbin_cen / r_car, grad_log_den_dm_rel, ls="solid", marker='.', c="black",ms=6)
        d.plot(rlogbin_cen / r_car, grad_log_den_bar_rel, ls="dashed", marker='.', c="orange",ms=6)
        d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_rel, ls="dotted", marker='.', c="orangered",ms=6)

        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True, labelleft=True)

        d.set_xlabel("$R/R_{200m}$", size=16)
        d.yaxis.set_ticklabels([])

        d.set_xscale('log')
        d.set_xlim(0.3, 4.9)
        # d.set_ylim(-13.4,5.2) ##sector 1
        # d.set_ylim(-12.3, 8) ##full box
        d.set_ylim(-15, 13)  ##sector 5

        d.axvline(x=1, color='grey', label='$R_{200m}$', ls='solid')
        d.axvline(x=1.689, color='orange', label="$R_{sp,gas}$", ls='dashed')
        d.axvline(x=1.505, color='orangered', label="$R_{sp,DM}$", ls='dotted')

        d.legend()







        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()



    def plot_den_fil_tot():

        f, ((a, c), (b, d)) = plt.subplots(2, 2)

        a.plot(rlogbin_cen / r_car, log_den_dm_fil, ls="solid", marker='.', color="black", label="DM",ms=6)

        # c.plot(rlogbin_cen/r_car, log_den_bar_all, ls="dotted", marker='.', color="green", label="baryons")
        # c.plot(rlogbin_cen/r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkgreen", label="DM+baryons")

        a.plot(rlogbin_cen / r_car, log_den_bar_fil, ls="dashed", marker='.', color="mediumvioletred", label="gas",ms=6)
        a.plot(rlogbin_cen / r_car, log_den_dm_bar_fil, ls="dotted", marker='.', color="purple", label="DM+gas",ms=6)

        # c.plot(rlogbin_cen / r_car, log_den_bar_all, ls="dotted", marker='.', color="red", label="baryons")
        # c.plot(rlogbin_cen / r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkred", label="DM+baryons")

        # c.plot(rlogbin_cen / r_car, log_den_bar_all, ls="dotted", marker='.', color="grey", label="baryons")
        # c.plot(rlogbin_cen / r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="darkgrey", label="DM+baryons")

        a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        # c.axvline(x=1087, color='grey')
        # c.text(1087, -3.5, "$R_{500}$", rotation=90, size=16)
        # c.axvline(x=2147, color='grey', ls='dashed')
        # c.text(2147, -3.5, "$R_{vir}$", rotation=90, size=16)
        a.set_xlim(0.3, 4.9)
        a.set_ylim(-0.2, 5)
        # c.set_ylim(-6.4, -2.1)
        # plt.xlabel("R(kpc)", size=16)
        # c.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{DM}}$[M_{\odot}.$\mathrm{kpc^{-3}}$])", size=16)
        #a.set_ylabel("$log_{10}(rho[M_{\odot}/kpc^3])$",size=16)  # code à copier ds plot : $log_{10}(\rho[M_{\odot}/kpc^3])$
        a.set_ylabel(r"$log_{10}(\rho~[M_{\odot}~kpc^{-3}])$", size=16)

        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        a.legend()
        a.set_xscale('log')
        # c.set_title("Density profiles comparison, spherical collapse sector")
        # c.set_title("Density profiles comparison, matter infall from filament sector")
        a.set_title("Filament Material")
        a.xaxis.set_ticklabels([])

        a.axvline(x=1, color='grey', ls='solid')
        #a.axvline(x=1.3456, color='blue', ls='dashed')
        #a.axvline(x=1.19, color='darkblue', ls='dashed')

        # Relaxed sector
        # c.axvline(x=1.505, color='darkgreen', ls='dashed', gapcolor="black",dashes=[4, 4])
        # c.axvline(x=1.685, color='green', ls='dashed')

        # Spherical collapse sector
        # c.axvline(x=1.19, color='black', ls='dashed', gapcolor="darkblue",dashes=[4, 4])
        # c.axvline(x=1.3456, color='blue', ls='dashed')

        # Matter infall from filament sector
        # c.axvline(x=1.505, color='darkred', ls='dashed', gapcolor="black", dashes=[4, 4])
        # c.axvline(x=1.685, color='red', ls='dashed')

        # plt.xticks(fontsize=14)
        # a.set_yticks()

        # d.plot(rlogbin_cen/rvir, grad_log_den_bar, ls="dotted", marker='.',c="black")
        b.plot(rlogbin_cen / r_car, grad_log_den_dm_fil, ls="solid", marker='.', c="black",ms=6)

        # d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="green")
        # d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkgreen")

        b.plot(rlogbin_cen / r_car, grad_log_den_bar_fil, ls="dashed", marker='.', c="mediumvioletred",ms=6)
        b.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_fil, ls="dotted", marker='.', c="purple",ms=6)

        # d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="red")
        # d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkred")

        # d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dotted", marker='.', c="grey")
        # d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="darkgrey")

        b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        # b.axvline(x=1087, color='grey')
        # d.text(1087, -7, "$R_{500}$", rotation=90, size=16)
        # d.axvline(x=2147, color='grey', ls='dashed')
        # d.text(2147, -7, "$R_{vir}$", rotation=90, size=16)
        # d.set_xlabel("$R$ [kpc]", size=16)
        b.set_xlabel("$R/R_{200m}$", size=16)
        # d.yaxis.set_ticklabels([])
        # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        #b.set_ylabel("$dlog_{10}(rho_{bar})/log_{10}(r)$",size=16)  # code à copier ds plot : $\frac{dlog_{10}(\rho)}{dlog_{10}(r)}$
        b.set_ylabel(r"$\frac{dlog_{10}(\rho)}{dlog_{10}(r)}$", size=16)
        # plt.legend(prop={'size': 16})

        # b.axvline(x=1, color='grey', label='$R_{200m}$', ls='dashed')

        ##sector 1
        # d.axvline(x=2.025, color='orange', label="DM(+baryons): $R_{sb}\sim$4350kpc", ls='dashed',gapcolor="green",dashes=[4, 4])
        # d.axvline(x=2.267, color='blue',label="Baryons: $R_{sb}\sim$4890kpc",ls='dashed')

        ##full box
        # d.axvline(x=1.431, color='orange', label="DM(+baryons): $R_{sb}\sim$3090kpc", ls='dashed',gapcolor="green",dashes=[4, 4])
        # d.axvline(x=1.606, color='blue',label="Baryons: $R_{sb}\sim$3450kpc",ls='dashed')

        ##sector 5

        # Relaxed sector
        # d.axvline(x=1.505, color='darkgreen', label="$R_{sp_{DM(+bar)}}$", ls='dashed',gapcolor="black",dashes=[4, 4])
        # d.axvline(x=1.685, color='green',label="$R_{sp_{bar}}$",ls='dashed')

        # Spherical collapse
        # d.axvline(x=1.19, color='darkblue', label="$R_{sp_{DM(+bar)}}$", ls='dashed', gapcolor="black",dashes=[4, 4])
        # d.axvline(x=1.3456, color='blue', label="$R_{sp_{bar}}$", ls='dashed')

        # Matter infall from filament sector
        # d.axvline(x=1.505, color='darkred', label="$R_{sp_{DM(+bar)}}$", ls='dashed', gapcolor="black", dashes=[4, 4])
        # d.axvline(x=1.685, color='red', label="$R_{sp_{bar}}$", ls='dashed')

        b.set_xscale('log')
        b.set_xlim(0.3, 4.9)
        # d.set_ylim(-13.4,5.2) ##sector 1
        # d.set_ylim(-12.3, 8) ##full box
        b.set_ylim(-17.5, 10.5)  ##sector 5

        zerox = np.linspace(50, 8000, 500)
        zeroy = np.zeros(500)

        b.axvline(x=1, color='grey', label='$R_{200m}$', ls='solid')
        #b.axvline(x=1.3456, color='blue', label="$R_{sp,bar}\sim$3.9Mpc", ls='dashed')
        #b.axvline(x=1.19, color='darkblue', label="$R_{sp,DM}\sim$3.4Mpc", ls='dashed')

        b.legend()

        # d.plot(zerox, zeroy, c='orange', ls='dotted')
        # b.set_xticks()
        # b.set_yticks()
        # plt.title("Projected temperature profiles, high res, MW los, 100 MC loops, \n comparison between 3 weighting methods")
        # plt.xlim(50,7000)

        c.plot(rlogbin_cen / r_car, log_den_dm_all, ls="solid", marker='.', color="black", label="DM",ms=6)
        c.plot(rlogbin_cen / r_car, log_den_bar_all, ls="dashed", marker='.', color="silver", label="gas",ms=6)
        c.plot(rlogbin_cen / r_car, log_den_dm_bar_all, ls="dotted", marker='.', color="grey", label="DM+gas",ms=6)

        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        # c.axvline(x=1087, color='grey')
        # c.text(1087, -3.5, "$R_{500}$", rotation=90, size=16)
        # c.axvline(x=2147, color='grey', ls='dashed')
        # c.text(2147, -3.5, "$R_{vir}$", rotation=90, size=16)
        c.set_xlim(0.3, 4.9)
        c.set_ylim(-0.2, 5)

        c.axvline(x=1, color='grey', ls='solid')
        #c.axvline(x=1.689, color='green', ls='dashed')
        #c.axvline(x=1.505, color='darkgreen', ls='dashed')
        # c.set_ylim(-6.4, -2.1)
        # plt.xlabel("R(kpc)", size=16)
        # c.set_ylabel("lo$\mathrm{g_{10}}$($n_{\mathrm{DM}}$[M_{\odot}.$\mathrm{kpc^{-3}}$])", size=16)
        # a.set_ylabel("$log_{10}(rho[M_{\odot}/kpc^3])$",size=16)  # code à copier ds plot : $log_{10}(\rho[M_{\odot}/kpc^3])$
        # plt.ylabel("$log_{10}(n_e[cm^{-3}])$",size=14)
        # plt.ylabel("$log_{10}(T[keV])$", size=14)
        c.legend()
        c.set_xscale('log')
        # c.set_title("Density profiles comparison, spherical collapse sector")
        # c.set_title("Density profiles comparison, matter infall from filament sector")
        c.set_title("Full Material")
        c.xaxis.set_ticklabels([])
        c.yaxis.set_ticklabels([])

        d.plot(rlogbin_cen / r_car, grad_log_den_dm_all, ls="solid", marker='.', c="black",ms=6)

        d.plot(rlogbin_cen / r_car, grad_log_den_bar_all, ls="dashed", marker='.', c="silver",ms=6)
        d.plot(rlogbin_cen / r_car, grad_log_den_dm_bar_all, ls="dotted", marker='.', c="grey",ms=6)

        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)

        d.set_xlabel("$R/R_{200m}$", size=16)
        d.yaxis.set_ticklabels([])

        d.set_xscale('log')
        d.set_xlim(0.3, 4.9)
        # d.set_ylim(-13.4,5.2) ##sector 1
        # d.set_ylim(-12.3, 8) ##full box
        d.set_ylim(-17.5, 10)  ##sector 5

        d.axvline(x=1, color='grey', label='$R_{200m}$', ls='solid')
        #d.axvline(x=1.689, color='green', label="$R_{sp,bar}\sim$4.9Mpc", ls='dashed')
        #d.axvline(x=1.505, color='darkgreen', label="$R_{sp,DM}\sim$4.3Mpc", ls='dashed')

        d.legend(loc="upper left")

        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()

    #plot_den()

    #plot_den_rel_spher()

    plot_den_fil_tot()


def estimate_r200():

    print("loading data")

    file_name = '/data/cluster/tlebeau/virgo/virgo_xyz_dm_high_res.dat'
    d = FortranFile(file_name, 'r')

    ncell = d.read_ints()

    x_dm, y_dm, z_dm, m_dm, vx_dm, vy_dm, vz_dm = ftp.f90_to_py.read_dm(ncell, file_name)

    r_dm = np.sqrt(x_dm ** 2 + y_dm ** 2 + z_dm ** 2)

    #r_dm = np.log10(r_dm)

    print('DM data ready')

    file_name = "/data/cluster/tlebeau/virgo/virgo_xyz_hydro_l21.dat"
    h = FortranFile(file_name, 'r')

    ncell = h.read_ints()

    n_e = h.read_reals()
    t = h.read_reals()
    p = h.read_reals()
    x_bar = h.read_reals()
    y_bar = h.read_reals()
    z_bar = h.read_reals()
    vx = h.read_reals()
    vy = h.read_reals()
    vz = h.read_reals()
    m_bar = h.read_reals()
    lvl = h.read_reals()

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

    r_bar = np.sqrt((x_bar - x_cen) ** 2 + (y_bar - y_cen) ** 2 + (z_bar - z_cen) ** 2)

    #print("r_bar",r_bar)

    ##masses in rsp

    m_3300 = np.sum(m_bar[r_bar < 3300]) + np.sum(m_dm[r_dm < 3300])
    m_3400 = np.sum(m_bar[r_bar < 3400]) + np.sum(m_dm[r_dm < 3400])
    m_3900 = np.sum(m_bar[r_bar < 3900]) + np.sum(m_dm[r_dm < 3900])
    m_4300 = np.sum(m_bar[r_bar < 4300]) + np.sum(m_dm[r_dm < 4300])
    m_4900 = np.sum(m_bar[r_bar < 4900]) + np.sum(m_dm[r_dm < 4900])
    m_5500 = np.sum(m_bar[r_bar < 5500]) + np.sum(m_dm[r_dm < 5500])

    print("m_3300",m_3300)
    print("m_3400",m_3400)
    print("m_3900",m_3900)
    print("m_4300",m_4300)
    print("m_4900",m_4900)
    print("m_5500",m_5500)

    ##masses in r500c

    #m_1090 = np.sum(m_bar[r_bar < 1090]) + np.sum(m_dm[r_dm < 1090])
    #m_1085 = np.sum(m_bar[r_bar < 1085]) + np.sum(m_dm[r_dm < 1085])
    #m_1104 = np.sum(m_bar[r_bar < 1104]) + np.sum(m_dm[r_dm < 1104])
    #m_1229 = np.sum(m_bar[r_bar < 1229]) + np.sum(m_dm[r_dm < 1229])

    #print("m_1090",m_1090)
    #print("m_1085",m_1085)
    #print("m_1104",m_1104)
    #print("m_1229",m_1229)

    ##masses in r200m

    #m_2766 = np.sum(m_bar[r_bar < 2766]) + np.sum(m_dm[r_dm < 2766])
    #m_2895 = np.sum(m_bar[r_bar < 2895]) + np.sum(m_dm[r_dm < 2895])
    #m_2964 = np.sum(m_bar[r_bar < 2964]) + np.sum(m_dm[r_dm < 2964])
    #m_3047 = np.sum(m_bar[r_bar < 3047]) + np.sum(m_dm[r_dm < 3047])

    #print("m_2766",m_2766)
    #print("m_2895",m_2895)
    #print("m_2964",m_2964)
    #print("m_3047",m_3047)


    sys.exit()

    #r_bar = np.log10(r_bar)

    print('Baryons data ready')

    n = 200

    den = np.zeros(n)

    #cond_bar = np.logical_and(x_bar > x_cen,np.logical_and(y_bar > y_cen,z_bar > z_cen)) #Sector 8 = Spherical Collapse
    #cond_bar = np.logical_and(x_bar < x_cen,np.logical_and(y_bar < y_cen,z_bar < z_cen))  # Sector 1 = Relaxed
    cond_bar = np.logical_and(x_bar > x_cen, np.logical_and(y_bar < y_cen, z_bar < z_cen))  # Sector 5 = Filament

    #cond_dm = np.logical_and(x_dm > 0,np.logical_and(y_dm > 0,z_dm > 0)) #Sector 8 = Spherical Collapse
    #cond_dm = np.logical_and(x_dm < 0,np.logical_and(y_dm < 0,z_dm < 0))  # Sector 1 = Relaxed
    cond_dm = np.logical_and(x_dm > 0, np.logical_and(y_dm < 0, z_dm < 0))  # Sector 5 = Filament

    # cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)  # Full box

    m_dm = m_dm[cond_dm]
    m_bar = m_bar[cond_bar]
    r_dm = r_dm[cond_dm]
    r_bar = r_bar[cond_bar]

    for i in range(n):
        #cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)  # new binning

        rlogbin_cen = np.array([10 ** ((516 + i) * 0.00625) for i in range(n)])





        r = 2900 + i

        #print("i",i,"r",r)

        #den[i] = (3 * m_sun * ( np.sum([m_dm[r_dm < (i + 516) * 0.00625]]) + np.sum(m_bar[r_bar < (i + 516) * 0.00625]) ) ) / (4 * np.pi * (10 ** ((i + 516) * 0.00625) * pc * 1E3) ** 3)

        den[i] = (3 * m_sun * (np.sum([m_dm[r_dm < r]]) + np.sum(m_bar[r_bar < r]))) / (4 * np.pi * (r * pc * 1E3) ** 3)

        den[i] *=8 #because the sub-box is 8 times smaller than the full box

        rho_m = rho_c * omega_m

        sum_m_dm = np.sum([m_dm[r_dm < r]])

        sum_m_tot = np.sum([m_dm[r_dm < r]]) + np.sum(m_bar[r_bar < r])

        #print("rho/rho_m",den/rho_m)
        #print("rho/rho_c", den[i] / rho_c)

        #print("r",r,"rho/rho_c", den[i] / rho_c)
        print("r", r, "rho/rho_m", den[i] / rho_m)

        #print('m_dm',sum_m_dm)
        #print('m_tot',sum_m_tot)

        if ((den[i] / rho_m)<200) :
            print("r500 found")
            sys.exit()

    print("end")

    sys.exit()

def r_sp_proj(type,plot):

    n = 90

    rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

    if (type=="sd" and plot==1):

        meanprof_log = np.load("SD_proj_profile.npy")
        stdprof_log = np.load("SD_proj_profile_std.npy")

        medianprof_log = np.load("SD_proj_profile_med.npy")
        madprof_log = np.load("SD_proj_profile_mad.npy")

        #meanprof_log = np.load("sd_proj_profile_mean_01.npy")
        #stdprof_log = np.load("sd_proj_profile_std_01.npy")

        #medianprof_log = np.load("sd_proj_profile_med_01.npy")
        #madprof_log = np.load("sd_proj_profile_mad_01.npy")

        #meanprof_log = np.load("sd_proj_profile_mean_00.npy")
        #stdprof_log = np.load("sd_proj_profile_mean_00.npy")

        #medianprof_log = np.load("sd_proj_profile_med_00.npy")
        #madprof_log = np.load("sd_proj_profile_mad_00.npy")

        #meanprof_log_stack = np.load("SD_stacked_proj_profile.npy")
        #stdprof_log_stack = np.load("SD_stacked_proj_profile_std.npy")

        meanprof_log_stack = np.load("./maps/high_res/random_proj/sd_bar/sd_sum100_proj_profile_mean.npy")
        stdprof_log_stack = np.load("./maps/high_res/random_proj/sd_bar/sd_sum100_proj_profile_std.npy")

        grad = np.gradient(meanprof_log, 0.025)
        grad_med = np.gradient(medianprof_log, 0.025)
        grad_stack = np.gradient(meanprof_log_stack, 0.025)

        # print("meanprof",meanprof)

        # print('after meanprof calculation')

        r200m = 2895

        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        #c.plot(rlogbin_cen / r200m, meanprof_log, ls="dotted", marker='.', color='black')
        c.scatter(rlogbin_cen / r200m, meanprof_log_stack, ls="solid", marker='.', color='tomato')
        c.errorbar(rlogbin_cen / r200m, meanprof_log_stack, yerr=stdprof_log_stack, ls="solid", marker='.',color='tomato', label="Stacking over 100 random projections (mean)")
        c.scatter(rlogbin_cen / r200m, meanprof_log, ls="dotted", marker='.',color='black')
        c.errorbar(rlogbin_cen / r200m, meanprof_log, yerr=stdprof_log, ls="dotted", marker='.', color='black',label="Cen projection (mean)")
        c.scatter(rlogbin_cen / r200m, medianprof_log, ls="dashed", marker='.', color='lightgrey')
        c.errorbar(rlogbin_cen / r200m, medianprof_log, yerr=madprof_log, ls="dashed", marker='.', color='lightgrey',label="Cen projection (median)")


        #plt.scatter(rlogbin_cen, 10 ** t_all, s=6, c='black')
        #plt.errorbar(rlogbin_cen, 10 ** t_all, yerr=10 ** t_all * err_t_all, ls='dashed', label='Full box', alpha=0.7, c='black')
        # c.plot(rlogbin_cen, meanprof_log, ls="dotted", marker='.')
        c.set_xlim(0.3, 4.9)
        c.set_ylim(0, 12)
        c.set_xscale("log")
        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        c.xaxis.set_ticklabels([])
        c.set_ylabel('$log_{10}(SD~[\mathrm{M_{\odot}~kpc^{-2}}])$', size=22)
        c.set_title('Surface Density radial profile', size=22)
        c.axvline(x=1, color='grey', ls='dashed')
        c.axvline(x=1.126, color='black', ls='dashed')
        c.legend(loc="lower left")

        d.plot(rlogbin_cen / r200m, grad_stack, ls="solid", marker='.', color='tomato')
        d.plot(rlogbin_cen / r200m, grad, ls="dotted", marker='.',color='black')
        d.plot(rlogbin_cen / r200m, grad_med, ls="dashed", marker='.',color='lightgrey')
        # d.plot(rlogbin_cen, grad, ls="dotted", marker='.')
        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        d.set_xlabel("$R/R_{200m}$", size=22)

        d.set_xscale('log')
        d.set_xlim(0.3, 4.9)
        d.set_ylabel('$\\frac{dlog_{10}(SD)}{dlog_{10}(r)}$', size=22)  # code à copier ds plot : $\frac{dlog_{10}(SD)}{dlog_{10}(r)}$

        d.axvline(x=1, color='grey', ls='dashed',label="$R_{200m}$")
        d.axvline(x=1.126, color='black', ls='dashed', label="$R_{sp,SD}$")
        d.legend()

        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()

        sys.exit()

    if (type=="em" and plot==1):

        meanprof_log = np.load("em_proj_profile_mean.npy")
        stdprof_log = np.load("em_proj_profile_std.npy")

        medianprof_log = np.load("em_proj_profile_med.npy")
        madprof_log = np.load("em_proj_profile_mad.npy")

        #meanprof_log = np.load("em_proj_profile_mean_01.npy")
        #stdprof_log = np.load("em_proj_profile_std_01.npy")

        #medianprof_log = np.load("em_proj_profile_med_01.npy")
        #madprof_log = np.load("em_proj_profile_mad_01.npy")

        #meanprof_log_stack = np.load("EM_stacked_proj_profile.npy")
        #stdprof_log_stack = np.load("EM_stacked_proj_profile_std.npy")

        meanprof_log_stack = np.load("./maps/high_res/random_proj/em/em_sum100_proj_profile_mean.npy")
        stdprof_log_stack = np.load("./maps/high_res/random_proj/em/em_sum100_proj_profile_std.npy")

        print("std prof log",stdprof_log)

        #sys.exit()

        grad = np.gradient(meanprof_log, 0.025)
        grad_med = np.gradient(medianprof_log, 0.025)
        grad_stack = np.gradient(meanprof_log_stack, 0.025)

        # print("meanprof",meanprof)

        # print('after meanprof calculation')

        r200m = 2895

        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        c.scatter(rlogbin_cen / r200m, meanprof_log_stack, ls="solid", marker='.', color='red')
        c.errorbar(rlogbin_cen / r200m, meanprof_log_stack, yerr=stdprof_log_stack, ls="solid", marker='.',color='darkred', label="Stacking over 100 random projection (mean)")
        c.scatter(rlogbin_cen / r200m, meanprof_log, ls="dotted", marker='.', color='orangered')
        c.errorbar(rlogbin_cen / r200m, meanprof_log, yerr=stdprof_log, ls="dotted", marker='.', color='orangered',label="Cen projection (mean)")
        c.scatter(rlogbin_cen / r200m, medianprof_log, ls="dashed", marker='.', color='orange')
        c.errorbar(rlogbin_cen / r200m, medianprof_log, yerr=madprof_log, ls="dashed", marker='.', color='orange',label="Cen projection (median)")
        # c.plot(rlogbin_cen, meanprof_log, ls="dotted", marker='.')
        c.set_xlim(0.3, 4.9)
        c.set_xscale("log")
        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        c.xaxis.set_ticklabels([])
        c.set_ylabel('$log_{10}(EM~[\mathrm{cm^{-6}~Mpc}])$', size=22)
        c.set_title('Emission measure radial profile',size=22)
        c.axvline(x=1, color='grey', ls='dashed') #, label="$R_{200m}$")
        c.axvline(x=1.337, color='orangered', ls='dashed') #, label="$R_{sp,EM}$")
        c.set_ylim(-15, -5.5)
        c.legend()

        d.plot(rlogbin_cen / r200m, grad_stack, ls="solid", marker='.', color='darkred')
        d.plot(rlogbin_cen / r200m, grad, ls="dotted", marker='.', color='orangered')
        d.plot(rlogbin_cen / r200m, grad_med, ls="dashed", marker='.', color='orange')
        #d.plot(rlogbin_cen, grad, ls="dotted", marker='.')
        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        d.set_xlabel("$R/R_{200m}$", size=16)
        d.axvline(x=1, color='grey', ls='dashed', label="$R_{200m}$")
        d.axvline(x=1.337, color='orangered', ls='dashed', label="$R_{sp,EM}$")

        d.set_xscale('log')
        d.set_xlim(0.3, 4.9)
        d.set_ylim(-12.5, 2)
        d.set_ylabel('$\\frac{dlog_{10}(EM)}{dlog_{10}(r)}$', size=22)  # code à copier ds plot : $\frac{dlog_{10}(EM)}{dlog_{10}(r)}$
        d.legend()

        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()

        sys.exit()

    if (type=="y" and plot==1):

        meanprof_log = np.load("y_proj_profile.npy")
        stdprof_log = np.load("y_proj_profile_std.npy")

        meanprof_log_stack = np.load("./maps/high_res/random_proj/y/y_sum100_proj_profile_mean.npy")
        stdprof_log_stack = np.load("./maps/high_res/random_proj/y/y_sum100_proj_profile_std.npy")

        medianprof_log = np.load("y_proj_profile_med.npy")
        madprof_log = np.load("y_proj_profile_mad.npy")


        grad = np.gradient(meanprof_log, 0.025)
        grad_med = np.gradient(medianprof_log, 0.025)
        grad_stack = np.gradient(meanprof_log_stack, 0.025)

        # print("meanprof",meanprof)

        # print('after meanprof calculation')

        r200m = 2895

        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        c.scatter(rlogbin_cen / r200m, meanprof_log_stack, ls="solid", marker='.', color='blue')
        c.errorbar(rlogbin_cen / r200m, meanprof_log_stack, yerr=stdprof_log_stack, ls="solid", marker='.', color='blue', label="Stacking over 100 random projection (mean)")

        c.scatter(rlogbin_cen / r200m, meanprof_log, ls="dotted", marker='.', color='darkturquoise')
        c.errorbar(rlogbin_cen / r200m, meanprof_log, yerr=stdprof_log, ls="dotted", marker='.', color='darkturquoise',label="Cen projection (mean)")

        c.scatter(rlogbin_cen / r200m, medianprof_log, ls="dashed", marker='.', color='skyblue')
        c.errorbar(rlogbin_cen / r200m, medianprof_log, yerr=madprof_log, ls="dashed", marker='.', color='forestgreen',label="Cen projection (median)")

        # c.plot(rlogbin_cen, meanprof_log, ls="dotted", marker='.')
        c.set_xlim(0.3, 4.9)
        c.set_xscale("log")
        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        c.xaxis.set_ticklabels([])
        c.set_ylabel('$log_{10}(y)$', size=22)
        c.set_title('$y$ radial profile',size=22)

        c.legend(loc='lower left')

        c.axvline(x=1, color='grey', ls='dashed')#, label="$R_{200m}=2.9Mpc$")
        c.axvline(x=1.682, color='darkturquoise', ls='dashed')#, label="$R_{sp,Compton-y}\sim4.9Mpc$")

        d.plot(rlogbin_cen / r200m, grad_stack, ls="solid", marker='.', color='blue')
        d.plot(rlogbin_cen / r200m, grad, ls="dotted", marker='.', color='darkturquoise')
        d.plot(rlogbin_cen / r200m, grad_med, ls="dashed", marker='.', color='forestgreen')
        # d.plot(rlogbin_cen, grad, ls="dotted", marker='.')
        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        d.set_xlabel("$R/R_{200m}$", size=22)

        d.set_xscale('log')
        d.set_xlim(0.3, 4.9)
        #d.set_ylim(-10, 1)
        d.set_ylabel('$\\frac{dlog_{10}(y)}{dlog_{10}(r)}$', size=22)  # code à copier ds plot : $\frac{dlog_{10}(y_c)}{dlog_{10}(r)}$

        d.axvline(x=1, color='grey', ls='dashed', label="$R_{200m}$")
        d.axvline(x=1.682, color='turquoise', ls='dashed', label="$R_{sp,y}$")
        d.legend(loc='lower left')

        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()

        sys.exit()

    if (type=="y"):

        file = './maps/high_res/map_high_19_cen_y_los.bin'
        #file_stack = './maps/high_res/random_proj/map_high_19_rand_sum100_y_los.bin'

    if (type=="sd"):

        #file = './maps/high_res/random_proj/sd_bar/map_high_19_rand_01_sd_bar_los.bin'
        file = './maps/high_res/map_high_19_cen_SD_bar_los.bin'

    if (type=="em"):

        file = './maps/high_res/map_high_19_cen_EM_los.bin'
        #file = './maps/high_res/random_proj/em/map_high_19_rand_01_em_los.bin'

    h = FortranFile(file, 'r')
    map = h.read_reals()
    # map=[]
    # nline=h.read_ints()
    # print("nline",nline)
    # nline = 16
    # sys.exit()
    # for i in range(nline):
    # print(i)
    # m=h.read_reals()
    # print("m",m)
    # sys.exit()
    # map=np.concatenate((map,m))
    # map=np.array(map)
    print("len map", len(map))
    print("map", map)
    # sys.exit()
    px = np.int_(np.sqrt(len(map)))
    print("nbr px per line", px)
    # sys.exit()
    # plt.hist(map,bins=100)
    # plt.show()
    map = np.reshape(map, (px, px))
    print('file loaded')

    if (type=="sd"):

        file = './maps/high_res/map_high_19_cen_SD_DM_los.bin'
        #file = './maps/high_res/random_proj/sd_dm/map_high_19_rand_01_sd_dm_los.bin'

        h2 = FortranFile(file, 'r')
        map2 = h2.read_reals()
        print("len map", len(map2))
        print("map", map2)
        px = np.int_(np.sqrt(len(map2)))
        #print("nbr px per line", px)
        map2 = np.reshape(map2, (px, px))
        print('file 2 loaded')

        map = map + map2

    d = np.load('maps/map_distances_1.4065.npy')

    #print("d",d)
    #print("max d",np.max(d))

    n = 90

    rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])
    rlogbin = np.array([10 ** ((92 + i) * 0.025) for i in range(n+1)])
    rlog = np.log10(rlogbin)

    #print("rlogbin",rlogbin)

    #sys.exit()


    meanprof = np.zeros(n)
    stdprof = np.zeros(n)
    medprof = np.zeros(n)
    madprof = np.zeros(n)

    for n in range(30,60):

        print("n",n)

        #print('rlogbin_cen',rlogbin_cen[42:45])
        #print('rlogbin',rlogbin[42:45])

        map_4243= map[np.logical_and(d > rlog[n], d < rlog[n+1])]
        mean= np.nanmean(map_4243)
        median = np.nanmedian(map_4243)
        #print("mean",mean)
        #print("median",median)

        #cdf_test=np.cumsum(map_4243)

        #plt.plot(cdf_test)

        plt.hist(np.log10(map_4243),bins=100,log=True,color='grey',density=True)

        plt.axvline(x=np.log10(median), color='black', ls='dashed', label='median')#,alpha=0.5)
        plt.axvline(x=np.log10(mean), color='red', ls='dashed', label='mean',alpha=0.5)

        inf = rlogbin[n]/1000
        sup = rlogbin[n+1]/1000

        titre = 'SD distribution in [' + str(round(inf,2)) + ',' + str(round(sup,2)) + ']Mpc'

        #plt.axvline(x=18745385, color='black', ls='dashed', label='median')
        #plt.axvline(x=16929347, color='red', ls='dashed', label='mean')
        plt.title(titre)
        plt.xlabel("$log_{10}(SD[M_{\odot}/kpc^2])$")
        plt.ylabel("$N_{px}$")
        plt.xlim(4,12)
        plt.ylim(1e-5,5e0)

        #plt.hist(map_4243, bins=100, color='darkorange')
        #plt.axvline(x=3.405e-10, color='black', ls='dashed', label='median')
        #plt.axvline(x=3.745e-10, color='red', ls='dashed', label='mean')
        #plt.title('EM distribution in [2.37,2.51]Mpc')
        #plt.xlabel("$EM[cm^{-6}Mpc]$")
        #plt.ylabel("$N_{px}$")

        #plt.hist(map_4243, bins=100, color='darkturquoise')
        #plt.axvline(x=10 ** (-6.49), color='black', ls='dashed', label='median')
        #plt.axvline(x=10 ** (-6.37), color='red', ls='dashed', label='mean')
        #plt.axvline(x=3.849e-7, color='black', ls='dashed', label='median')
        #plt.axvline(x=3.83e-7, color='red', ls='dashed', label='mean')
        #plt.title('$y_c$ distribution in [2.37,2.51]Mpc')
        #plt.xlabel("$y_c$")
        #plt.ylabel("$N_{px}$")


        savefile = "./sectors_study/splashback/sd_dist/sd_dist_"+str(n)+".png"

        plt.legend()
        plt.tight_layout()
        #plt.show()

        #sys.exit()
        plt.savefig(savefile)

        plt.clf()

    sys.exit()
    #plt.show()
    #sys.exit()

    #for i in range(0, n):
        #print(i)

        #cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)

        # cond = np.logical_and(rlog > (i + 35) * 0.05,np.logical_and(rlog < (i + 36) * 0.05, np.logical_and(x < 0, np.logical_and(y > 0, z > 0))))

        #cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)  # new binning
        #cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025, np.logical_and(x > x_cen, np.logical_and(y > y_cen,z > z_cen))))  # new binning

    print('before meanprof calculation')

    map[map==0]=np.nan

    #map = np.log10(map)

    meanprof = np.array([np.nanmean(map[np.logical_and(d > rlog[i], d < rlog[i + 1])]) for i in range(n)])
    stdprof = np.array([np.nanstd(map[np.logical_and(d > rlog[i], d < rlog[i + 1])]) for i in range(n)])

    medprof = np.array([np.nanmedian(map[np.logical_and(d > rlog[i], d < rlog[i + 1])]) for i in range(n)])
    madprof = np.array([np.median(np.abs(map[np.logical_and(d > rlog[i], d < rlog[i + 1])]-medprof[i])) for i in range(n)])
    #err_p[i] = np.median(np.abs(p_sum_log - p_rad_log[i]))

    #print("mean prof", meanprof)
    #print("std prof",stdprof)

    stdprof = stdprof / (np.log(10)*meanprof)
    meanprof = np.log10(meanprof)


    madprof = madprof / (np.log(10)*medprof)
    medprof = np.log10(medprof)



    #sys.exit()

    #meanprof_log = np.log10(meanprof)
    #stdprof_log = stdprof/meanprof

    file_name_mean = type + "_proj_profile_mean_01.npy"
    file_name_std = type + "_proj_profile_std_01.npy"
    file_name_med = type + "_proj_profile_med_01.npy"
    file_name_mad = type + "_proj_profile_mad_01.npy"

    np.save(file_name_mean, meanprof)
    np.save(file_name_std, stdprof)
    np.save(file_name_med, medprof)
    np.save(file_name_mad, madprof)

    #np.save()

    print("profile saved")

    sys.exit()

    #meanprof_log = np.load("SD_proj_profile.npy")

    grad = np.gradient(meanprof_log,0.025)


    #print("meanprof",meanprof)

    #print('after meanprof calculation')

    r200m = 2895

    f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

    c.plot(rlogbin_cen/r200m,meanprof_log,ls="dotted",marker='.')
    #c.plot(rlogbin_cen, meanprof_log, ls="dotted", marker='.')
    c.set_xlim(0.3,10)
    c.set_xscale("log")
    c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    c.xaxis.set_ticklabels([])


    d.plot(rlogbin_cen/r200m,grad,ls="dotted",marker='.')
    #d.plot(rlogbin_cen, grad, ls="dotted", marker='.')
    d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    d.set_xlabel("$R/R_{200m}$", size=16)

    d.set_xscale('log')
    d.set_xlim(0.3, 10)

    plt.subplots_adjust(wspace=0, hspace=0)
    plt.show()

    sys.exit()

def vrad_r_phase_space():

    def phase_space_DM():
        file_name = '/data/cluster/tlebeau/virgo/virgo_xyz_dm_high_res.dat'
        d = FortranFile(file_name, 'r')

        # print('fichier dm ouvert')

        ncell = d.read_ints()
        # x = d.read_reals()
    # y = d.read_reals()
    # z = d.read_reals()

    # print("fichier lu")

    # print("n dm cell", ncell)

        x, y, z, m, vx, vy, vz = ftp.f90_to_py.read_dm(ncell, file_name)

        print('data loaded')

        r = np.sqrt(x ** 2 + y ** 2 + z ** 2)

        #plt.hist(x)
    #plt.yscale('log')
    #plt.xscale('log')
    #plt.show()

    #sys.exit()


    # v_pec = np.sqrt(vx_gal**2 + vy_gal**2 + vz_gal**2)

    # H0 = cosmo.H(0).to_value('km/s/Mpc')

        H0 = 67.74

        # print(H0)

    # sys.exit()

    #x_gal_0 = x_gal - x_cen
    #y_gal_0 = y_gal - y_cen
    #z_gal_0 = z_gal - z_cen

    # plt.hist(x_gal_0)
    # plt.show()
    # sys.exit()

        #plt.hist(r)
        #plt.show()
        #sys.exit()

        v_pec = (x * vx + y* vy + z * vz) / r
        v_rad = v_pec + H0 * r * 1e-3

        r_car = 2895

        r_plot = r / r_car

        #cond = np.logical_and(x>0,np.logical_and(y<0,z<0))

        #plt.hist2d(r[cond], v_rad[cond], bins=200, range=[[0,5000],[-2000,2000]],density=True,cmap='inferno')
        #plt.colorbar()
        #plt.show()

        #sys.exit()

        return x , y , z , r , v_rad


    def phase_space_baryons():
        #file_name = "/data/cluster/tlebeau/virgo/virgo_xyz_hydro_l21.dat"
        file_name = "/data/cluster/tlebeau/virgo/virgo_xyz_hydro_l21_gal_clean_m1e8.5.dat"
        h = FortranFile(file_name, 'r')

        ncell = h.read_ints()

        n_e = h.read_reals()
        t = h.read_reals()
        p = h.read_reals()
        x = h.read_reals()
        y = h.read_reals()
        z = h.read_reals()
        vx = h.read_reals()
        vy = h.read_reals()
        vz = h.read_reals()
        m = h.read_reals()
        lvl = h.read_reals()

        #print("x",x[0:10])
        #print("vx",vx[0:10])

        print('data loaded')

        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        # print("x",x)

        # print("x_cen",x_cen,'y_cen',y_cen,'z_cen',z_cen)
        # sys.exit()

        x = x - x_cen
        y = y - y_cen
        z = z - z_cen

        r = np.sqrt(x ** 2 + y ** 2 + z ** 2)

        #print("r",r[0:10])

        H0 = 67.74


        v_pec = (x * vx + y * vy + z * vz) / r
        v_rad = v_pec + H0 * r * 1e-3

        #print('min',np.min(v_rad))
        #print('max',np.max(v_rad))
        #sys.exit()

        #plt.hist(r)
        #plt.show()
        #sys.exit()

        r_car = 2895

        r_plot = r / r_car

        #cond = np.logical_and(x > 0, np.logical_and(y < 0, z < 0))

        #plt.hist2d(r, v_rad, bins=100, range=[[0, 5000], [-2000, 2000]], density=True, cmap='YlOrRd')
        #plt.colorbar()
        #plt.show()

        #sys.exit()

        return x , y , z , r , v_rad, t

    x_bar, y_bar, z_bar, r_bar, v_rad_bar, t= phase_space_baryons()
    #x_DM, y_DM, z_DM, r_DM, v_rad_DM = phase_space_DM()

    #r_tot = np.append(r_bar,r_DM)
    #v_rad_tot = np.append(v_rad_bar,v_rad_DM)
    #x_tot = np.append(x_bar,x_DM)
    #y_tot = np.append(y_bar,y_DM)
    #z_tot = np.append(z_bar,z_DM)

    r_tot = r_bar
    v_rad_tot = v_rad_bar
    x_tot = x_bar
    y_tot = y_bar
    z_tot = z_bar

    print("data processed")


    #cond_sph = np.logical_and(x_tot > 0, np.logical_and(y_tot > 0, z_tot > 0))
    #cond_rel = np.logical_and(x_tot < 0, np.logical_and(y_tot < 0, z_tot < 0))
    #cond_fil = np.logical_and(x_tot > 0, np.logical_and(y_tot < 0, z_tot < 0))

    cond_sph = np.logical_and(x_tot > 0, np.logical_and(y_tot > 0, np.logical_and(z_tot > 0,t>1e5)))
    cond_rel = np.logical_and(x_tot < 0, np.logical_and(y_tot < 0, np.logical_and(z_tot < 0,t>1e5)))
    cond_fil = np.logical_and(x_tot > 0, np.logical_and(y_tot < 0, np.logical_and(z_tot < 0,t>1e5)))


    f, ((a, c), (b, d)) = plt.subplots(2, 2, figsize=(16,9))

    a.hist2d(r_tot, v_rad_tot, bins=[100,50], range=[[0, 4999], [-2000, 2000]], density=True, cmap='hot')

    a.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    a.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    a.set_ylabel("$v_{rad}~[\mathrm{km~s^{-1}}]$",size=16)
    a.xaxis.set_ticklabels([])
    a.axhline(y=0, color='white', ls='dashed')
    a.text(500, 1500, "$Full\,Material$", size=24, color='white')
    a.axvline(x=2895, color='white', ls='dotted')
    #a.text(2895, -1900, "$R_{200m}$", size=16, color='white',rotation=90)
    a.axvline(x=2147, color='white', ls='dotted')
    #a.text(2147, -1900, "$R_{vir}$", size=16, color='white',rotation=90)



    b.hist2d(r_tot[cond_rel], v_rad_tot[cond_rel], bins=[100,50], range=[[0, 4999], [-2000, 1999]], density=True, cmap='hot')

    b.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    b.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    b.set_xlabel("$R~$[kpc]", size=16)
    b.set_ylabel("$v_{rad}~[\mathrm{km~s^{-1}}]$", size=16)
    #b.yaxis.set_ticklabels([])
    b.axhline(y=0, color='white', ls='dashed')
    b.text(500, 1500, "$Outflowing\,Material$", size=24, color='white')
    b.axvline(x=2895, color='white', ls='dotted')
    b.text(2695, -1900, "$R_{200m}$", size=16, color='white', rotation=90)
    b.axvline(x=2147, color='white', ls='dotted')
    b.text(1947, -1900, "$R_{vir}$", size=16, color='white', rotation=90)



    c.hist2d(r_tot[cond_fil], v_rad_tot[cond_fil], bins=[100,50], range=[[0, 5000], [-2000, 2000]], density=True, cmap='hot')

    c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    c.xaxis.set_ticklabels([])
    c.yaxis.set_ticklabels([])
    c.axhline(y=0, color='white', ls='dashed')
    c.text(500, 1500, "$Filament\,Material$", size=24, color='white')
    c.axvline(x=2895, color='white', ls='dotted')
    #c.text(2695, -1900, "$R_{200m}$", size=16, color='white', rotation=90)
    c.axvline(x=2147, color='white', ls='dotted')
    #c.text(1947, -1900, "$R_{vir}$", size=16, color='white', rotation=90)



    d.hist2d(r_tot[cond_sph], v_rad_tot[cond_sph], bins=[100,50], range=[[0, 5000], [-2000, 1999]], density=True, cmap='hot')

    d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    d.set_xlabel("$R~$[kpc]", size=16)
    d.yaxis.set_ticklabels([])
    #d.xaxis.set_ticklabels([])
    d.axhline(y=0, color='white', ls='dashed')
    d.text(500, 1500, "$Collapsing\,Material$", size=24, color='white')
    d.axvline(x=2895, color='white', ls='dotted')
    d.text(2695, -1900, "$R_{200m}$", size=16, color='white', rotation=90)
    d.axvline(x=2147, color='white', ls='dotted')
    d.text(1947, -1900, "$R_{vir}$", size=16, color='white', rotation=90)

    plt.subplots_adjust(wspace=0.005, hspace=0.01)
    #plt.suptitle('Baryons and DM' )

    plt.savefig('./papers_plots/paper_2_splashback/phase_space_diag_5.png',dpi=300,format='png')
    print('plot saved')

    #plt.show()


    sys.exit()

def r_sp_proj_stack(type,plot):

    n = 90

    rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

    if (type=="sd" and plot==1):

        meanprof_log = np.load("SD_proj_profile.npy")
        stdprof_log = np.load("SD_proj_profile_std.npy")

        medianprof_log = np.load("SD_proj_profile_med.npy")
        madprof_log = np.load("SD_proj_profile_mad.npy")

        meanprof_log_stack = np.load("SD_stacked_proj_profile.npy")
        stdprof_log_stack = np.load("SD_stacked_proj_profile_std.npy")

        grad = np.gradient(meanprof_log, 0.025)
        grad_med = np.gradient(medianprof_log, 0.025)
        grad_stack = np.gradient(meanprof_log_stack, 0.025)

        print("grad",grad)

        rms_mean = np.sqrt(np.nanmean(grad**2))
        rms_med = np.sqrt(np.nanmean(grad_med**2))
        rms_stack = np.sqrt(np.nanmean(grad_stack**2))

        print("rms mean",rms_mean,"rms med",rms_med,"rms stack",rms_stack)
        sys.exit()

        # print("meanprof",meanprof)

        # print('after meanprof calculation')

        r200m = 2895

        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        #c.plot(rlogbin_cen / r200m, meanprof_log, ls="dotted", marker='.', color='black')
        c.scatter(rlogbin_cen / r200m, meanprof_log, ls="dotted", marker='.',color='black')
        c.errorbar(rlogbin_cen / r200m, meanprof_log, yerr=stdprof_log, ls="dotted", marker='.', color='black',label="Cen projection (mean)")
        c.scatter(rlogbin_cen / r200m, medianprof_log, ls="dashed", marker='.', color='grey')
        c.errorbar(rlogbin_cen / r200m, medianprof_log, yerr=madprof_log, ls="dashed", marker='.', color='dimgrey',label="Cen projection (median)")
        c.scatter(rlogbin_cen / r200m, meanprof_log_stack, ls="dotted", marker='.', color='brown')
        c.errorbar(rlogbin_cen / r200m, meanprof_log_stack, yerr=stdprof_log_stack, ls="dotted", marker='.', color='brown',label="Stacking over 100 random projections (mean)")

        #plt.scatter(rlogbin_cen, 10 ** t_all, s=6, c='black')
        #plt.errorbar(rlogbin_cen, 10 ** t_all, yerr=10 ** t_all * err_t_all, ls='dashed', label='Full box', alpha=0.7, c='black')
        # c.plot(rlogbin_cen, meanprof_log, ls="dotted", marker='.')
        c.set_xlim(0.3, 4.9)
        c.set_ylim(0, 12)
        c.set_xscale("log")
        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        c.xaxis.set_ticklabels([])
        c.set_ylabel('$log_{10}(SD[M_{\odot}/kpc^2])$', size=16)
        c.set_title('Surface Density radial profile')
        c.axvline(x=1, color='grey', ls='dashed')
        c.axvline(x=1.126, color='black', ls='dashed')
        c.legend(loc="lower left")

        d.plot(rlogbin_cen / r200m, grad, ls="dotted", marker='.',color='black')
        d.plot(rlogbin_cen / r200m, grad_med, ls="dashed", marker='.',color='dimgrey')
        d.plot(rlogbin_cen / r200m, grad_stack, ls="dotted", marker='.',color='brown')
        # d.plot(rlogbin_cen, grad, ls="dotted", marker='.')
        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        d.set_xlabel("$R/R_{200m}$", size=16)

        d.set_xscale('log')
        d.set_xlim(0.3, 4.9)
        d.set_ylabel('$\\frac{dlog_{10}(SD)}{dlog_{10}(r)}$', size=16)  # code à copier ds plot : $\frac{dlog_{10}(SD)}{dlog_{10}(r)}$

        d.axvline(x=1, color='grey', ls='dashed',label="$R_{200m}$")
        d.axvline(x=1.126, color='black', ls='dashed', label="$R_{sp,SD}$")
        d.legend()

        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()

        sys.exit()

    if (type=="em" and plot==1):

        meanprof_log = np.load("EM_proj_profile.npy")
        stdprof_log = np.load("EM_proj_profile_std.npy")

        medianprof_log = np.load("EM_proj_profile_med.npy")
        madprof_log = np.load("EM_proj_profile_mad.npy")

        meanprof_log_stack = np.load("EM_stacked_proj_profile.npy")
        stdprof_log_stack = np.load("EM_stacked_proj_profile_std.npy")

        print("std prof log",stdprof_log)

        #sys.exit()

        grad = np.gradient(meanprof_log, 0.025)
        grad_med = np.gradient(medianprof_log, 0.025)
        grad_stack = np.gradient(meanprof_log_stack, 0.025)

        # print("meanprof",meanprof)

        # print('after meanprof calculation')

        r200m = 2895

        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        c.scatter(rlogbin_cen / r200m, meanprof_log, ls="dotted", marker='.', color='orangered')
        c.errorbar(rlogbin_cen / r200m, meanprof_log, yerr=stdprof_log, ls="dotted", marker='.', color='orangered',label="Cen projection (mean)")
        c.scatter(rlogbin_cen / r200m, medianprof_log, ls="dotted", marker='.', color='orange')
        c.errorbar(rlogbin_cen / r200m, medianprof_log, yerr=madprof_log, ls="dotted", marker='.', color='orange',label="Cen projection (median)")
        c.scatter(rlogbin_cen / r200m, meanprof_log_stack, ls="dotted", marker='.', color='red')
        c.errorbar(rlogbin_cen / r200m, meanprof_log_stack, yerr=stdprof_log_stack, ls="dotted", marker='.', color='darkred',label="Stacking over 100 random projection (mean)")
        # c.plot(rlogbin_cen, meanprof_log, ls="dotted", marker='.')
        c.set_xlim(0.3, 4.9)
        c.set_xscale("log")
        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        c.xaxis.set_ticklabels([])
        c.set_ylabel('$log_{10}(EM[cm^{-6}Mpc])$', size=16)
        c.set_title('Emission measure radial profile')
        c.axvline(x=1, color='grey', ls='dashed') #, label="$R_{200m}$")
        c.axvline(x=1.3458, color='orangered', ls='dashed') #, label="$R_{sp,EM}$")
        c.set_ylim(-15, -5.5)
        c.legend()

        d.plot(rlogbin_cen / r200m, grad, ls="dotted", marker='.', color='orangered')
        d.plot(rlogbin_cen / r200m, grad_med, ls="dashed", marker='.', color='orange')
        d.plot(rlogbin_cen / r200m, grad_stack, ls="dotted", marker='.', color='darkred')
        # d.plot(rlogbin_cen, grad, ls="dotted", marker='.')
        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        d.set_xlabel("$R/R_{200m}$", size=16)
        d.axvline(x=1, color='grey', ls='dashed', label="$R_{200m}$")
        d.axvline(x=1.3458, color='orangered', ls='dashed', label="$R_{sp,EM}$")

        d.set_xscale('log')
        d.set_xlim(0.3, 4.9)
        d.set_ylim(-10, 2)
        d.set_ylabel('$\\frac{dlog_{10}(EM)}{dlog_{10}(r)}$', size=16)  # code à copier ds plot : $\frac{dlog_{10}(EM)}{dlog_{10}(r)}$
        d.legend()

        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()

        sys.exit()

    if (type=="y" and plot==1):

        meanprof_log = np.load("y_proj_profile.npy")
        stdprof_log = np.load("y_proj_profile_std.npy")

        meanprof_log_stack = np.load("y_proj_profile_stack_100.npy")
        stdprof_log_stack = np.load("y_proj_profile_std_stack_100.npy")

        medianprof_log = np.load("y_proj_profile_med.npy")
        madprof_log = np.load("y_proj_profile_mad.npy")


        grad = np.gradient(meanprof_log, 0.025)
        grad_med = np.gradient(medianprof_log, 0.025)
        grad_stack = np.gradient(meanprof_log_stack, 0.025)

        # print("meanprof",meanprof)

        # print('after meanprof calculation')

        r200m = 2895

        f, (c, d) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [2, 2]})

        c.scatter(rlogbin_cen / r200m, meanprof_log, ls="dotted", marker='.', color='turquoise')
        c.errorbar(rlogbin_cen / r200m, meanprof_log, yerr=stdprof_log, ls="dotted", marker='.', color='turquoise',label="Cen projection (mean)")

        c.scatter(rlogbin_cen / r200m, meanprof_log_stack, ls="dotted", marker='.', color='blue')
        c.errorbar(rlogbin_cen / r200m, meanprof_log_stack, yerr=stdprof_log_stack, ls="dotted", marker='.', color='blue',label="Stacking over 100 random projection (mean)")

        c.scatter(rlogbin_cen / r200m, medianprof_log, ls="dotted", marker='.', color='skyblue')
        c.errorbar(rlogbin_cen / r200m, medianprof_log, yerr=madprof_log, ls="dotted", marker='.', color='skyblue',label="Cen projection (median)")

        # c.plot(rlogbin_cen, meanprof_log, ls="dotted", marker='.')
        c.set_xlim(0.3, 4.9)
        c.set_xscale("log")
        c.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        c.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        c.xaxis.set_ticklabels([])
        c.set_ylabel('$log_{10}(y_c)$', size=16)
        c.set_title('$y_c$ radial profile')

        c.legend(loc='lower left')

        c.axvline(x=1, color='grey', ls='dashed')#, label="$R_{200m}=2.9Mpc$")
        c.axvline(x=1.682, color='turquoise', ls='dashed')#, label="$R_{sp,Compton-y}\sim4.9Mpc$")

        d.plot(rlogbin_cen / r200m, grad, ls="dotted", marker='.', color='turquoise')
        d.plot(rlogbin_cen / r200m, grad_stack, ls="dotted", marker='.', color='blue')
        d.plot(rlogbin_cen / r200m, grad_med, ls="dotted", marker='.', color='skyblue')
        # d.plot(rlogbin_cen, grad, ls="dotted", marker='.')
        d.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
        d.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,
                      labelleft=True)
        d.set_xlabel("$R/R_{200m}$", size=16)

        d.set_xscale('log')
        d.set_xlim(0.3, 4.9)
        #d.set_ylim(-10, 1)
        d.set_ylabel('$\\frac{dlog_{10}(y_c)}{dlog_{10}(r)}$', size=16)  # code à copier ds plot : $\frac{dlog_{10}(y_c)}{dlog_{10}(r)}$

        d.axvline(x=1, color='grey', ls='dashed', label="$R_{200m}$")
        d.axvline(x=1.682, color='turquoise', ls='dashed', label="$R_{sp,y_c}$")
        d.legend(loc='lower left')

        plt.subplots_adjust(wspace=0, hspace=0)
        plt.show()

        sys.exit()

    d = np.load('maps/map_distances_1.4065.npy')

    stacked_mean_prof = np.zeros((100,n))
    stacked_median_prof = np.zeros((100,n))

    for i in range(0,100):
        print("i",i)


        #if (type=="y"):

            #file = './maps/high_res/map_high_19_cen_y_los.bin'
            #file_stack = './maps/high_res/random_proj/map_high_19_rand_sum100_y_los.bin'

        #if (type=="sd"):

            #file = './maps/high_res/random_proj/sd_bar/map_high_19_rand_sum100_sd_bar_los.bin'

        #if (type=="em"):

            #file = './maps/high_res/map_high_19_cen_EM_los.bin'
            #file = './maps/high_res/random_proj/em/map_high_19_rand_sum100_em_los.bin'
        if i<10:
            file = './maps/high_res/random_proj/' + type + '/map_high_19_rand_0' + str(i) + '_' + type + '_los.bin'
        else :
            file = './maps/high_res/random_proj/' + type + '/map_high_19_rand_' + str(i) + '_' + type + '_los.bin'
        if type == "sd":
            if i<10:
                file = './maps/high_res/random_proj/sd_bar/map_high_19_rand_0' + str(i) + '_sd_bar_los.bin'
            else:
                file = './maps/high_res/random_proj/sd_bar/map_high_19_rand_' + str(i) + '_sd_bar_los.bin'





        print('file', file)

        #sys.exit()

        h = FortranFile(file, 'r')
        map = h.read_reals()
        # map=[]
        # nline=h.read_ints()
        # print("nline",nline)
        # nline = 16
        # sys.exit()
        # for i in range(nline):
        # print(i)
        # m=h.read_reals()
        # print("m",m)
        # sys.exit()
        # map=np.concatenate((map,m))
        # map=np.array(map)
        #print("len map", len(map))
        #print("map", map)
        # sys.exit()
        px = np.int_(np.sqrt(len(map)))
        #print("nbr px per line", px)
        # sys.exit()
        # plt.hist(map,bins=100)
        # plt.show()
        map = np.reshape(map, (px, px))
        #print('file loaded')

        if (type=="sd"):

            if i<10:
                file = './maps/high_res/random_proj/sd_dm/map_high_19_rand_0' + str(i) + '_sd_dm_los.bin'
            else:
                file = './maps/high_res/random_proj/sd_dm/map_high_19_rand_' + str(i) + '_sd_dm_los.bin'

            h2 = FortranFile(file, 'r')
            map2 = h2.read_reals()
            #print("len map", len(map2))
            #print("map", map2)
            px = np.int_(np.sqrt(len(map2)))
            #print("nbr px per line", px)
            map2 = np.reshape(map2, (px, px))
            print('file 2 loaded')

            map = map + map2

        #print("d",d)
        #print("max d",np.max(d))



        rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])
        rlogbin = np.array([10 ** ((92 + i) * 0.025) for i in range(n+1)])
        rlog = np.log10(rlogbin)

        #print("rlogbin",rlogbin)

        #sys.exit()


        meanprof = np.zeros(n)
        stdprof = np.zeros(n)
        medprof = np.zeros(n)
        madprof = np.zeros(n)

        #for i in range(0, n):
            #print(i)

            #cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)

            # cond = np.logical_and(rlog > (i + 35) * 0.05,np.logical_and(rlog < (i + 36) * 0.05, np.logical_and(x < 0, np.logical_and(y > 0, z > 0))))

            #cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)  # new binning
            #cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025, np.logical_and(x > x_cen, np.logical_and(y > y_cen,z > z_cen))))  # new binning

        #print('profs calculation')

        map[map==0]=np.nan

        #map = np.log10(map)

        meanprof = np.array([np.nanmean(map[np.logical_and(d > rlog[i], d < rlog[i + 1])]) for i in range(n)])
        stdprof = np.array([np.nanstd(map[np.logical_and(d > rlog[i], d < rlog[i + 1])]) for i in range(n)])

        medprof = np.array([np.nanmedian(map[np.logical_and(d > rlog[i], d < rlog[i + 1])]) for i in range(n)])
        madprof = np.array([np.median(np.abs(map[np.logical_and(d > rlog[i], d < rlog[i + 1])]-medprof[i])) for i in range(n)])
        #err_p[i] = np.median(np.abs(p_sum_log - p_rad_log[i]))

        #print("mean prof", meanprof)
        #print("std prof",stdprof)

        stdprof = stdprof / (np.log(10)*meanprof)
        meanprof = np.log10(meanprof)


        madprof = madprof / (np.log(10)*medprof)
        medprof = np.log10(medprof)



        #sys.exit()

        #meanprof_log = np.log10(meanprof)
        #stdprof_log = stdprof/meanprof

        if (i<10):
            file_name_mean = './maps/high_res/random_proj/' + type + "/" + type + "_0" + str(i) + "_proj_profile_mean.npy"
            file_name_std = './maps/high_res/random_proj/' + type + "/" + type + "_0" + str(i) +  "_proj_profile_std.npy"
            file_name_med = './maps/high_res/random_proj/' + type + "/" + type + "_0" + str(i) + "_proj_profile_med.npy"
            file_name_mad = './maps/high_res/random_proj/' + type + "/" + type + "_0" + str(i) + "_proj_profile_mad.npy"

        else:
            file_name_mean = './maps/high_res/random_proj/' + type + "/" + type + "_" + str(i) + "_proj_profile_mean.npy"
            file_name_std = './maps/high_res/random_proj/' + type + "/" + type + "_" + str(i) + "_proj_profile_std.npy"
            file_name_med = './maps/high_res/random_proj/' + type + "/" + type + "_" + str(i) + "_proj_profile_med.npy"
            file_name_mad = './maps/high_res/random_proj/' + type + "/" + type + "_" + str(i) + "_proj_profile_mad.npy"

        if type == "sd":
            if (i<10):
                file_name_mean = './maps/high_res/random_proj/sd_bar/' + type + "_0" + str(i) + "_proj_profile_mean.npy"
                file_name_std = './maps/high_res/random_proj/sd_bar/' + type + "_0" + str(i) + "_proj_profile_std.npy"
                file_name_med = './maps/high_res/random_proj/sd_bar/' + type + "_0" + str(i) + "_proj_profile_med.npy"
                file_name_mad = './maps/high_res/random_proj/sd_bar/' + type + "_0" + str(i) + "_proj_profile_mad.npy"

            else:
                file_name_mean = './maps/high_res/random_proj/sd_bar/' + type + "_" + str(i) + "_proj_profile_mean.npy"
                file_name_std = './maps/high_res/random_proj/sd_bar/' + type + "_" + str(i) + "_proj_profile_std.npy"
                file_name_med = './maps/high_res/random_proj/sd_bar/' + type + "_" + str(i) + "_proj_profile_med.npy"
                file_name_mad = './maps/high_res/random_proj/sd_bar/' + type + "_" + str(i) + "_proj_profile_mad.npy"


        #file_name_mean = type + "_proj_profile_mean.npy"
        #file_name_std = type + "_proj_profile_std.npy"
        #file_name_med = type + "_proj_profile_med.npy"
        #file_name_mad = type + "_proj_profile_mad.npy"

        np.save(file_name_mean, meanprof)
        np.save(file_name_std, stdprof)
        np.save(file_name_med, medprof)
        np.save(file_name_mad, madprof)

        stacked_mean_prof[i,:] = meanprof
        stacked_median_prof[i,:] = medprof







    #np.save()

    final_stacked_mean_prof = np.mean(stacked_mean_prof,axis=0)
    final_stacked_mean_prof_std = np.std(stacked_mean_prof, axis=0)
    final_stacked_median_prof = np.mean(stacked_median_prof,axis=0)
    final_stacked_median_prof_std = np.std(stacked_median_prof, axis=0)

    file_name_stack_mean_avg = './maps/high_res/random_proj/' + type + "/" + type + "_sum100_proj_profile_mean.npy"
    file_name_stack_mean_mean_std = './maps/high_res/random_proj/' + type + "/" + type + "_sum100_proj_profile_std.npy"
    file_name_stack_med_avg = './maps/high_res/random_proj/' + type + "/" + type + "_sum100_proj_profile_med.npy"
    file_name_stack_med_avg_std = './maps/high_res/random_proj/' + type + "/" + type + "_sum100_proj_profile_mad.npy"

    if type=="sd":
        file_name_stack_mean_avg = './maps/high_res/random_proj/sd_bar/' + type + "_sum100_proj_profile_mean.npy"
        file_name_stack_mean_mean_std = './maps/high_res/random_proj/sd_bar/' + type + "_sum100_proj_profile_std.npy"
        file_name_stack_med_avg = './maps/high_res/random_proj/sd_bar/' + type + "_sum100_proj_profile_med.npy"
        file_name_stack_med_avg_std = './maps/high_res/random_proj/sd_bar/' + type + "_sum100_proj_profile_mad.npy"

    np.save(file_name_stack_mean_avg, final_stacked_mean_prof)
    np.save(file_name_stack_mean_mean_std, final_stacked_mean_prof_std)
    np.save(file_name_stack_med_avg, final_stacked_median_prof)
    np.save(file_name_stack_med_avg_std, final_stacked_median_prof_std)

    print("profiles saved")

    #sys.exit()

def rsp_summary_column():
    #stats = {'Chandra sample': [0.7798459608865042, 0.018654519890114293],
             #'XMM sample': [0.780732135752321, 0.020483864000632738],
             #'Chandra free z-dependence': [0.8111976747717893, 0.020171516668287284],
             #'XMM free z-dependence': [0.80288984150501, 0.022053997714264563],
             #'Planck15 SZ': [0.785933240944345, 0.03965747630966077],
             #'Bocquet+19': [0.745, 0.042],
             #'Garrel+22': [0.882, 0.046],
             #'Costanzi+21': [0.796, [[0.038], [0.048]]],
             #'Amon+22': [0.772, 0.018],
             #'Heymans+21': [0.766, [[0.014], [0.020]]],
             #'Li+21': [0.769, [[0.034], [0.031]]],
             #'Planck18 CMB': [0.8339288569099189, 0.016069600307101223],
             #'Aiola+20': [0.840, 0.03],
             #'Balkenhol+23': [0.797, 0.042],
             #'Madhavacheril+23': [0.840, 0.028],

             #}
    stats = {
        'DM (Collapsing)':[3.4,0.2],
        'Gas (Col.)': [3.9, 0.2],
        'Pressure (Col.)': [4.3, 0.3],
        'Max entropy grad. (Col.)': [3.7, 0.2],
        'Min entropy grad. (Col.)': [4.3, 0.3],
        'DM (Outflowing)': [4.3, 0.3],
        'Gas (Out.)': [4.9, 0.3],
        'Pressure (Out.)': [5.5, 0.3],
        'Max entropy grad. (Out.)': [4.9, 0.3],
        'Min entropy grad. (Out.)': [5.5, 0.3],
        'Surface Density': [3.3, 0.2],
        'Emission Measure': [3.9, 0.2],
        'Compton-y': [4.9, 0.3],




    }
    #colors = ['tab:blue']
    colors = ['black','red','blue','pink','pink','black','red','blue','pink','pink','grey','orange','turquoise']
    plot_height = list(range(75, 4, -5))
    fig = plt.figure(figsize=(5, 5.5))
    ax = fig.add_subplot(1, 1, 1)
    ax.set_xlim(1, 6)
    plt.xticks(range(3,7))
    ax.set_ylim(12.5, 77.5)
    ax.set_xlabel('Splashback radii [Mpc]', fontsize=16)
    # ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    ax.spines["left"].set_visible(False)
    # ax.set_ylabel('Scale range')
    # ax.set_xticks(list(np.linspace(-8.,-2.,7)))
    # ax.set_xticks(list(np.linspace(-8.,-2.,31)), minor=True)
    plt.yticks(ticks=[])
    # ax.grid(which='minor', alpha=0.6, linestyle=':')
    # ax.grid(axis='x',which='major', alpha=0.6)
    # ax.grid(axis='y',which='major', alpha=0.8, linestyle='--')
    for i, m in enumerate(stats):
        if i < 9:
            ax.text(1.2, plot_height[i], m, fontsize=14, va='center', color='black')
        else:
            ax.text(1.2, plot_height[i], m, fontsize=14, va='center', color='black')#, weight='bold')

        #else:
        #ax.text(0.62, plot_height[i], m, fontsize=10, va='center', color='black')
        markers, caps, bars = ax.errorbar(stats[m][0], plot_height[i], xerr=stats[m][1], fmt='D', capsize=2,
                                          markeredgewidth=2, markersize=3, elinewidth=1.5,
                                          color=colors[i], ecolor=colors[i], capthick=1)

    ax.axhline(y=52.5, color='black', ls='dashed')
    ax.axhline(y=27.5, color='black', ls='dashed')
    #ax.axhline(y=32.5, color='black', ls='dashed')
        # [bar.set_alpha(0.7) for bar in bars]
        # [cap.set_alpha(0.7) for cap in caps]
    fig.tight_layout()
    #plt.savefig('/Users/gaspardaymerich/Desktop/PhD/Figures/S8.pdf')
    plt.show()



##### Project 3 : Filament in Virgo

def velocity_gradients(file):

    #file = './maps/high_res/filament/3D_fields/map_3D_high_19_xyz_mid3_bottom_right_map_vx_z_d0.08.bin'

    h = FortranFile(file, 'r')
    nx, ny, nz = h.read_ints()
    print("nx,ny,nz", nx, ny, nz)
    ncell = nx * ny * nz
    print("ncell", ncell)
    #sys.exit()
    map = np.zeros(ncell)

    map = ftp.f90_to_py.read_map_file(ncell, file)

    map = np.reshape(map, (nx, ny, nz),order='F')

    #plt.imshow(map[:, :, 30], cmap="Reds", origin='lower')
    #plt.colorbar()
    #plt.show()

    #sys.exit()

    grad_x = np.gradient(map, axis=0)
    grad_y = np.gradient(map, axis=1)
    grad_z = np.gradient(map, axis=2)

    #map = np.flip(map,axis=0)
    #map = np.flip(map,axis=1)
    #map = np.flip(map,axis=2)


    #print('grad_x shape',np.shape(grad_x))
    #print('grad_y shape',np.shape(grad_y))
    #print('grad_z shape',np.shape(grad_z))



    return grad_x, grad_y, grad_z

def velocity_operators():

    #print("calculating vx gradients")
    #dvx_dx,dvx_dy,dvx_dz = velocity_gradients('./maps/high_res/filament/3D_fields/map_3D_high_19_xyz_mid3_bottom_right_map_vx_z_d0.08.bin')
    #print("calculating vy gradients")
    #dvy_dx,dvy_dy,dvy_dz = velocity_gradients('./maps/high_res/filament/3D_fields/map_3D_high_19_xyz_mid3_bottom_right_map_vy_z_d0.08.bin')
    #print("calculating vz gradients")
    #dvz_dx,dvz_dy,dvz_dz = velocity_gradients('./maps/high_res/filament/3D_fields/map_3D_high_19_xyz_mid3_bottom_right_map_vz_z_d0.08.bin')

    print("calculating vx gradients")
    dvx_dx, dvx_dy, dvx_dz = velocity_gradients('./maps/high_res/filament/3D_fields/map_3D_high_18_xyz_left_map_vx_z_d0.08.bin')
    print("calculating vy gradients")
    dvy_dx, dvy_dy, dvy_dz = velocity_gradients('./maps/high_res/filament/3D_fields/map_3D_high_18_xyz_left_map_vy_z_d0.08.bin')
    print("calculating vz gradients")
    dvz_dx, dvz_dy, dvz_dz = velocity_gradients('./maps/high_res/filament/3D_fields/map_3D_high_18_xyz_left_map_vz_z_d0.08.bin')

    #print("calculating divergence")
    div_v = dvx_dx + dvy_dy + dvz_dz

    #print("calculating rotational")
    #rot_v = np.array([dvz_dy - dvy_dz, dvx_dz - dvz_dx, dvy_dx - dvx_dy])



    print("calculating mean divergence over z")
    div_v_meanz = np.nanmean(div_v, axis=2)

    #print(np.shape(div_v_meanz))

    np.save('./filament/left_fil_vel_ops/div_v_meanz.npy',div_v_meanz)

    #print("divergence saved")

    #sys.exit()

    rot_vz = dvy_dx - dvx_dy

    rot_vz_meanz = np.nanmean(rot_vz, axis=2)

    np.save('./filament/left_fil_vel_ops/rot_vz_meanz.npy',rot_vz_meanz)

    print("file saved")

    rot_vx = dvz_dy - dvy_dz

    rot_vx_meanz = np.nanmean(rot_vx, axis=2)

    np.save('./filament/left_fil_vel_ops/rot_vx_meanz.npy',rot_vx_meanz)

    print("file saved")

    rot_vy = dvx_dz - dvz_dx

    rot_vy_meanz = np.nanmean(rot_vy, axis=2)

    np.save('./filament/left_fil_vel_ops/rot_vy_meanz.npy',rot_vy_meanz)

    print("file saved")

def vel_power_spectrum():

    def read_vel_matrix(file):

        h = FortranFile(file, 'r')
        nx, ny, nz = h.read_ints()
        print("nx,ny,nz", nx, ny, nz)
        ncell = nx * ny * nz
        print("ncell", ncell)
        # sys.exit()
        map = np.zeros(ncell)

        map = ftp.f90_to_py.read_map_file(ncell, file,1)

        map = np.reshape(map, (nx, ny, nz), order='F')

        map = np.array(map,dtype=np.float32)

        return map

    def compare_Pk_plot():
        k8 = np.load('./filament/pk_vel/k_8.npy')
        Pk8 = np.load('./filament/pk_vel/Pk_8.npy')

        k6 = np.load('./filament/pk_vel/k_6.npy')
        Pk6 = np.load('./filament/pk_vel/Pk_6.npy')

        k4 = np.load('./filament/pk_vel/k_4.npy')
        Pk4 = np.load('./filament/pk_vel/Pk_4.npy')

        k2 = np.load('./filament/pk_vel/k_2.npy')
        Pk2 = np.load('./filament/pk_vel/Pk_2.npy')

        k0 = np.load('./filament/pk_vel/k_0.npy')
        Pk0 = np.load('./filament/pk_vel/Pk_0.npy')

        k8_PCS = np.load('./filament/pk_vel/k_8_test.npy')
        Pk8_PCS = np.load('./filament/pk_vel/Pk_8_test.npy')

        kp6=np.load('./filament/pk_vel/k_+6.npy')
        Pkp6=np.load('./filament/pk_vel/Pk_+6.npy')

        kp4=np.load('./filament/pk_vel/k_+4.npy')
        Pkp4=np.load('./filament/pk_vel/Pk_+4.npy')

        kp2=np.load('./filament/pk_vel/k_+2.npy')
        Pkp2=np.load('./filament/pk_vel/Pk_+2.npy')

        #plt.plot((2 * np.pi) / k8, Pk8, label="minus 8Mpc",ls='solid',ms=3,color="pink")
        #plt.plot((2 * np.pi) / k6, Pk6, label="minus 6Mpc",ls='dashed',ms=3,color='orange')
        #plt.plot((2 * np.pi) / k4, Pk4, label="minus 4Mpc", ls='dashdot',ms=3,color='red')
        #plt.plot((2 * np.pi) / k2, Pk2, label="minus 2Mpc", ls='dotted',ms=3,color='darkred',lw=2)
        #plt.plot((2 * np.pi) / k0, Pk0, label="core",ls='solid',ms=3,color='black')

        #plt.plot((2 * np.pi) / kp2, Pkp2, label="plus 2Mpc", ls='dotted',ms=3,color='darkblue',lw=2)
        #plt.plot((2 * np.pi) / kp4, Pkp4, label="plus 4Mpc", ls='dashed',ms=3,color='blue')
        #plt.plot((2 * np.pi) / kp6, Pkp6, label="plus 6Mpc", ls='solid',ms=3,color='cyan')



        #plt.plot((2 * np.pi) / k8_PCS, Pk8_PCS, label="minus 8Mpc PCS test", marker='.', ls='dashed')

        Ak8 = np.sqrt(4 * np.pi * k8 ** 3 * Pk8)
        Ak6 = np.sqrt(4 * np.pi * k6 ** 3 * Pk6)
        Ak4 = np.sqrt(4 * np.pi * k4 ** 3 * Pk4)
        Ak2 = np.sqrt(4 * np.pi * k2 ** 3 * Pk2)
        Ak0 = np.sqrt(4 * np.pi * k0 ** 3 * Pk0)
        Akp2 = np.sqrt(4 * np.pi * kp2 ** 3 * Pkp2)
        Akp4 = np.sqrt(4 * np.pi * kp4 ** 3 * Pkp4)
        Akp6 = np.sqrt(4 * np.pi * kp6 ** 3 * Pkp6)


        plt.plot((2 * np.pi) / k8, Ak8, label="minus 8Mpc", ls='solid', ms=3, color="pink")
        plt.plot((2 * np.pi) / k6, Ak6, label="minus 6Mpc", ls='dashed', ms=3, color='orange')
        plt.plot((2 * np.pi) / k4, Ak4, label="minus 4Mpc", ls='dashdot', ms=3, color='red')
        plt.plot((2 * np.pi) / k2, Ak2, label="minus 2Mpc", ls='dotted', ms=3, color='darkred', lw=2)
        plt.plot((2 * np.pi) / k0, Ak0, label="core", ls='solid', ms=3, color='black')

        plt.plot((2 * np.pi) / kp2, Akp2, label="plus 2Mpc", ls='dotted', ms=3, color='darkblue', lw=2)
        plt.plot((2 * np.pi) / kp4, Akp4, label="plus 4Mpc", ls='dashed', ms=3, color='blue')
        plt.plot((2 * np.pi) / kp6, Akp6, label="plus 6Mpc", ls='solid', ms=3, color='cyan')



        #plt.plot(k2, Pk2, label="minus 2Mpc",marker='.',ls='dashed')
        #plt.plot(k4, Pk4, label="minus 4Mpc",marker='.',ls='dashed')
        #plt.plot(k6, Pk6, label="minus 6Mpc",marker='.',ls='dashed')
        #plt.plot(k8, Pk8, label="minus 8Mpc",marker='.',ls='dashed')

        #print("k2",k2)

        x=np.linspace(1000,1,100)

        y=5e5*x**(-5/3)

        #print("x",x)
        #print("y",y)

        #plt.plot(x,y,label="k^(-5/3)",ls='dotted')

        #plt.xlim(max((2 * np.pi) / k2), min((2 * np.pi) / k2))
        plt.xlim(1500,10)

        plt.xscale('log')
        plt.yscale('log')
        # plt.invert_xaxis()
        plt.xlabel(r"$\mathrm{L=\frac{2\pi}{k}}~$[kpc]")
        #plt.xlim(max((2 * np.pi) / k), min((2 * np.pi) / k))
        # plt.xlabel("k [Mpc^-1]")
        plt.ylabel("A(k) [$\mathrm{km.s^{-1}}$]")
        plt.legend()
        plt.show()

        sys.exit()

    #compare_Pk_plot()






    #vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_18_xyz_left_map_vx_z_d0.08.bin')
    #vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_18_xyz_left_map_vy_z_d0.08.bin')
    #vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_18_xyz_left_map_vz_z_d0.08.bin')

    #v = np.sqrt(vx**2 + vy**2 + vz**2)

    #v = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_18_xyz_core_map_v_z.bin')

    v = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_18_xyz_right_plus_2Mpc_v_2Mpc_cube.bin')

    #plt.hist(v.flatten(),bins=100)
    #plt.show()
    #sys.exit()

    cs = 1500 #sound speed in km/s (Gaspari 2014)
    cs = 1223.1288343546449 #sound speed in km/s (Virgo core)

    #v /= cs



    print("v shpae",np.shape(v),"type",type(v))

    #sys.exit()

    #correl_function = correlate(v,v)

    #print("corel fct shape",np.shape(correl_function))

    #size = (737441*0.03)/8

    size = 2000

    print("size",size)

    #help(PKL.Pk)

    #sys.exit()

    Pk = PKL.Pk(v,size,axis=0,MAS='PCS')#,MAS='None',threads=4,verbose='True')

    k = Pk.k3D
    Pk = Pk.Pk[:,0]

    print("len k",len(k))
    #print("k",k)
    #print("l",(2*np.pi)/k)

    #sys.exit()

    #np.save("./filament/core/k.npy",k)
    #np.save("./filament/core/Pk.npy",Pk.Pk[:,0])

    #k = np.load("./filament/core/k.npy")
    #Pk = np.load("./filament/core/Pk.npy")

    test = np.array([5e5*i**(-5/3) for i in range(1,2000)])
    test2 = np.array([5e5 * i ** (-13 / 5) for i in range(1,2000)])

    #plt.plot(test,label="k^(-5/3)")
    #plt.plot(test2,label="k^(-13/5)")

    #np.sqrt(4 * np.pi * k ** 3 * Pk)

    np.save('./filament/pk_vel/k_+2.npy',k)
    np.save('./filament/pk_vel/Pk_+2.npy',Pk)
    print("files saved")
    #sys.exit()


    plt.plot((2*np.pi)/k, Pk, label="Velocity power spectrum (+2 Mpc) ")
    plt.xscale('log')
    plt.yscale('log')
    #plt.invert_xaxis()
    plt.xlabel("L (kpc)")
    plt.xlim(max((2*np.pi)/k),min((2*np.pi)/k))
    #plt.xlabel("k [Mpc^-1]")
    plt.ylabel("A(k)")
    plt.legend()
    plt.show()


    sys.exit()

def test_PK():
        import MAS_library as MASL

        # number of particles
        Np = 128 ** 3

        # density field parameters
        grid = 128  # the 3D field will have grid x grid x grid voxels
        BoxSize = 1000.0  # Mpc/h ; size of box
        MAS = 'CIC'  # mass-assigment scheme
        verbose = True  # print information on progress

        # particle positions in 3D
        pos = np.random.random((Np, 3)).astype(np.float32) * BoxSize

        # define 3D density field
        delta = np.zeros((grid, grid, grid), dtype=np.float32)

        # construct 3D density field
        MASL.MA(pos, delta, BoxSize, MAS, verbose=verbose)

        # at this point, delta contains the effective number of particles in each voxel
        # now compute overdensity and density constrast
        delta /= np.mean(delta, dtype=np.float64);
        delta -= 1.0

        Pk = PKL.Pk(delta, BoxSize)#, axis, MAS, threads, verbose)
        k = Pk.k3D
        Pk = Pk.Pk[:, 0]

        plt.plot(k, Pk)
        plt.show()
        sys.exit()

def velocity_gradients_2D(file):

    #file = './maps/high_res/filament/3D_fields/map_3D_high_19_xyz_mid3_bottom_right_map_vx_z_d0.08.bin'

    h = FortranFile(file, 'r')
    nx, ny, nz = h.read_ints()
    print("nx,ny,nz", nx, ny, nz)
    ncell = ny * nz #for transverse cuts
    #ncell = nx * ny
    print("ncell", ncell)
    #sys.exit()
    map = np.zeros(ncell)

    map = ftp.f90_to_py.read_map_file(ncell, file,0)

    #map = np.reshape(map, (nx, ny),order='F')
    map = np.reshape(map, (nz, ny), order='F')

    #plt.imshow(map[:, :, 30], cmap="Reds", origin='lower')
    #plt.colorbar()
    #plt.show()

    #sys.exit()

    grad_x = np.gradient(map, axis=0)
    grad_y = np.gradient(map, axis=1)
    #grad_z = np.gradient(map, axis=2)

    #map = np.flip(map,axis=0)
    #map = np.flip(map,axis=1)
    #map = np.flip(map,axis=2)


    #print('grad_x shape',np.shape(grad_x))
    #print('grad_y shape',np.shape(grad_y))
    #print('grad_z shape',np.shape(grad_z))

    return grad_x, grad_y

def velocity_operators_2D():

    #print("calculating vx gradients")
    #dvx_dx,dvx_dy,dvx_dz = velocity_gradients('./maps/high_res/filament/3D_fields/map_3D_high_19_xyz_mid3_bottom_right_map_vx_z_d0.08.bin')
    #print("calculating vy gradients")
    #dvy_dx,dvy_dy,dvy_dz = velocity_gradients('./maps/high_res/filament/3D_fields/map_3D_high_19_xyz_mid3_bottom_right_map_vy_z_d0.08.bin')
    #print("calculating vz gradients")
    #dvz_dx,dvz_dy,dvz_dz = velocity_gradients('./maps/high_res/filament/3D_fields/map_3D_high_19_xyz_mid3_bottom_right_map_vz_z_d0.08.bin')

    #print("calculating vx gradients")
    #dvx_dz, dvx_dy = velocity_gradients_2D('./maps/high_res/filament/map_high_19_xyz_left_minus_4Mpc_map_vx_x_d0.02.bin')
    print("calculating vy gradients")
    dvy_dz, dvy_dy = velocity_gradients_2D('./maps/high_res/filament/map_high_19_xyz_left_minus_0Mpc_map_vy_x_d0.02.bin')
    print("calculating vz gradients")
    dvz_dz, dvz_dy = velocity_gradients_2D('./maps/high_res/filament/map_high_19_xyz_left_minus_0Mpc_map_vz_x_d0.02.bin')


    print("shape dvy_dz",np.shape(dvy_dz))

    sys.exit()
    #dvy_dz, dvy_dy = velocity_gradients_2D('./maps/high_res/filament/map_high_19_xyz_full_map_vx_z_d0.02.bin')
    #dvz_dz, dvz_dy = velocity_gradients_2D('./maps/high_res/filament/map_high_19_xyz_full_map_vy_z_d0.02.bin')

    #dvx_dx, dvx_dy = velocity_gradients_2D('./maps/high_res/filament/map_high_19_xyz_full_map_vx_z_d0.02.bin')
    #dvy_dx, dvy_dy = velocity_gradients_2D('./maps/high_res/filament/map_high_19_xyz_full_map_vy_z_d0.02.bin')

    #dvx_dx, dvx_dy = velocity_gradients_2D('./maps/high_res/velocity/map_high_21_z_core_map_vx.bin')
    #dvy_dx, dvy_dy = velocity_gradients_2D('./maps/high_res/velocity/map_high_21_z_core_map_vy.bin')

    #print("calculating divergence")
    #div_v = dvx_dx + dvy_dy + dvz_dz

    div_v = dvy_dy + dvz_dz
    #div_v = dvx_dx + dvy_dy


    #print("calculating rotational")
    #rot_v = np.array([dvz_dy - dvy_dz, dvx_dz - dvz_dx, dvy_dx - dvx_dy])



    #print("calculating mean divergence over z")
    #div_v_meanz = np.nanmean(div_v, axis=2)

    #print(np.shape(div_v_meanz))

    np.save('./filament/left_fil_transverse_vel_ops/div_v_minus_0Mpc.npy',div_v)

    #np.save('./velocity/div_v_core_map_z_proj.npy', div_v)

    #print("divergence saved")

    #sys.exit()

    #rot_vz = dvy_dx - dvx_dy

    #rot_vz = dvy_dx - dvx_dy

    rot_vx = dvz_dy - dvy_dz

    np.save('./filament/left_fil_transverse_vel_ops/rot_vx_minus_0Mpc.npy',rot_vx)

    #np.save('./velocity/rot_vz_core_map_z_proj.npy', rot_vz)

    print("file saved")

    #rot_vx = dvz_dy - dvy_dz

    #rot_vx_meanz = np.nanmean(rot_vx, axis=2)

    #np.save('./filament/left_fil_vel_ops/rot_vx_meanz.npy',rot_vx_meanz)

    #print("file saved")

    #rot_vy = dvx_dz - dvz_dx

    #rot_vy_meanz = np.nanmean(rot_vy, axis=2)

    #np.save('./filament/left_fil_vel_ops/rot_vy_meanz.npy',rot_vy_meanz)

    #print("file saved")


def read_fit_file():
    from astropy.io import fits
    file = fits.open('paint_vel_PRIOR.fits')
    image = file[0].data

    print("image shape",np.shape(image))
    print("image",image)
    print("image max",np.max(image))
    print("image min",np.min(image))

    #plt.hist(image.flatten(),bins=100)
    #plt.show()

    plt.imshow(image, cmap='seismic',vmin=-700,vmax=700,origin='lower')
    plt.colorbar()
    plt.show()

def decompose_vel_field():

    def compare_Pk_plot():

        k0 = np.load('./filament/right_fil_transverse_vel_ops/k_16_0.npy')
        Pk0 = np.load('./filament/right_fil_transverse_vel_ops/Pk_16_0.npy')

        k2 = np.load('./filament/right_fil_transverse_vel_ops/k_16_+2.npy')
        Pk2 = np.load('./filament/right_fil_transverse_vel_ops/Pk_16_+2.npy')

        k4 = np.load('./filament/right_fil_transverse_vel_ops/k_16_+4.npy')
        Pk4 = np.load('./filament/right_fil_transverse_vel_ops/Pk_16_+4.npy')

        k6 = np.load('./filament/right_fil_transverse_vel_ops/k_16_+6.npy')
        Pk6 = np.load('./filament/right_fil_transverse_vel_ops/Pk_16_+6.npy')

        k0comp = np.load('./filament/right_fil_transverse_vel_ops/kcomp_16_0.npy')
        Pk0comp = np.load('./filament/right_fil_transverse_vel_ops/Pkcomp_16_0.npy')

        k2comp = np.load('./filament/right_fil_transverse_vel_ops/kcomp_16_+2.npy')
        Pk2comp = np.load('./filament/right_fil_transverse_vel_ops/Pkcomp_16_+2.npy')

        k4comp = np.load('./filament/right_fil_transverse_vel_ops/kcomp_16_+4.npy')
        Pk4comp = np.load('./filament/right_fil_transverse_vel_ops/Pkcomp_16_+4.npy')

        k6comp = np.load('./filament/right_fil_transverse_vel_ops/kcomp_16_+6.npy')
        Pk6comp = np.load('./filament/right_fil_transverse_vel_ops/Pkcomp_16_+6.npy')

        k0sol = np.load('./filament/right_fil_transverse_vel_ops/ksol_16_0.npy')
        Pk0sol = np.load('./filament/right_fil_transverse_vel_ops/Pksol_16_0.npy')

        k2sol = np.load('./filament/right_fil_transverse_vel_ops/ksol_16_+2.npy')
        Pk2sol = np.load('./filament/right_fil_transverse_vel_ops/Pksol_16_+2.npy')

        k4sol = np.load('./filament/right_fil_transverse_vel_ops/ksol_16_+4.npy')
        Pk4sol = np.load('./filament/right_fil_transverse_vel_ops/Pksol_16_+4.npy')

        k6sol = np.load('./filament/right_fil_transverse_vel_ops/ksol_16_+6.npy')
        Pk6sol = np.load('./filament/right_fil_transverse_vel_ops/Pksol_16_+6.npy')

        Ak0 = np.sqrt(4 * np.pi * k0 ** 3 * Pk0)
        Akcomp0 = np.sqrt(4 * np.pi * k0comp ** 3 * Pk0comp)
        Aksol0 = np.sqrt(4 * np.pi * k0sol ** 3 * Pk0sol)

        Ak2 = np.sqrt(4 * np.pi * k2 ** 3 * Pk2)
        Akcomp2 = np.sqrt(4 * np.pi * k2comp ** 3 * Pk2comp)
        Aksol2 = np.sqrt(4 * np.pi * k2sol ** 3 * Pk2sol)

        Ak4 = np.sqrt(4 * np.pi * k4 ** 3 * Pk4)
        Akcomp4 = np.sqrt(4 * np.pi * k4comp ** 3 * Pk4comp)
        Aksol4 = np.sqrt(4 * np.pi * k4sol ** 3 * Pk4sol)

        Ak6 = np.sqrt(4 * np.pi * k6 ** 3 * Pk6)
        Akcomp6 = np.sqrt(4 * np.pi * k6comp ** 3 * Pk6comp)
        Aksol6 = np.sqrt(4 * np.pi * k6sol ** 3 * Pk6sol)


        #plt.plot((2 * np.pi) / k0, Ak0, label="Velocity (+0Mpc) ",ls='solid',color='black')
        #plt.plot((2 * np.pi) / k0comp, Akcomp0, label="Compressive velocity (+0Mpc) ",ls='solid',color = 'red')
        #plt.plot((2 * np.pi) / k0sol, Aksol0, label="Solenoidal velocity (+0Mpc) ",ls='solid',color='blue')
        #plt.plot((2 * np.pi) / k2, Ak2, label="Velocity (+2Mpc) ",ls='dashed',color='black')
        #plt.plot((2 * np.pi) / k2comp, Akcomp2, label="Compressive velocity (+2Mpc) ",ls='dashed',color='red')
        #plt.plot((2 * np.pi) / k2sol, Aksol2, label="Solenoidal velocity (+2Mpc) ",ls='dashed',color='blue')
        #plt.plot((2 * np.pi) / k4, Ak4, label="Velocity (+4Mpc) ",ls='dashdot',color='black')
        #plt.plot((2 * np.pi) / k4comp, Akcomp4, label="Compressive velocity (+4Mpc) ",ls='dashdot',color='red')
        #plt.plot((2 * np.pi) / k4sol, Aksol4, label="Solenoidal velocity (+4Mpc) ",ls='dashdot',color='blue')
        #plt.plot((2 * np.pi) / k6, Ak6, label="Velocity (+6Mpc) ",ls='dotted',color='black')
        #plt.plot((2 * np.pi) / k6comp, Akcomp6, label="Compressive velocity (+6Mpc) ",ls='dotted',color='red')
        #plt.plot((2 * np.pi) / k6sol, Aksol6, label="Solenoidal velocity (+6Mpc) ",ls='dotted',color='blue')

        plt.plot((2 * np.pi) / k0, Aksol0/Ak0, label="+0Mpc ",ls='solid',color='black')
        plt.plot((2 * np.pi) / k2, Aksol2/Ak2, label="+2Mpc ",ls='dashed',color='black')
        plt.plot((2 * np.pi) / k4, Aksol4/Ak4, label="+4Mpc ",ls='dashdot',color='black')
        plt.plot((2 * np.pi) / k6, Aksol6/Ak6, label="+6Mpc ",ls='dotted',color='black')

        plt.xscale('log')
        plt.yscale('log')
        # plt.invert_xaxis()
        plt.xlabel("L (kpc)")
        plt.xlim(max((2 * np.pi) / k0), min((2 * np.pi) / k0))
        # plt.xlabel("k [Mpc^-1]")
        plt.ylabel("A(k)")
        plt.legend()
        plt.show()

        sys.exit()

    #compare_Pk_plot()


    def read_vel_matrix(file):

        h = FortranFile(file, 'r')
        nx, ny, nz = h.read_ints()
        #print("nx,ny,nz", nx, ny, nz)
        ncell = nx * ny * nz
        #print("ncell", ncell)
        # sys.exit()
        map = np.zeros(ncell)

        print("loading map")

        map = ftp.f90_to_py.read_map_file(ncell, file,1)

        print('reshape map')

        map = np.reshape(map, (nx, ny, nz), order='F')

        map = np.array(map,dtype=np.float32)

        print("reshpae done")

        return map

    #vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_2Mpc_cube.bin')
    #vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_2Mpc_cube.bin')
    #vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_2Mpc_cube.bin')

    #vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vx_10Mpc_cube.bin')
    #vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vy_10Mpc_cube.bin')
    #vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vz_10Mpc_cube.bin')

    #vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vx_10x10x20Mpc_cube.bin')
    #vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vy_10x10x20Mpc_cube.bin')
    #vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vz_10x10x20Mpc_cube.bin')

    def reshape_data(file):
        print(file)

        h = FortranFile(file, 'r')

        ncell = h.read_ints()

        print("ncell", ncell)

        x,y,z,vx,vy,vz = ftp.f90_to_py.read_vel_file(ncell, file)

        print("data loaded")

        #n_e = []
        #n_e = h.read_reals()

        #print("t")
        #t = []
        #t = h.read_reals()

        #print("p")
        #p = []
        #p = h.read_reals()
        #print("x")
        #x = []
        #x = h.read_reals()

        #print("xmin", np.min(x))
        #print("xmax", np.max(x))

        #print('y')
        #y = []
        #y = h.read_reals()

        #print("z")
        #z = []
        #z = h.read_reals()

        #print("vx")
        #vx = []
        #vx = h.read_reals()

        #print("vy")
        #vy = []
        #vy = h.read_reals()


        #print("vz")
        #vz = []
        #vz = h.read_reals()

        #print("m")
        #m = []
        #m = h.read_reals()

        #print("mass min", np.min(m))
        #print("mass max", np.max(m))

        #print("lvl")
        #lvl = []
        #lvl = h.read_reals()

        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        #x -= x_cen
        #y -= y_cen
        # -= z_cen

        vx_virgo = -509.1301
        vy_virgo = 228.9488
        vz_virgo = -131.9249

        vx -= vx_virgo
        vy -= vy_virgo
        vz -= vz_virgo

        #print("x min",np.min(x),"x max",np.max(x))
        #print("y min",np.min(y),"y max",np.max(y))
        #print("z min",np.min(z),"z max",np.max(z))

        #sys.exit()


        #plt.hist(x,bins=100)
        #plt.show()

        #sys.exit()

        cond = np.logical_and(x>-10000,np.logical_and(x<10000,np.logical_and(y>-6000,np.logical_and(y<6000,np.logical_and(z>-6000,z<6000)))))

        print("size x[cond]",len(x[cond]))

        x_cube = x[cond]
        y_cube = y[cond]
        z_cube = z[cond]
        vx_cube = vx[cond]
        vy_cube = vy[cond]
        vz_cube = vz[cond]

        #sys.exit()

        lvl = 15

        nx = int(20000/(737441/2**lvl))
        ny = int(12000/(737441/2**lvl))
        nz = ny

        print("nx,ny,nz",nx,ny,nz)

        cube = np.zeros((nx,ny,nz,3))

        n=0

        for i in range(len(x_cube)):
            if i%1000000 == 0:
                print("i",i,"ratio",i/len(x_cube))

            x_mat = int((x_cube[i]+10000)/(20000/nx))
            y_mat = int((y_cube[i]+6000)/(12000/ny))
            z_mat = int((z_cube[i]+6000)/(12000/nz))

            #print("x_mat",x_mat,"y_mat",y_mat,"z_mat",z_mat,"x",x_cube[0],"y",y_cube[0],"z",z_cube[0])

            #sys.exit()

            if x_mat<nx+1 and y_mat<ny+1 and z_mat<nz+1 and cube[x_mat,y_mat,z_mat,0] == 0 :
                cube[x_mat,y_mat,z_mat,0] = vx_cube[i]
                cube[x_mat,y_mat,z_mat,1] = vy_cube[i]
                cube[x_mat,y_mat,z_mat,2] = vz_cube[i]
                n+=1

        print("n",n,"len x_cube",len(x_cube))

        return cube

    #v_matrix = reshape_data('virgo_xyz_hydro_l15_high_rescale_vel.dat')

    #sys.exit()

    #np.save('./filament/virgo_xyz_hydro_l15_high_rescale_vel_mat.npy',v_matrix)

    v_matrix = np.load('./filament/virgo_xyz_hydro_l15_high_rescale_vel_mat.npy')

    print("file loaded")

    #sys.exit()





    def test():
        grid_size = 10

        # Create a grid of points
        x = np.linspace(-1, 1, grid_size)
        y = np.linspace(-1, 1, grid_size)
        z = np.linspace(-1, 1, grid_size)
        X, Y, Z = np.meshgrid(x, y, z)

        # Define the rotational velocity field components
        #U = -Y  # Velocity component in x-direction
        #V = X  # Velocity component in y-direction
        #W = np.zeros_like(X)

        # Define the diverging velocity field components
        U = X  # Velocity component in x-direction
        V = Y  # Velocity component in y-direction
        W = Z  # Velocity component in z-direction

        rot_x = np.gradient(W, axis=1) - np.gradient(V, axis=2)
        rot_y = np.gradient(U, axis=2) - np.gradient(W, axis=0)
        rot_z = np.gradient(V, axis=0) - np.gradient(U, axis=1)

        div = np.gradient(U, axis=1) + np.gradient(V, axis=2) + np.gradient(W, axis=0)

        #print("rot_x",rot_x)
        #print("rot_y",rot_y)
        #print("rot_z",rot_z)

        #print("div",div)

        #print("shape",np.shape(X))

        #plt.streamplot(X[:,:,5], Y[:,:,5], U[:,:,5], V[:,:,5])
        #plt.streamplot(Y[:,:,0], Z[:,:,0], V[:,:,0], W[:,:,0])
        #plt.show()
        #sys.exit()

        #print("U",U)
        #print("V",V)
        #print("W",W)



        return U,V,W

    #vx,vy,vz = test()


    vx = v_matrix[:,:,:,0]
    vy = v_matrix[:,:,:,1]
    vz = v_matrix[:,:,:,2]

    nx,ny,nz = np.shape(vx)

    print("nx,ny,nz",nx,ny,nz)


    #sys.exit()


    print("fft")

    start = time.time()

    vxk = np.fft.fftn(vx)
    vyk = np.fft.fftn(vy)
    vzk = np.fft.fftn(vz)

    #print("vxk shape",np.shape(vxk))
    #print("vyk shape",np.shape(vyk))
    #print("vzk shape",np.shape(vzk))

    end = time.time()

    print("fft time", end - start)

    kx = np.fft.fftfreq(nx).reshape(nx, 1, 1)
    ky = np.fft.fftfreq(ny).reshape(nz, 1)
    kz = np.fft.fftfreq(nz)

    #print("shape kx",np.shape(kx))
    #print("shape ky",np.shape(ky))
    #print("shape kz",np.shape(kz))

    k2= kx ** 2 + ky ** 2 + kz ** 2
    k2[0, 0, 0] = 1

    print("k2 shape",np.shape(k2))

    #sys.exit()

    print("inverse fft")

    start = time.time()

    #v_sol_xk = 1- (kx ** 2 / k2)*vxk - (kx * ky / k2)*vyk - (kx * kz / k2)*vzk
    #v_sol_yk = 1- (ky * kx / k2)*vxk - (ky ** 2 / k2)*vyk - (ky * kz / k2)*vzk
    #v_sol_zk = 1- (kz * kx / k2)*vxk - (kz * ky / k2)*vyk - (kz ** 2 / k2)*vzk

    #v_sol_x = np.fft.ifftn(v_sol_xk).real
    #v_sol_y = np.fft.ifftn(v_sol_yk).real
    #v_sol_z = np.fft.ifftn(v_sol_zk).real

    #v_comp_xk = vxk - v_sol_xk
    #v_comp_yk = vyk - v_sol_yk
    #v_comp_zk = vzk - v_sol_zk

    #v_comp_x = np.fft.ifftn(v_comp_xk).real
    #v_comp_y = np.fft.ifftn(v_comp_yk).real
    #v_comp_z = np.fft.ifftn(v_comp_zk).real

    div_Vf_f = (vxk * kx + vyk * ky + vzk * kz)  # * 1j
    V_compressive_overk = div_Vf_f / k2
    v_comp_x = np.fft.ifftn(V_compressive_overk * kx)  # [:,np.newaxis,np.newaxis])
    v_comp_y = np.fft.ifftn(V_compressive_overk * ky)
    v_comp_z = np.fft.ifftn(V_compressive_overk * kz)

    v_sol_x = vx - v_comp_x
    v_sol_y = vy - v_comp_y
    v_sol_z = vz - v_comp_z

    #print("v sol x shape",np.shape(v_sol_x))
    #print("v sol x shape flatten",np.shape(v_sol_x.flatten()))

    end = time.time()

    print("inverse fft time", end - start)

    #print(np.shape(v_comp_x))

    print('end')
    #sys.exit()

    v = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)
    v_comp  = np.array(np.sqrt(v_comp_x.real ** 2 + v_comp_y.real ** 2 + v_comp_z.real ** 2),dtype='f')
    v_sol = np.array(np.sqrt(v_sol_x.real ** 2 + v_sol_y.real ** 2 + v_sol_z.real ** 2),dtype='f')

    def test_zero_padding():
        vx = v_matrix[:, :, :, 0]
        vy = v_matrix[:, :, :, 1]
        vz = v_matrix[:, :, :, 2]

        nx, ny, nz = np.shape(vx)
        nx, ny, nz = [1024,1024,1024]

        print("nx,ny,nz", nx, ny, nz)

        # sys.exit()

        print("fft")

        start = time.time()

        vxk = np.fft.fftn(vx,s=[1024,1024,1024])
        vyk = np.fft.fftn(vy,s=[1024,1024,1024])
        vzk = np.fft.fftn(vz,s=[1024,1024,1024])

        print("vxk shape",np.shape(vxk))
        print("vyk shape",np.shape(vyk))
        print("vzk shape",np.shape(vzk))

        end = time.time()

        print("fft time", end - start)

        kx = np.fft.fftfreq(nx).reshape(nx, 1, 1)
        ky = np.fft.fftfreq(ny).reshape(nz, 1)
        kz = np.fft.fftfreq(nz)

        # print("shape kx",np.shape(kx))
        # print("shape ky",np.shape(ky))
        # print("shape kz",np.shape(kz))

        k2 = kx ** 2 + ky ** 2 + kz ** 2
        k2[0, 0, 0] = 1

        print("k2 shape", np.shape(k2))

        # sys.exit()

        print("inverse fft")

        start = time.time()

        # v_sol_xk = 1- (kx ** 2 / k2)*vxk - (kx * ky / k2)*vyk - (kx * kz / k2)*vzk
        # v_sol_yk = 1- (ky * kx / k2)*vxk - (ky ** 2 / k2)*vyk - (ky * kz / k2)*vzk
        # v_sol_zk = 1- (kz * kx / k2)*vxk - (kz * ky / k2)*vyk - (kz ** 2 / k2)*vzk

        # v_sol_x = np.fft.ifftn(v_sol_xk).real
        # v_sol_y = np.fft.ifftn(v_sol_yk).real
        # v_sol_z = np.fft.ifftn(v_sol_zk).real

        # v_comp_xk = vxk - v_sol_xk
        # v_comp_yk = vyk - v_sol_yk
        # v_comp_zk = vzk - v_sol_zk

        # v_comp_x = np.fft.ifftn(v_comp_xk).real
        # v_comp_y = np.fft.ifftn(v_comp_yk).real
        # v_comp_z = np.fft.ifftn(v_comp_zk).real

        div_Vf_f = (vxk * kx + vyk * ky + vzk * kz)  # * 1j
        V_compressive_overk = div_Vf_f / k2
        v_comp_x = np.fft.ifftn(V_compressive_overk * kx,s=[1024,1024,1024])  # [:,np.newaxis,np.newaxis])
        v_comp_y = np.fft.ifftn(V_compressive_overk * ky,s=[1024,1024,1024])
        v_comp_z = np.fft.ifftn(V_compressive_overk * kz,s=[1024,1024,1024])

        print("v_comp_x",v_comp_x.real)
        print("v_x",vx)
        sys.exit()

        v_sol_x = vx - v_comp_x
        v_sol_y = vy - v_comp_y
        v_sol_z = vz - v_comp_z

        # print("v sol x shape",np.shape(v_sol_x))
        # print("v sol x shape flatten",np.shape(v_sol_x.flatten()))

        end = time.time()

        print("inverse fft time", end - start)

        # print(np.shape(v_comp_x))

        print('end')
        #sys.exit()

        v_zp = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)
        v_comp_zp = np.array(np.sqrt(v_comp_x.real ** 2 + v_comp_y.real ** 2 + v_comp_z.real ** 2), dtype='f')
        v_sol_zp = np.array(np.sqrt(v_sol_x.real ** 2 + v_sol_y.real ** 2 + v_sol_z.real ** 2), dtype='f')

        return v_zp,v_comp_zp,v_sol_zp

    v_zp, v_comp_zp, v_sol_zp = test_zero_padding()

    print("mean v",np.mean(v_),"v",v)
    print("mean v_zp", np.mean(v_zp), "v_zp", v_zp)
    print("mean v_zp", np.mean(v_zp[v_zp!=0]), "v_zp", v_zp[v_zp!=0])
    sys.exit()
    print("diff v_c", v_comp - v_comp_zp, "mean diff", np.mean(v_comp - v_comp_zp))
    print("diff v_s", v_sol - v_sol_zp, "mean diff", np.mean(v_sol - v_sol_zp))

    sys.exit()

    def hist_toy_model():

        f, axs = plt.subplots(3, 3, figsize=(60, 60),constrained_layout=True)

        axs[0,0].hist(v_comp_x.real.flatten(),bins=100)
        axs[0,0].set_title("v_comp_x")

        axs[0,1].hist(v_comp_y.real.flatten(),bins=100)
        axs[0,1].set_title("v_comp_y")

        axs[0,2].hist(v_comp_z.real.flatten(),bins=100)
        axs[0,2].set_title("v_comp_z")

        axs[1,0].hist(v_sol_x.real.flatten(),bins=100)
        axs[1,0].set_title("v_sol_x")

        axs[1,1].hist(v_sol_y.real.flatten(),bins=100)
        axs[1,1].set_title("v_sol_y")

        axs[1,2].hist(v_sol_z.real.flatten(),bins=100)
        axs[1,2].set_title("v_sol_z")

        axs[2,0].hist(vx.real.flatten(),bins=100)
        axs[2,0].set_title("vx")

        axs[2,1].hist(vy.real.flatten(),bins=100)
        axs[2,1].set_title("vy")

        axs[2,2].hist(vz.real.flatten(),bins=100)
        axs[2,2].set_title("vz")

        plt.show()

        rot_x_comp = np.gradient(v_comp_z, axis=1) - np.gradient(v_comp_y, axis=2)
        rot_y_comp = np.gradient(v_comp_x, axis=2) - np.gradient(v_comp_z, axis=0)
        rot_z_comp = np.gradient(v_comp_y, axis=0) - np.gradient(v_comp_x, axis=1)

        div_comp = np.gradient(v_comp_x, axis=1) + np.gradient(v_comp_y, axis=2) + np.gradient(v_comp_z, axis=0)

        print('rot_x_comp',rot_x_comp)
        print('rot_y_comp',rot_y_comp)
        print('rot_z_comp',rot_z_comp)
        print("div_comp",div_comp)


        #print("v comp x",np.mean(v_comp_x.real))
        #print("v comp y", np.mean(v_comp_y.real))
        #print("v comp z", np.mean(v_comp_z.real))

        #print("v sol x",np.mean(v_sol_x.real))
        #print("v sol y", np.mean(v_sol_y.real))
        #print("v sol z", np.mean(v_sol_z.real))


    #print("test divVs==0")

    #start = time.time()

    #divVs = np.fft.ifftn((np.fft.fftn(v_sol_x) * kx + np.fft.fftn(v_sol_y) * ky + np.fft.fftn(v_sol_z) * kz) * 1j * 2. * np.pi)

    #end = time.time()

    #print('div_solenoidal max:', abs(divVs).max(), 'time : ', end - start)

    #sys.exit()

    lvl=15

    dimx = (nx / 2) * (737.441 / 2 ** lvl)
    dimy = dimx


    dim = [-dimx, dimx, -dimy, dimy]

    def show_map(vela,titrea,velb,titreb,velc,titrec,comp):
        slice = int(nz/2)


        mapa = vela[:, :, slice]
        mapb = velb[:, :, slice]
        mapc = velc[:, :, slice]


        mapa = mapa.T
        #mapa = np.flip(mapa, axis=0)

        mapb = mapb.T
        #mapb = np.flip(mapb, axis=0)

        mapc = mapc.T
        #mapc = np.flip(mapc, axis=0)

        if comp=="comp" :

            vmin = -1000
            vmax = 1000

            colormap = "bwr"

        elif comp=="tot":

            vmin = 0
            vmax = 1000

            colormap = "cividis"

        f, axs = plt.subplots(1, 3, figsize=(20, 70),constrained_layout=True)
        plt.sca(axs[0])
        im = plt.imshow(mapa, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
        plt.title(titrea)
        plt.xlabel("x [Mpc]")
        plt.ylabel("y [Mpc]")
        #plt.colorbar()

        #vmin = 0
        #vmax = 1
        #colormap = "binary"

        plt.sca(axs[1])
        im = plt.imshow(mapb, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
        plt.title(titreb)
        plt.yticks([])
        plt.xlabel("x [Mpc]")

        #vmin = 0
        #vmax = 1
        #colormap = "binary"

        plt.sca(axs[2])
        im = plt.imshow(mapc, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
        plt.title(titrec)
        plt.yticks([])
        plt.xlabel("x [Mpc]")


        f.colorbar(im,ax=axs.ravel().tolist(), label='velocity $[km s^{-1}]$')#,shrink=0.6)

        #plt.subplots_adjust(wspace=0.05)#, hspace=0.3)

        plt.show()

    #show_map(vx,"total x",v_comp_x,"compressive x",v_sol_x,"solenoidal x","comp")

    #sys.exit()

    #show_map(v, "total", v_comp, "compressive", v_sol, "solenoidal","tot")

    #sys.exit()

    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_12x12x20Mpc_cube.bin',v)
    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_12x12x20Mpc_cube.bin',vx)
    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_12x12x20Mpc_cube.bin',vy)
    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_12x12x20Mpc_cube.bin',vz)

    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_comp_12x12x20Mpc_cube.bin', v_comp)
    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_comp_12x12x20Mpc_cube.bin',v_comp_x.real)
    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_comp_12x12x20Mpc_cube.bin',v_comp_y.real)
    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_comp_12x12x20Mpc_cube.bin',v_comp_z.real)

    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_sol_12x12x20Mpc_cube.bin', v_sol)
    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_sol_12x12x20Mpc_cube.bin',v_sol_x.real)
    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_sol_12x12x20Mpc_cube.bin',v_sol_y.real)
    np.save('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_sol_12x12x20Mpc_cube.bin',v_sol_z.real)

    print("files saved")



    sys.exit()

    #print("v_comp_x",v_comp_x)
    #print("v_sol_x",v_sol_x)
    #print("vx-v_comp_x-v_sol_x",vx-v_comp_x-v_sol_x)

    #divVs = np.fft.ifftn((np.fft.fftn(v_sol_x) * kx + np.fft.fftn(v_sol_y) * ky + np.fft.fftn(v_sol_z) * kz) * 1j * 2. * np.pi)

    #divVs = np.fft.ifftn((np.fft.fftn(V_solenoidal_x) * kx + np.fft.fftn(V_solenoidal_y) * ky + np.fft.fftn(V_solenoidal_z) * kz) * 1j * 2. * np.pi)



    #sys.exit()

    #v = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)

    #v_comp = np.array(np.sqrt(V_compressive_x.real ** 2 + V_compressive_y.real ** 2 + V_compressive_z.real ** 2), dtype='f')
    #v_sol = np.array(np.sqrt(V_solenoidal_x.real ** 2 + V_solenoidal_y.real ** 2 + V_solenoidal_z.real ** 2),dtype='f')

    #print(type(v_comp))
    #sys.exit()

    size = 10000

    print("size", size)

    Pk = PKL.Pk(v, size, axis=0, MAS='CIC')  # ,MAS='None',threads=4,verbose='True')

    k = Pk.k3D
    Pk = Pk.Pk[:, 0]

    Pkcomp = PKL.Pk(v_comp, size, axis=0, MAS='CIC')  # ,MAS='None',threads=4,verbose='True')

    kcomp = Pkcomp.k3D
    Pkcomp = Pkcomp.Pk[:, 0]

    Pksol = PKL.Pk(v_sol, size, axis=0, MAS='CIC')  # ,MAS='None',threads=4,verbose='True')

    ksol = Pksol.k3D
    Pksol = Pksol.Pk[:, 0]

    print("len k", len(k))
    # print("k",k)
    # print("l",(2*np.pi)/k)

    # sys.exit()

    # np.save("./filament/core/k.npy",k)
    # np.save("./filament/core/Pk.npy",Pk.Pk[:,0])

    # k = np.load("./filament/core/k.npy")
    # Pk = np.load("./filament/core/Pk.npy")

    #test = np.array([5e5 * i ** (-5 / 3) for i in range(1, 2000)])
    #test2 = np.array([5e5 * i ** (-13 / 5) for i in range(1, 2000)])

    # plt.plot(test,label="k^(-5/3)")
    # plt.plot(test2,label="k^(-13/5)")

    # np.sqrt(4 * np.pi * k ** 3 * Pk)

    #np.save('./filament/pk_vel/k_+2.npy', k)
    #np.save('./filament/pk_vel/Pk_+2.npy', Pk)
    #print("files saved")
    # sys.exit()
    Ak = np.sqrt(4 * np.pi * k ** 3 * Pk)
    Akcomp = np.sqrt(4 * np.pi * kcomp ** 3 * Pkcomp)
    Aksol = np.sqrt(4 * np.pi * ksol ** 3 * Pksol)

    np.save('./filament/Ak_cube_core_test/k_l17_10Mpc.npy', (2 * np.pi) /k)
    np.save('./filament/Ak_cube_core_test/Ak_l17_10Mpc.npy', Ak)

    np.save('./filament/Ak_cube_core_test/kcomp_l17_10Mpc.npy', (2 * np.pi) /kcomp)
    np.save('./filament/Ak_cube_core_test/Akcomp_l17_10Mpc.npy', Akcomp)

    np.save('./filament/Ak_cube_core_test/ksol_l17_10Mpc.npy', (2 * np.pi) /ksol)
    np.save('./filament/Ak_cube_core_test/Aksol_l17_10Mpc.npy', Aksol)

    sys.exit()

    print("files saved")

    k10 = np.load('./filament/Ak_cube_core_test/k_l15_10Mpc.npy')
    Ak10 = np.load('./filament/Ak_cube_core_test/Ak_l15_10Mpc.npy')

    kcomp10 = np.load('./filament/Ak_cube_core_test/kcomp_l15_10Mpc.npy')
    Akcomp10 = np.load('./filament/Ak_cube_core_test/Akcomp_l15_10Mpc.npy')

    ksol10 = np.load('./filament/Ak_cube_core_test/ksol_l15_10Mpc.npy')
    Aksol10 = np.load('./filament/Ak_cube_core_test/Aksol_l15_10Mpc.npy')

    plt.plot(k10, Ak10, label="Total, cube=10Mpc",color='black',ls='solid')
    plt.plot(kcomp10, Akcomp10, label="Compressive, cube=10Mpc",color="black",ls='dashed')
    plt.plot(ksol10, Aksol10, label="Solenoidal, cube=10Mpc",color='black',ls='dotted')

    k5 = np.load('./filament/Ak_cube_core_test/k_l15_5Mpc.npy')
    Ak5 = np.load('./filament/Ak_cube_core_test/Ak_l15_5Mpc.npy')

    kcomp5 = np.load('./filament/Ak_cube_core_test/kcomp_l15_5Mpc.npy')
    Akcomp5 = np.load('./filament/Ak_cube_core_test/Akcomp_l15_5Mpc.npy')

    ksol5 = np.load('./filament/Ak_cube_core_test/ksol_l15_5Mpc.npy')
    Aksol5 = np.load('./filament/Ak_cube_core_test/Aksol_l15_5Mpc.npy')

    plt.plot(k5, Ak5, label="Total, cube=5Mpc",color='red',ls='solid')
    plt.plot(kcomp5, Akcomp5, label="Compressive, cube=5Mpc",color='red',ls='dashed')
    plt.plot(ksol5, Aksol5, label="Solenoidal, cube=5Mpc",color='red',ls='dotted')

    plt.plot((2 * np.pi) / k, Ak, label="Total, cube=2Mpc",color='blue',ls='solid')
    plt.plot((2 * np.pi) / kcomp, Akcomp, label="Compressive, cube=2Mpc",color='blue',ls='dashed')
    plt.plot((2 * np.pi) / ksol, Aksol, label="Solenoidal, cube=2Mpc",color='blue',ls='dotted')
    plt.xscale('log')
    plt.yscale('log')
    # plt.invert_xaxis()
    plt.xlabel("L (kpc)")
    plt.xlim(max((2 * np.pi) / k), min((2 * np.pi) / k))
    plt.xlim(7000,50)
    # plt.xlabel("k [Mpc^-1]")
    plt.ylabel("A(k)")
    plt.legend()
    plt.show()

    sys.exit()


def decompose_vel_field_2D(n,pm):

    def read_map(file):

        h = FortranFile(file, 'r')
        nx, ny, nz = h.read_ints()
        cen_x, cen_y, cen_z = h.read_reals()
        print("nx,ny,nz", nx, ny, nz)
        ncell = nz * ny
        map = np.zeros(ncell)
        map = ftp.f90_to_py.read_map_file(ncell, file, 0)
        map = np.reshape(map, (nz, ny))

        return map,ny,nz

    if pm=='+':
        pos = 'plus'
    elif pm=='-':
        pos = 'minus'

    file_vz = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vz_x_d0.02.bin'
    file_vy = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vy_x_d0.02.bin'

    vz,ny,nz = read_map(file_vz)
    vy,ny,nz = read_map(file_vy)

    vz[np.isnan(vz)] = 0
    vy[np.isnan(vy)] = 0

    vx_virgo = -509.1301
    vy_virgo = 228.9488
    vz_virgo = -131.9249

    vy -= vy_virgo
    vz -= vz_virgo

    print("vy",vy)
    print("vz",vz)

    #print("vz shape",np.shape(vz))

    #sys.exit()

    start = time.time()

    print("fft")

    vyk = np.fft.fftn(vy)
    vzk = np.fft.fftn(vz)

    print("vyk shape",np.shape(vyk))
    print("vzk shape",np.shape(vzk))


    end = time.time()

    print("fft time", end - start)

    # kx = np.fft.fftfreq(nx).reshape(nx, 1, 1)
    ky = np.fft.fftfreq(ny).reshape(ny, 1)
    kz = np.fft.fftfreq(nz).reshape(nz)

    #print("shape kx",np.shape(kx))
    print("shape ky",np.shape(ky))
    print("shape kz",np.shape(kz))

    k2 = ky ** 2 + kz ** 2
    k2[0, 0] = 1

    print("k2 shape",np.shape(k2))

    #sys.exit()

    print("inverse fft")

    start = time.time()


    div_Vf_f = (vyk * ky + vzk * kz)  # * 1j
    V_compressive_overk = div_Vf_f / k2
    V_compressive_y = np.fft.ifftn(V_compressive_overk * ky)
    V_compressive_z = np.fft.ifftn(V_compressive_overk * kz)

    V_solenoidal_y = vy - V_compressive_y
    V_solenoidal_z = vz - V_compressive_z

    end = time.time()

    print("inverse fft time", end - start)

    # print(np.shape(v_comp_x))

    savefile_vzcomp = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vzcomp_x_d0.02.npy'
    savefile_vycomp = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vycomp_x_d0.02.npy'
    savefile_vzsol = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vzsol_x_d0.02.npy'
    savefile_vysol = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vysol_x_d0.02.npy'

    print('v comp z ',V_compressive_z.real)
    print('v comp y ',V_compressive_y.real)
    print('v sol z ',V_solenoidal_z.real)
    print('v sol y ',V_solenoidal_y.real)

    np.save(savefile_vzcomp, V_compressive_z.real)
    np.save(savefile_vycomp, V_compressive_y.real)
    np.save(savefile_vzsol, V_solenoidal_z.real)
    np.save(savefile_vysol, V_solenoidal_y.real)


    print('files saved')

    # print("v_comp_x",v_comp_x)
    # print("v_sol_x",v_sol_x)
    # print("vx-v_comp_x-v_sol_x",vx-v_comp_x-v_sol_x)

    # divVs = np.fft.ifftn((np.fft.fftn(v_sol_x) * kx + np.fft.fftn(v_sol_y) * ky + np.fft.fftn(v_sol_z) * kz) * 1j * 2. * np.pi)

    #divVs = np.fft.ifftn((np.fft.fftn(V_solenoidal_y) * ky + np.fft.fftn(V_solenoidal_z) * kz) * 1j * 2. * np.pi)

    #print('div_solenoidal max:', abs(divVs).max())

    #sys.exit()

def vel_pk_2D(n,pm):
    def read_map(file):
        h = FortranFile(file, 'r')
        nx, ny, nz = h.read_ints()
        cen_x, cen_y, cen_z = h.read_reals()
        print("nx,ny,nz", nx, ny, nz)
        ncell = nz * ny
        map = np.zeros(ncell)
        map = ftp.f90_to_py.read_map_file(ncell, file, 0)
        map = np.reshape(map, (nz, ny))

        return map, ny, nz

    if pm=='+':
        pos = 'plus'
    elif pm=='-':
        pos = 'minus'

    file_vz = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vz_x_d0.02.bin'
    file_vy = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vy_x_d0.02.bin'

    vz, ny, nz = read_map(file_vz)
    vy, ny, nz = read_map(file_vy)

    v = np.sqrt(vy ** 2 + vz ** 2)

    savefile_vzcomp = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vzcomp_x_d0.02.bin.npy'
    savefile_vycomp = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vycomp_x_d0.02.bin.npy'
    savefile_vzsol = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vzsol_x_d0.02.bin.npy'
    savefile_vysol = './maps/high_res/filament/map_high_19_xyz_left_' + pos + '_' + str(n) + 'Mpc_map_vysol_x_d0.02.bin.npy'


    vzcomp = np.load(savefile_vzcomp)
    vycomp = np.load(savefile_vycomp)
    vzsol = np.load(savefile_vzsol)
    vysol = np.load(savefile_vysol)

    #print("vzcomp",vzcomp)
    #print("vycomp",vycomp)
    #print("vzsol",vzsol)
    #print("vysol",vysol)

    vcomp = np.sqrt(vycomp ** 2 + vzcomp ** 2)
    vsol = np.sqrt(vysol ** 2 + vzsol ** 2)

    print("files loaded")

    size = 5000.0

    zmin = 6085
    zmax = 9641
    ymin = 6085
    ymax = 9641

    if n==4 and pm=='-': ##355px = 500kpc, to center on the core of the filament
        ymin+=355*3
        ymax+=355*3

    if n==6 and pm=='-':
        ymin+=355*4
        ymax+=355*4

    if n==8 and pm=='-':
        ymin+=355*7
        ymax+=355*7



    vpk = np.array(v[zmin:zmax,ymin:ymax],dtype=np.float32)

    vcomppk = np.array(vcomp[zmin:zmax,ymin:ymax],dtype=np.float32)

    vsolpk = np.array(vsol[zmin:zmax,ymin:ymax],dtype=np.float32)


    print("vpk shape",np.shape(vpk))

    Pk = PKL.Pk_plane(vpk, size)
    k = Pk.k
    Pk = Pk.Pk

    Pkcomp = PKL.Pk_plane(vcomppk, size)
    kcomp = Pkcomp.k
    Pkcomp = Pkcomp.Pk

    Pksol = PKL.Pk_plane(vsolpk, size)
    ksol = Pksol.k
    Pksol = Pksol.Pk

    Ak = np.sqrt(4 * np.pi * k ** 3 * Pk)
    Akcomp = np.sqrt(4 * np.pi * kcomp ** 3 * Pkcomp)
    Aksol = np.sqrt(4 * np.pi * ksol ** 3 * Pksol)

    #np.save('./filament/right_fil_transverse_vel_ops/k_16_+6.npy', k)
    #np.save('./filament/right_fil_transverse_vel_ops/Pk_16_+6.npy', Pk)

    #np.save('./filament/right_fil_transverse_vel_ops/kcomp_16_+6.npy', kcomp)
    #np.save('./filament/right_fil_transverse_vel_ops/Pkcomp_16_+6.npy', Pkcomp)

    #np.save('./filament/right_fil_transverse_vel_ops/ksol_16_+6.npy', ksol)
    #np.save('./filament/right_fil_transverse_vel_ops/Pksol_16_+6.npy', Pksol)

    print("akcomp",Akcomp)
    print("aksol",Aksol)

    #labelak = "Velocity power spectrum ("+ pm + str(n) + "Mpc) "
    #labelakcomp = "Compressive velocity power spectrum ("+ pm + str(n) + "Mpc) "
    #labelaksol = "Solenoidal velocity power spectrum ("+ pm + str(n) + "Mpc) "

    labelak = 'Total'
    labelakcomp = 'Compressive'
    labelaksol = 'Solenoidal'

    title = 'Velocity power spectrum ('+ pm + str(n) + 'Mpc)'

    plt.plot((2 * np.pi) / k, Ak, label=labelak)
    plt.plot((2 * np.pi) / kcomp, Akcomp, label=labelakcomp)
    plt.plot((2 * np.pi) / ksol, Aksol, label=labelaksol)
    plt.xscale('log')
    plt.yscale('log')
    # plt.invert_xaxis()
    plt.xlabel("L (kpc)")
    plt.xlim(max((2 * np.pi) / k), min((2 * np.pi) / k))
    plt.xlim(3000,30)
    # plt.xlabel("k [Mpc^-1]")
    plt.ylabel("A(k)")
    plt.title(title)
    plt.legend()
    plt.tight_layout()
    plt.show()

def show_decomposed_vel_fields():

    def read_vel_matrix(file):

        h = FortranFile(file, 'r')
        nx, ny, nz = h.read_ints()
        print("nx,ny,nz", nx, ny, nz)
        ncell = nx * ny * nz
        print("ncell", ncell)
        # sys.exit()
        map = np.zeros(ncell)

        map = ftp.f90_to_py.read_map_file(ncell, file,1)

        print("reshape map")

        map = np.reshape(map, (nx, ny, nz), order='F')

        print("reshape done")

        map = np.array(map,dtype=np.float32)

        return map

    #vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_2Mpc_cube.bin')
    #vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_2Mpc_cube.bin')
    #vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_2Mpc_cube.bin')

    lvl=15

    if lvl==16:

        #vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vx_10Mpc_cube.bin')
        #vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vy_10Mpc_cube.bin')
        #vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vz_10Mpc_cube.bin')

        #v = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_10Mpc_cube.bin.npy')
        #v_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_comp_10Mpc_cube.bin.npy')
        #v_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_sol_10Mpc_cube.bin.npy')

        v = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_10x10x20Mpc_cube.bin.npy')
        v_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_comp_10x10x20Mpc_cube.bin.npy')
        v_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_sol_10x10x20Mpc_cube.bin.npy')

    if lvl==15:


        #vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_10Mpc_cube.bin')
        #vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_10Mpc_cube.bin')
        #vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_10Mpc_cube.bin')

        #vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_10x10x20Mpc_cube_rdr15.bin')
        #vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_10x10x20Mpc_cube_rdr15.bin')
        #vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_10x10x20Mpc_cube_rdr15.bin')

        #v = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_10Mpc_cube.bin.npy')
        #v_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_comp_10Mpc_cube.bin.npy')
        #v_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_sol_10Mpc_cube.bin.npy')

        v = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_10x10x20Mpc_cube.bin.npy')
        v_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_comp_10x10x20Mpc_cube.bin.npy')
        v_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_sol_10x10x20Mpc_cube.bin.npy')

        #v = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)

    nx, ny, nz = np.shape(v)

    #lvl = 15

    dimx = (nx / 2) * (737.441 / 2 ** lvl)
    dimy = dimx

    dim = [-dimx, dimx, -dimy, dimy]
    def show_map_3(vela,titrea,velb,titreb,velc,titrec,comp):
        slice = int(nx/2)


        mapa = vela[:, :, slice]
        mapb = velb[:, :, slice]
        mapc = velc[:, :, slice]

        mapa = mapa.T
        #mapa = np.flip(mapa, axis=0)

        mapb = mapb.T
        #mapb = np.flip(mapb, axis=0)

        mapc = mapc.T
        #mapc = np.flip(mapc, axis=0)

        if comp=="comp" :

            vmin = -1000
            vmax = 1000

            colormap = "bwr"

        elif comp=="tot":

            vmin = 0
            vmax = 1000

            colormap = "cividis"

        f, axs = plt.subplots(1, 3, figsize=(20, 70),constrained_layout=True)
        plt.sca(axs[0])
        im = plt.imshow(mapa, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
        plt.title(titrea)
        plt.xlabel("x [Mpc]")
        plt.ylabel("y [Mpc]")
        #plt.colorbar()

        #vmin = 0
        #vmax = 1
        #colormap = "binary"

        plt.sca(axs[1])
        im = plt.imshow(mapb, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
        plt.title(titreb)
        plt.yticks([])
        plt.xlabel("x [Mpc]")

        #vmin = 0
        #vmax = 1
        #colormap = "binary"

        plt.sca(axs[2])
        im = plt.imshow(mapc, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
        plt.title(titrec)
        plt.yticks([])
        plt.xlabel("x [Mpc]")


        f.colorbar(im,ax=axs.ravel().tolist(), label='velocity $[\mathrm{km\,s^{-1}}]$')#,shrink=0.6)

        #plt.subplots_adjust(wspace=0.05)#, hspace=0.3)

        plt.show()

    def show_map_nx3(vela,titrea,velb,titreb,velc,titrec,comp):
        slice = int(nx/2)

        print("slice",slice)

        print('nx',nx)

        #slice = int(nx/2-nx/5)

        print("slice",slice)



        mapa = vela[slice, :, :]
        mapb = mapa
        mapc = mapa
        #mapb = velb[slice, :, :]
        #mapc = velc[slice, :, :]

        #mapa = vela[:, slice, :]
        #mapb = velb[:, slice, :]
        #mapc = velc[:, slice, :]

        #mapa = np.mean(vela[slice-1:slice, :, :],axis=0)

        #mapa = mapa.T
        #mapa = np.flip(mapa, axis=0)

        #mapb = mapb.T
        #mapb = np.flip(mapb, axis=0)

        #mapc = mapc.T
        #mapc = np.flip(mapc, axis=0)

        if comp=="comp" :

            vmin = -1000
            vmax = 1000

            colormap = "bwr"

        elif comp=="tot":

            vmin = 0
            vmax = 1200

            colormap = "cividis"


        init=0
        n=8

        f, axs = plt.subplots(3, n, figsize=(20, 4),constrained_layout=True)
        for i in range(init,init+n):
            print("i",i)

            fs=10


            title = "$\Delta x_{cen}$=" +str(round(2*i-8,3)) + " Mpc"

            slice = int(nx / 2 - (4-i)*(nx/10))

            #print("slice", slice)

            #print('nx', nx)

            # slice = int(nx/2-nx/5)

            print("slice", slice)

            mapa = vela[slice, :, :]
            #mapb = mapa
            #mapc = mapa

            mapb = velb[slice, :, :]
            mapc = velc[slice, :, :]

            plt.sca(axs[0,i-init])
            im = plt.imshow(mapa, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
            plt.title(title, fontsize=fs)
            #plt.xlabel("x [Mpc]")
            if i-init==0:
                plt.ylabel("y [Mpc]", fontsize=fs)
                plt.yticks(fontsize=fs)
            else :
                plt.yticks([])
            #plt.xticks([])
            a = plt.gca()
            xax = a.axes.get_xaxis()
            xax = xax.set_visible(False)

            if i==(init+n-1):
                plt.text(1.05,0.5,'Total',transform=axs[0,n-1].transAxes,verticalalignment='center',rotation=270, fontsize=fs)
            #plt.colorbar()

            #vmin = 0
            #vmax = 1
            #colormap = "binary"

            plt.sca(axs[1,i-init])
            im = plt.imshow(mapb, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
            #plt.title(titreb)
            #plt.xticks([])
            a = plt.gca()
            xax = a.axes.get_xaxis()
            xax = xax.set_visible(False)
            if i-init==0:
                plt.ylabel("y [Mpc]", fontsize=fs)
                plt.yticks(fontsize=fs)
            else :
                plt.yticks([])
            if i==(init+n-1):
                plt.text(1.05,0.5,'Compressive',transform=axs[1,n-1].transAxes,verticalalignment='center',rotation=270, fontsize=fs)

            #vmin = 0
            #vmax = 1
            #colormap = "binary"

            plt.sca(axs[2,i-init])
            im = plt.imshow(mapc, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
            #plt.title(titrec)
            #plt.yticks([])
            plt.xlabel("z [Mpc]", fontsize=fs)
            plt.xticks(fontsize=fs)
            if i-init==0:
                plt.ylabel("y [Mpc]", fontsize=fs)
                plt.yticks(fontsize=fs)
            else :
                plt.yticks([])
            if i==(init+n-1):
                plt.text(1.05,0.5,'Solenoidal',transform=axs[2,n-1].transAxes,verticalalignment='center',rotation=270, fontsize=fs)


        cb = f.colorbar(im,ax=axs.ravel().tolist(), label='velocity $[\mathrm{km\,s^{-1}}]$')#,size='small')#,shrink=0.6)
        cb.ax.tick_params(labelsize=fs)

        #plt.subplots_adjust(wspace=0, hspace=0)

        #f.tight_layout()


        plt.show()

    #show_map(vx,"total x",v_comp_x,"compressive x",v_sol_x,"solenoidal x","comp")



    #print("files saved")

    show_map_nx3(v, "total", v_comp, "compressive", v_sol, "solenoidal","tot")

    #show_map_nx3(vz, "total x", v_comp, "compressive x", v_sol, "solenoidal x", "comp")

def vel_pk_nD():
    def read_vel_matrix(file):

        h = FortranFile(file, 'r')
        nx, ny, nz = h.read_ints()
        print("nx,ny,nz", nx, ny, nz)
        ncell = nx * ny * nz
        print("ncell", ncell)
        # sys.exit()
        map = np.zeros(ncell)

        map = ftp.f90_to_py.read_map_file(ncell, file, 1)

        map = np.reshape(map, (nx, ny, nz), order='F')

        map = np.array(map, dtype=np.float32)

        return map

    # vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_2Mpc_cube.bin')
    # vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_2Mpc_cube.bin')
    # vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_2Mpc_cube.bin')

    print("loading files")

    lvl = 15

    if lvl == 16:
        #vx = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vx_10Mpc_cube.bin')
        #vy = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vy_10Mpc_cube.bin')
        #vz = read_vel_matrix('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_vz_10Mpc_cube.bin')

        #v = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_10Mpc_cube.bin.npy')
        #v_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_comp_10Mpc_cube.bin.npy')
        #v_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_sol_10Mpc_cube.bin.npy')

        v = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_10x10x20Mpc_cube.bin.npy')
        v_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_comp_10x10x20Mpc_cube.bin.npy')
        v_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_16_xyz_right_minus_0Mpc_v_sol_10x10x20Mpc_cube.bin.npy')

    if lvl == 15:
        v = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_10x10x20Mpc_cube.bin.npy')
        v_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_comp_10x10x20Mpc_cube.bin.npy')
        v_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_v_sol_10x10x20Mpc_cube.bin.npy')

    nx,ny,nz = np.shape(v)

    print("nx",nx,"ny",ny,"nz",nz)

    #slice = int( nx / 2)

    #if n == 4 and pm == '-':
    #    i=0
    #if n == 2 and pm == '-':
    #    i=1
    #if n == 0 :
    #    i=2

    init = 1
    end = 7
    n= end - init

    f,axs = plt.subplots(1,n, figsize=(20, 4), constrained_layout=True)

    for i in range(init,end):

        # i=0 : -8Mpc , i=1 : -6Mpc , i=2 : -4Mpc , i=3 : -2Mpc , i=4 : 0Mpc , i=5 : 2Mpc , i=6 : 4Mpc , i=7 : 6Mpc

        slice = int(nx / 2 - (4 - i) * (nx / 10))

        print("slice",slice)

        size = 5000.0

        width = 10000.0

        conversion_factor = nz/width # pixel per kpc

        print("conversion factor",conversion_factor)

        zmin = int(nz/2-2500*conversion_factor)
        zmax = int(nz/2+2500*conversion_factor)
        ymin = int(ny/2-2500*conversion_factor)
        ymax = int(ny/2+2500*conversion_factor)

        print("zmin",zmin,"zmax",zmax,"ymin",ymin,"ymax",ymax)
        print("i",i)

        if i==0:
            factor = 5
            factor_x = 4

        if i==1:
            factor = 3
            factor_x = 3

        if i==2:
            factor = 3
            factor_x = 2

        if i==3:
            factor_x = 1

        if i==4:
            factor_x = 0

        if i==5:
            factor_x = -1

        if i == 6 :
            factor = -2
            factor_x = -2

        if i == 7 :
            factor = -5
            factor_x = -3

        ymin += int(500 * conversion_factor) * factor
        ymax += int(500 * conversion_factor) * factor

        xmin = int(nx / 2 - 2500 * conversion_factor - factor_x * 2000 * conversion_factor)
        xmax = int(nx / 2 + 2500 * conversion_factor - factor_x * 2000 * conversion_factor)





        print("xmin",xmin,"xmax",xmax, "ymin", ymin, "ymax", ymax, "zmin", zmin, "zmax", zmax)
        #print("diff z",zmin-zmax,"diff y",ymin-ymax)

        #sys.exit()


        #print("files loaded")

        dim=2

        if dim==2:
            vpk = np.array(v[slice,ymin:ymax,zmin:zmax]**2,dtype=np.float32)
            vcomppk = np.array(v_comp[slice,ymin:ymax,zmin:zmax]**2,dtype=np.float32)
            vsolpk = np.array(v_sol[slice,ymin:ymax,zmin:zmax]**2,dtype=np.float32)

            # vpk = np.array(v[slice, :, :]**2, dtype=np.float32)
            # vcomppk = np.array(v_comp[slice, :,:]**2, dtype=np.float32)
            # vsolpk = np.array(v_sol[slice, :,:]**2, dtype=np.float32)

            Pk = PKL.Pk_plane(vpk, size)
            k = Pk.k
            Pk = Pk.Pk

            Pkcomp = PKL.Pk_plane(vcomppk, size)
            kcomp = Pkcomp.k
            Pkcomp = Pkcomp.Pk

            Pksol = PKL.Pk_plane(vsolpk, size)
            ksol = Pksol.k
            Pksol = Pksol.Pk

        if dim == 3:

            vpk = np.array(v[xmin:xmax, ymin:ymax, zmin:zmax] ** 2, dtype=np.float32)
            vcomppk = np.array(v_comp[xmin:xmax, ymin:ymax, zmin:zmax] ** 2, dtype=np.float32)
            vsolpk = np.array(v_sol[xmin:xmax, ymin:ymax, zmin:zmax] ** 2, dtype=np.float32)

            Pk = PKL.Pk(vpk, size)
            k = Pk.k3D
            Pk = Pk.Pk[:, 0]

            Pkcomp = PKL.Pk(vcomppk, size)
            kcomp = Pkcomp.k3D
            Pkcomp = Pkcomp.Pk[:, 0]

            Pksol = PKL.Pk(vsolpk, size)
            ksol = Pksol.k3D
            Pksol = Pksol.Pk[:, 0]

        print("vpk shape", np.shape(vpk))

        #Ak = np.sqrt(4 * np.pi * k ** 3 * Pk)
        #Akcomp = np.sqrt(4 * np.pi * kcomp ** 3 * Pkcomp)
        #Aksol = np.sqrt(4 * np.pi * ksol ** 3 * Pksol)

        # np.save('./filament/right_fil_transverse_vel_ops/k_16_+6.npy', k)
        # np.save('./filament/right_fil_transverse_vel_ops/Pk_16_+6.npy', Pk)

        # np.save('./filament/right_fil_transverse_vel_ops/kcomp_16_+6.npy', kcomp)
        # np.save('./filament/right_fil_transverse_vel_ops/Pkcomp_16_+6.npy', Pkcomp)

        # np.save('./filament/right_fil_transverse_vel_ops/ksol_16_+6.npy', ksol)
        # np.save('./filament/right_fil_transverse_vel_ops/Pksol_16_+6.npy', Pksol)

        #print("akcomp", Akcomp)
        #print("aksol", Aksol)

        # labelak = "Velocity power spectrum ("+ pm + str(n) + "Mpc) "
        # labelakcomp = "Compressive velocity power spectrum ("+ pm + str(n) + "Mpc) "
        # labelaksol = "Solenoidal velocity power spectrum ("+ pm + str(n) + "Mpc) "

        labelak = 'Total'
        labelakcomp = 'Compressive'
        labelaksol = 'Solenoidal'

        print("i", i)

        fs = 10

        title = "$x-x_{Virgo}$ = " + str(round(2 * i - 8, 3)) + "Mpc"

        def k_to_l(k):
            return 2*np.pi/k

        def l_to_k(l):
            return 2*np.pi/l

        def kolmog(A,k):
            return A*k**(-5/3)

        compare_x = [1e-2,1e-1]
        compare_y = [kolmog(4.641e12,compare_x[0]),kolmog(4.641e12,compare_x[1])]

        ##for 3D P(k)

        compare_x = [1e-2, 1e-1]
        compare_y = [kolmog(4.641e15, compare_x[0]), kolmog(4.641e15, compare_x[1])]


        def kolmog(A,k):
            return A*k**(-2)

        compare_x_2 = [1e-2, 1e-1]

        compare_y_2 = [kolmog(1e12, compare_x_2[0]), kolmog(1e12, compare_x_2[1])]

        compare_x_2 = [1e-2, 1e-1]
        compare_y_2 = [kolmog(1e15, compare_x[0]), kolmog(1e15, compare_x[1])]

        plt.sca(axs[i-init])
        #im = plt.imshow(mapa, cmap=colormap, origin="lower", alpha=1, extent=dim, vmin=vmin, vmax=vmax)
        plt.plot(k, Pk, label=labelak)
        plt.plot(kcomp, Pkcomp, label=labelakcomp)
        plt.plot(ksol, Pksol, label=labelaksol)
        plt.plot(compare_x,compare_y,linestyle='--',label='$k\propto-5/3 $')
        plt.plot(compare_x_2, compare_y_2, linestyle='--', label='$k\propto-2 $')
        secax = axs[i-init].secondary_xaxis('top', functions=(k_to_l, l_to_k))
        secax.set_xlabel(r'$L=\frac{2\pi}{k}$ [kpc]',fontsize=fs)
        secax.tick_params(labelsize=fs)
        plt.xscale('log')
        plt.yscale('log')

        # plt.invert_xaxis()
        # plt.xlabel("L (kpc)")
        # plt.xlim(max((2 * np.pi) / k), min((2 * np.pi) / k))
        plt.xlim(0.001,0.25)
        #plt.ylim(5e9,1e17) ##for 2D P(k)
        plt.ylim(1e11,1e21) ##for 3D P(k)
        # plt.xlabel("k [Mpc^-1]")
        # plt.ylabel("A(k)")
        # plt.title(title)
        plt.legend(fontsize=fs)
        # plt.tight_layout()
        plt.title(title, fontsize=fs+2)
        # plt.xlabel("x [Mpc]")
        if i-init == 0:
            plt.ylabel(r'$E(k)=\frac{1}{2} |\tilde{v}(k)| ^2$', fontsize=fs)
            plt.yticks(fontsize=fs)
        else:
            plt.yticks([])
        # plt.xticks([])
        #a = plt.gca()
        #xax = a.axes.get_xaxis()
        #xax = xax.set_visible(False)
        plt.xlabel("$k~\mathrm{[kpc^{-1}]}$", fontsize=fs)
        plt.xticks(fontsize=fs)
        plt.tick_params(which="minor", right=False, top=False, direction="in", length=3, labelbottom=False)
        plt.tick_params(which="major", right=False, top=False, direction="in", length=5, labelsize=14, labelbottom=True, labelleft=True)

        #if i == (n - 1):
        #    plt.text(1.05, 0.5, 'Total', transform=axs[0, n - 1].transAxes, verticalalignment='center', rotation=270,
        #             fontsize=fs)

        #title = 'Velocity power spectrum (' + pm + str(n) + 'Mpc)'

    f.suptitle('2D velocity power spectrum on 5Mpc*5Mpc*5Mpc cubes ', fontsize=fs)
    plt.show()

def test_interpolation():

    file = "/data/cluster/tlebeau/virgo/virgo_xyz_hydro_l21.dat"

    h = FortranFile(file, 'r')
    ncell = h.read_ints()

    n_e = []
    # print("ne",n_e)

    # for i in range(0,nline):
    n_e = h.read_reals()
    # n_e=np.concatenate((n_e,n_e_line))
    # print("len ne",len(n_e))

    # plt.hist(n_e, bins=100)
    # plt.xscale('log')
    # plt.yscale('log')
    # plt.show()
    # sys.exit()

    print("t")
    t = []
    # for i in range(0, nline):
    t = h.read_reals()
    # t = np.concatenate((t, t_line))

    # plt.hist(t,bins=100)
    # plt.xscale('log')
    # plt.yscale('log')
    # plt.show()
    # sys.exit()

    print("p")
    p = []
    # for i in range(0, nline):
    p = h.read_reals()
    # p = np.concatenate((p, p_line))

    # plt.hist(p, bins=100)
    # plt.xscale('log')
    # plt.yscale('log')
    # plt.show()
    # sys.exit()

    print("x")
    x = []
    # for i in range(0, nline):
    x = h.read_reals()
    # x = np.concatenate((x, x_line))

    # print("x len",len(x))
    print("xmin", np.min(x))
    print("xmax", np.max(x))

    # print("hist x")

    # plt.hist(x, bins=100)
    # plt.show()

    # sys.exit()

    print('y')
    y = []
    # for i in range(0, nline):
    y = h.read_reals()
    #    y = np.concatenate((y, y_line))

    # print("ymin", np.min(y))
    # print("ymax", np.max(y))

    # ys.exit()

    print("z")
    z = []
    # for i in range(0, nline):
    z = h.read_reals()
    #    z = np.concatenate((z, z_line))

    # plt.hist(z, bins=100)
    # plt.show()
    # sys.exit()

    # print("zmin", np.min(z))
    # print("zmax", np.max(z))

    # sys.exit()

    print("vx")
    vx = []
    # for i in range(0, nline):
    vx = h.read_reals()
    #    vx = np.concatenate((vx, vx_line))

    print("vy")
    vy = []
    # for i in range(0, nline):
    vy = h.read_reals()
    #   vy = np.concatenate((vy, vy_line))

    print("vz")
    vz = []
    # for i in range(0, nline):
    vz = h.read_reals()
    #    vz = np.concatenate((vz, vz_line))

    print("m")
    m = []
    # for i in range(0, nline):
    m = h.read_reals()
    #    m = np.concatenate((m, m_line))

    print("mass min", np.min(m))
    print("mass max", np.max(m))
    # sys.exit()

    # plt.hist(np.log10(m),bins=100,range=[2,7.2])
    # plt.show()
    # sys.exit()

    print("lvl")
    lvl = []
    # for i in range(0, nline):
    lvl = h.read_reals()
    #    lvl = np.concatenate((lvl, lvl_line))

    # print("max lvl",np.max(lvl))
    # print("min lvl",np.min(lvl))

    # sys.exit()

    # plt.hist2d(m,lvl,bins=[100,9],range=[[1E2,1E7],[11,19]])
    # plt.show()

    # sys.exit()

    # plt.scatter(m,lvl)
    # plt.show()
    # sys.exit()

    m_cumul_ba = np.zeros(21)

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

    print("x_cen", x_cen, "y_cen", y_cen, "z_cen", z_cen)

    x -= x_cen
    y -= y_cen
    z -= z_cen

    #x += 20000
    #y += 20000
    #z += 20

    #plt.hist(x,bins=100)
    #plt.show()
    #sys.exit()

    vx_virgo = -509.1301
    vy_virgo = 228.9488
    vz_virgo = -131.9249

    vx -= vx_virgo
    vy -= vy_virgo
    vz -= vz_virgo

    cond = np.logical_and(x>-10000,np.logical_and(x<10000,np.logical_and(y>-10000,np.logical_and(y<10000,np.logical_and(z>-100,z<100)))))

    #from scipy.interpolate import RegularGridInterpolator
    #from scipy.interpolate import LinearNDInterpolator
    from scipy.interpolate import griddata

    grid_size = 888  # Example grid size
    grid = np.linspace(-10000, 10000, grid_size)
    grid_z = np.linspace(-100, 100, 10)
    X, Y, Z = np.meshgrid(grid, grid, grid_z, indexing='ij')


    def test_griddata():
        def function(x,y,z):
            return x+y+z

        test = np.random.rand(100,3)
        #val = np.ones(100)
        val = function(test[:,0],test[:,1],test[:,2])
        test_grid = np.linspace(0,1,100)
        X,Y,Z = np.meshgrid(test_grid,test_grid,test_grid)
        test_result = griddata(test[:,0:3],val,(X,Y,Z),method='linear')

        f,ax = plt.subplots(1,1)

        im = ax.imshow(test_result[:,:,50],cmap='cividis',origin='lower',alpha=1,extent=[0,1,0,1])
        f.colorbar(im)

        cond = np.logical_and(test[:,2]>0.4,test[:,2]<0.6)
        ax.plot(test[:,0][cond], test[:,1][cond],'o')

        plt.show()
        sys.exit()

    #test_griddata()

    # Interpolate the AMR data onto the uniform grid
    print("doing interpolation")
    start = time.time()

    #interpolator_vx = RegularGridInterpolator((x[cond], y[cond], z[cond]), vx[cond])
    #interpolator_vy = RegularGridInterpolator((x[cond], y[cond], z[cond]), vy[cond])
    #interpolator_vz = RegularGridInterpolator((x[cond], y[cond], z[cond]), vz[cond])

    #print("vx[cond]",vx[cond])
    #print("min vx[cond]",np.min(vx[cond]))
    #print("max vx[cond]",np.max(vx[cond]))

    #sys.exit()

    #interpolator_vx = LinearNDInterpolator((x[cond], y[cond], z[cond]), vx[cond])

    #print("vx part 1 done")

    #interpolator_vy = LinearNDInterpolator((x[cond], y[cond], z[cond]), vy[cond])

    #print("vy part 1 done")

    #interpolator_vz = LinearNDInterpolator((x[cond], y[cond], z[cond]), vz[cond])

    #print("vz part 1 done")

    #vx_uniform = interpolator_vx((X, Y, Z))

    #print("vx part 2 done")

    #vy_uniform = interpolator_vy((X, Y, Z))

    #print("vy part 2 done")

    #vz_uniform = interpolator_vz((X, Y, Z))

    #print("vz part 2 done")

    vx_uniform = griddata((x[cond], y[cond], z[cond]), vx[cond], (X, Y, Z), method='linear')

    end = time.time()

    print("interpolation done, time =",end-start)

    print("vx_uniform",vx_uniform)
    print('min vx',np.min(vx_uniform))
    print('max vx',np.max(vx_uniform))
    print('shape vx',np.shape(vx_uniform))

    #sys.exit()

    #v = np.sqrt(vx_uniform ** 2 + vy_uniform ** 2 + vz_uniform ** 2)



    print("plotting")

    vmin = 0
    vmax = 1200

    colormap = "cividis"

    nx, ny, nz = np.shape(v)

    lvl = 15

    dimx = (nx / 2) * (737.441 / 2 ** lvl)
    dimy = dimx

    dim = [-dimx, dimx, -dimy, dimy]

    #cb = f.colorbar(im, ax=axs.ravel().tolist(),label='velocity $[\mathrm{km\,s^{-1}}]$')  # ,size='small')#,shrink=0.6)
    #cb.ax.tick_params(labelsize=fs)


    im = plt.imshow(vx_uniform[:,:,4],cmap=colormap, origin="lower", alpha=1, extent=dim)#, vmin=vmin, vmax=vmax)
    plt.colorbar(im, label='velocity $[\mathrm{km\,s^{-1}}]$')
    plt.show()

def energy_spectrum():

    print('loading files')

    vx = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_10x10x20Mpc_cube.bin.npy')
    vy = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_10x10x20Mpc_cube.bin.npy')
    vz = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_10x10x20Mpc_cube.bin.npy')

    vx_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_comp_10x10x20Mpc_cube.bin.npy')
    vy_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_comp_10x10x20Mpc_cube.bin.npy')
    vz_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_comp_10x10x20Mpc_cube.bin.npy')

    vx_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_sol_10x10x20Mpc_cube.bin.npy')
    vy_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_sol_10x10x20Mpc_cube.bin.npy')
    vz_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_sol_10x10x20Mpc_cube.bin.npy')

    print('files loaded')

    nx, ny, nz = np.shape(vx)

    print("nx",nx,"ny",ny,"nz",nz)

    #Set centered cube of 5Mpc width

    fs = 10
    # Plot the power spectrum
    f, axs = plt.subplots(3,5, figsize=(20, 12), constrained_layout=True)

    for i in range(0,5):

        print("i",i)

        shiftx = ny/10 #=1 Mpc
        shifty = ny/10 #=1 Mpc

        if i == 0:
            shiftx *= -4
            shifty *= 1.5
        if i == 1:
            shiftx *= -2
            shifty *= 0
        if i == 2:
            shiftx *= 0
            shifty *= 0
        if i == 3:
            shiftx *= 2
            shifty *= 0
        if i == 4:
            shiftx *= 4
            shifty *= -1

        #print("shiftx",shiftx)

        vx5 = np.array(vx[int(nx/2-nx/8+shiftx):int(nx/2+nx/8+shiftx),int(ny/4+shifty):int(3*ny/4+shifty),int(nz/4):int(3*nz/4)],dtype=np.float32)
        vy5 = np.array(vy[int(nx/2-nx/8+shiftx):int(nx/2+nx/8+shiftx),int(ny/4+shifty):int(3*ny/4+shifty),int(nz/4):int(3*nz/4)],dtype=np.float32)
        vz5 = np.array(vz[int(nx/2-nx/8+shiftx):int(nx/2+nx/8+shiftx),int(ny/4+shifty):int(3*ny/4+shifty),int(nz/4):int(3*nz/4)],dtype=np.float32)

        vx_comp5 = np.array(vx_comp[int(nx/2-nx/8+shiftx):int(nx/2+nx/8+shiftx),int(ny/4+shifty):int(3*ny/4+shifty),int(nz/4):int(3*nz/4)],dtype=np.float32)
        vy_comp5 = np.array(vy_comp[int(nx/2-nx/8+shiftx):int(nx/2+nx/8+shiftx),int(ny/4+shifty):int(3*ny/4+shifty),int(nz/4):int(3*nz/4)],dtype=np.float32)
        vz_comp5 = np.array(vz_comp[int(nx/2-nx/8+shiftx):int(nx/2+nx/8+shiftx),int(ny/4+shifty):int(3*ny/4+shifty),int(nz/4):int(3*nz/4)],dtype=np.float32)

        vx_sol5 = np.array(vx_sol[int(nx/2-nx/8+shiftx):int(nx/2+nx/8+shiftx),int(ny/4+shifty):int(3*ny/4+shifty),int(nz/4):int(3*nz/4)],dtype=np.float32)
        vy_sol5 = np.array(vy_sol[int(nx/2-nx/8+shiftx):int(nx/2+nx/8+shiftx),int(ny/4+shifty):int(3*ny/4+shifty),int(nz/4):int(3*nz/4)],dtype=np.float32)
        vz_sol5 = np.array(vz_sol[int(nx/2-nx/8+shiftx):int(nx/2+nx/8+shiftx),int(ny/4+shifty):int(3*ny/4+shifty),int(nz/4):int(3*nz/4)],dtype=np.float32)

        # Set centered cube of 2Mpc width
        offsetx = 0
        offsety = 0
        offsetz = 0
        if i==0:
            offsety = 1
            offsetz = 1

        if i==1:
            offsetx = 1
            offsety = 1
            offsetz = 1

        if i == 2:
            offsetx=1
            offsety=1
            offsetz=1

        if i == 3:
            offsetx=1
            offsety=1
            offsetz=1

        v_sol2_offset = 0

        if i == 4:
            offsetx=1
            offsety=0
            offsetz=1
            v_sol2_offset = 1

        #print("shiftx",shiftx)


        vx2 = np.array(vx[int(nx / 2 - nx / 20+shiftx):int(nx / 2 + nx / 20-offsetx+shiftx), int(ny / 2 - ny / 10+shifty):int(ny / 2 + ny / 10-offsety+shifty ), int(nz / 2 - nz / 10 ):int(nz / 2 + nz / 10-offsetz)],dtype=np.float32)
        vy2 = np.array(vy[int(nx / 2 - nx / 20+shiftx):int(nx / 2 + nx / 20-offsetx+shiftx), int(ny / 2 - ny / 10+shifty):int(ny / 2 + ny / 10-offsety+shifty ), int(nz / 2 - nz / 10 ):int(nz / 2 + nz / 10-offsetz)],dtype=np.float32)
        vz2 = np.array(vz[int(nx / 2 - nx / 20+shiftx):int(nx / 2 + nx / 20-offsetx+shiftx), int(ny / 2 - ny / 10+shifty):int(ny / 2 + ny / 10-offsety+shifty ), int(nz / 2 - nz / 10 ):int(nz / 2 + nz / 10-offsetz)],dtype=np.float32)

        vx_comp2 = np.array(vx_comp[int(nx / 2 - nx / 20+shiftx):int(nx / 2 + nx / 20-offsetx+shiftx), int(ny / 2 - ny / 10+shifty):int(ny / 2 + ny / 10-offsety+shifty ), int(nz / 2 - nz / 10 ):int(nz / 2 + nz / 10-offsetz)],dtype=np.float32)
        vy_comp2 = np.array(vy_comp[int(nx / 2 - nx / 20+shiftx):int(nx / 2 + nx / 20-offsetx+shiftx), int(ny / 2 - ny / 10+shifty):int(ny / 2 + ny / 10-offsety+shifty ), int(nz / 2 - nz / 10 ):int(nz / 2 + nz / 10-offsetz)],dtype=np.float32)
        vz_comp2 = np.array(vz_comp[int(nx / 2 - nx / 20+shiftx):int(nx / 2 + nx / 20-offsetx+shiftx), int(ny / 2 - ny / 10+shifty):int(ny / 2 + ny / 10-offsety+shifty ), int(nz / 2 - nz / 10 ):int(nz / 2 + nz / 10-offsetz)],dtype=np.float32)

        vx_sol2 = np.array(vx_sol[int(nx / 2 - nx / 20+shiftx):int(nx / 2 + nx / 20-offsetx+shiftx), int(ny / 2 - ny / 10 ):int(ny / 2 + ny / 10 -offsety - v_sol2_offset), int(nz / 2 - nz / 10 ):int(nz / 2 + nz / 10-offsetz)],dtype=np.float32)
        vy_sol2 = np.array(vy_sol[int(nx / 2 - nx / 20+shiftx):int(nx / 2 + nx / 20-offsetx+shiftx), int(ny / 2 - ny / 10 ):int(ny / 2 + ny / 10 -offsety - v_sol2_offset), int(nz / 2 - nz / 10 ):int(nz / 2 + nz / 10-offsetz)],dtype=np.float32)
        vz_sol2 = np.array(vz_sol[int(nx / 2 - nx / 20+shiftx):int(nx / 2 + nx / 20-offsetx+shiftx), int(ny / 2 - ny / 10 ):int(ny / 2 + ny / 10 -offsety - v_sol2_offset), int(nz / 2 - nz / 10 ):int(nz / 2 + nz / 10-offsetz)],dtype=np.float32)

        # Set centered cube of 1Mpc width

        if i==0:
            offsetx = 0
            offsety = 0
            offsetz = 1

        if i==1:
            offsetx = 0
            offsety = 1
            offsetz = 1

        if i==4:
            offsetx = 0
            offsety = 0
            offsetz = 1

        vx1 = np.array(vx[int(nx / 2 - nx / 40+shiftx):int(nx / 2 + nx / 40-offsetx+shiftx), int(ny / 2 - ny / 20 +shifty ):int(ny / 2 + ny / 20 +shifty-offsety), int(nz / 2 - nz / 20 ):int(nz / 2 + nz / 20-offsetz)],dtype=np.float32)
        vy1 = np.array(vy[int(nx / 2 - nx / 40+shiftx):int(nx / 2 + nx / 40-offsetx+shiftx), int(ny / 2 - ny / 20 +shifty ):int(ny / 2 + ny / 20 +shifty-offsety), int(nz / 2 - nz / 20 ):int(nz / 2 + nz / 20-offsetz)],dtype=np.float32)
        vz1 = np.array(vz[int(nx / 2 - nx / 40+shiftx):int(nx / 2 + nx / 40-offsetx+shiftx), int(ny / 2 - ny / 20 +shifty ):int(ny / 2 + ny / 20 +shifty-offsety), int(nz / 2 - nz / 20 ):int(nz / 2 + nz / 20-offsetz)],dtype=np.float32)

        vx_comp1 = np.array(vx_comp[int(nx / 2 - nx / 40+shiftx):int(nx / 2 + nx / 40-offsetx+shiftx), int(ny / 2 - ny / 20 +shifty ):int(ny / 2 + ny / 20 +shifty-offsety), int(nz / 2 - nz / 20 ):int(nz / 2 + nz / 20-offsetz)],dtype=np.float32)
        vy_comp1 = np.array(vy_comp[int(nx / 2 - nx / 40+shiftx):int(nx / 2 + nx / 40-offsetx+shiftx), int(ny / 2 - ny / 20 +shifty ):int(ny / 2 + ny / 20 +shifty-offsety), int(nz / 2 - nz / 20 ):int(nz / 2 + nz / 20-offsetz)],dtype=np.float32)
        vz_comp1 = np.array(vz_comp[int(nx / 2 - nx / 40+shiftx):int(nx / 2 + nx / 40-offsetx+shiftx), int(ny / 2 - ny / 20 +shifty ):int(ny / 2 + ny / 20 +shifty-offsety), int(nz / 2 - nz / 20 ):int(nz / 2 + nz / 20-offsetz)],dtype=np.float32)

        vx_sol1 = np.array(vx_sol[int(nx / 2 - nx / 40+shiftx):int(nx / 2 + nx / 40-offsetx+shiftx), int(ny / 2 - ny / 20 +shifty ):int(ny / 2 + ny / 20 +shifty-offsety), int(nz / 2 - nz / 20 ):int(nz / 2 + nz / 20-offsetz)],dtype=np.float32)
        vy_sol1 = np.array(vy_sol[int(nx / 2 - nx / 40+shiftx):int(nx / 2 + nx / 40-offsetx+shiftx), int(ny / 2 - ny / 20 +shifty ):int(ny / 2 + ny / 20 +shifty-offsety), int(nz / 2 - nz / 20 ):int(nz / 2 + nz / 20-offsetz)],dtype=np.float32)
        vz_sol1 = np.array(vz_sol[int(nx / 2 - nx / 40+shiftx):int(nx / 2 + nx / 40-offsetx+shiftx), int(ny / 2 - ny / 20 +shifty ):int(ny / 2 + ny / 20 +shifty-offsety), int(nz / 2 - nz / 20 ):int(nz / 2 + nz / 20-offsetz)],dtype=np.float32)

        print("shape vx5",np.shape(vx5))
        print("shape vx2",np.shape(vx2))
        print("shape vx1",np.shape(vx1))

        #sys.exit()

        def manual_energy_spectrum_3D():
            print("fft")

            start = time.time()


            vxk5 = np.fft.fftn(vx5)
            vyk5 = np.fft.fftn(vy5)
            vzk5 = np.fft.fftn(vz5)

            vxk_comp5 = np.fft.fftn(vx_comp5)
            vyk_comp5 = np.fft.fftn(vy_comp5)
            vzk_comp5 = np.fft.fftn(vz_comp5)

            vxk_sol5 = np.fft.fftn(vx_sol5)
            vyk_sol5 = np.fft.fftn(vy_sol5)
            vzk_sol5 = np.fft.fftn(vz_sol5)

            vxk2 = np.fft.fftn(vx2)
            vyk2 = np.fft.fftn(vy2)
            vzk2 = np.fft.fftn(vz2)

            vxk_comp2 = np.fft.fftn(vx_comp2)
            vyk_comp2 = np.fft.fftn(vy_comp2)
            vzk_comp2 = np.fft.fftn(vz_comp2)

            vxk_sol2 = np.fft.fftn(vx_sol2)
            vyk_sol2 = np.fft.fftn(vy_sol2)
            vzk_sol2 = np.fft.fftn(vz_sol2)

            vxk1 = np.fft.fftn(vx1)
            vyk1 = np.fft.fftn(vy1)
            vzk1 = np.fft.fftn(vz1)

            vxk_comp1 = np.fft.fftn(vx_comp1)
            vyk_comp1 = np.fft.fftn(vy_comp1)
            vzk_comp1 = np.fft.fftn(vz_comp1)

            vxk_sol1 = np.fft.fftn(vx_sol1)
            vyk_sol1 = np.fft.fftn(vy_sol1)
            vzk_sol1 = np.fft.fftn(vz_sol1)

            end = time.time()

            print("fft done, time =",end-start)

            ekv5 = 0.5 * (np.abs(vxk5) ** 2 + np.abs(vyk5) ** 2 + np.abs(vzk5) ** 2)
            ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
            ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

            ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
            ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
            ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

            ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
            ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
            ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

        size = 5000

        Pk = PKL.Pk(vx5, size)
        k5 = Pk.k3D
        Pk_vx5 = Pk.Pk[:, 0]

        Pk = PKL.Pk(vy5, size)
        Pk_vy5 = Pk.Pk[:, 0]

        Pk = PKL.Pk(vz5, size)
        Pk_vz5 = Pk.Pk[:, 0]

        Pkcomp = PKL.Pk(vx_comp5, size)
        kcomp = Pkcomp.k3D
        Pk_vx5_comp = Pkcomp.Pk[:, 0]

        Pkcomp = PKL.Pk(vy_comp5, size)
        Pk_vy5_comp = Pkcomp.Pk[:, 0]

        Pkcomp = PKL.Pk(vz_comp5, size)
        Pk_vz5_comp = Pkcomp.Pk[:, 0]

        Pksol = PKL.Pk(vx_sol5, size)
        ksol = Pksol.k3D
        Pk_vx5_sol = Pksol.Pk[:, 0]

        Pksol = PKL.Pk(vy_sol5, size)
        Pk_vy5_sol = Pksol.Pk[:, 0]

        Pksol = PKL.Pk(vz_sol5, size)
        Pk_vz5_sol = Pksol.Pk[:, 0]

        ekv5 = 0.5 * (np.abs(Pk_vx5) + np.abs(Pk_vy5) + np.abs(Pk_vz5))
        ekv_comp5 = 0.5 * (np.abs(Pk_vx5_comp) + np.abs(Pk_vy5_comp) + np.abs(Pk_vz5_comp))
        ekv_sol5 = 0.5 * (np.abs(Pk_vx5_sol) + np.abs(Pk_vy5_sol) + np.abs(Pk_vz5_sol))

        size = 2000

        Pk = PKL.Pk(vx2, size)
        k2 = Pk.k3D
        Pk_vx2 = Pk.Pk[:, 0]

        Pk = PKL.Pk(vy2, size)
        Pk_vy2 = Pk.Pk[:, 0]

        Pk = PKL.Pk(vz2, size)
        Pk_vz2 = Pk.Pk[:, 0]

        Pkcomp = PKL.Pk(vx_comp2, size)
        kcomp = Pkcomp.k3D
        Pk_vx2_comp = Pkcomp.Pk[:, 0]

        Pkcomp = PKL.Pk(vy_comp2, size)
        Pk_vy2_comp = Pkcomp.Pk[:, 0]

        Pkcomp = PKL.Pk(vz_comp2, size)
        Pk_vz2_comp = Pkcomp.Pk[:, 0]

        Pksol = PKL.Pk(vx_sol2, size)
        ksol = Pksol.k3D
        Pk_vx2_sol = Pksol.Pk[:, 0]

        Pksol = PKL.Pk(vy_sol2, size)
        Pk_vy2_sol = Pksol.Pk[:, 0]

        Pksol = PKL.Pk(vz_sol2, size)
        Pk_vz2_sol = Pksol.Pk[:, 0]

        ekv2 = 0.5 * (np.abs(Pk_vx2) + np.abs(Pk_vy2) + np.abs(Pk_vz2))
        ekv_comp2 = 0.5 * (np.abs(Pk_vx2_comp) + np.abs(Pk_vy2_comp) + np.abs(Pk_vz2_comp))
        ekv_sol2 = 0.5 * (np.abs(Pk_vx2_sol) + np.abs(Pk_vy2_sol) + np.abs(Pk_vz2_sol))

        size = 1000

        Pk = PKL.Pk(vx1, size)
        k1 = Pk.k3D
        Pk_vx1 = Pk.Pk[:, 0]

        Pk = PKL.Pk(vy1, size)
        Pk_vy1 = Pk.Pk[:, 0]

        Pk = PKL.Pk(vz1, size)
        Pk_vz1 = Pk.Pk[:, 0]

        Pkcomp = PKL.Pk(vx_comp1, size)
        kcomp = Pkcomp.k3D
        Pk_vx1_comp = Pkcomp.Pk[:, 0]

        Pkcomp = PKL.Pk(vy_comp1, size)
        Pk_vy1_comp = Pkcomp.Pk[:, 0]

        Pkcomp = PKL.Pk(vz_comp1, size)
        Pk_vz1_comp = Pkcomp.Pk[:, 0]

        Pksol = PKL.Pk(vx_sol1, size)
        ksol = Pksol.k3D
        Pk_vx1_sol = Pksol.Pk[:, 0]

        Pksol = PKL.Pk(vy_sol1, size)
        Pk_vy1_sol = Pksol.Pk[:, 0]

        Pksol = PKL.Pk(vz_sol1, size)
        Pk_vz1_sol = Pksol.Pk[:, 0]

        ekv1 = 0.5 * (np.abs(Pk_vx1) + np.abs(Pk_vy1) + np.abs(Pk_vz1))
        ekv_comp1 = 0.5 * (np.abs(Pk_vx1_comp) + np.abs(Pk_vy1_comp) + np.abs(Pk_vz1_comp))
        ekv_sol1 = 0.5 * (np.abs(Pk_vx1_sol) + np.abs(Pk_vy1_sol) + np.abs(Pk_vz1_sol))



        #ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
        #ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

        #ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
        #ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
        #ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

        #ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
        #ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
        #ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

        #ekv = 0.5*(vxk*np.conj(vxk)+vyk*np.conj(vyk)+vzk*np.conj(vzk))



        #print("ekv",ekv)
        #print("ekv_test",ekv_test)
        #print("diff",ekv-ekv_test)

        #sys.exit()



        #kx = np.fft.fftfreq(nx).reshape(nx, 1, 1)
        #ky = np.fft.fftfreq(ny).reshape(nz, 1)
        #kz = np.fft.fftfreq(nz)



        # print("shape kx",np.shape(kx))
        # print("shape ky",np.shape(ky))
        # print("shape kz",np.shape(kz))

        #k2 = kx ** 2 + ky ** 2 + kz ** 2

        #cf = 20000 / nx

        #cf = 1

        #print("cf",cf,"1/cf",1/cf)

        #sys.exit()

        #k5 = np.fft.fftfreq(int(ny/2),d=cf)

        #print('min k5',np.min(k5),'l max',2*np.pi/np.min(k5))
        #print('max k5',np.max(k5),'l min',2*np.pi/np.max(k5))

        #print('len k5',len(k5))
        #print('k5',k5)
        #sys.exit()
        #k5 = np.fft.fftfreq(5000, d=cf)
        #k = fftshift(k)
        #k5 = np.sqrt(k5[:, None, None] ** 2 + k5[None, :, None] ** 2 + k5[None, None, :] ** 2)
        #print('k5 sqrt',k5)

        # Bin the power spectrum
        #k_bins5 = np.linspace(0, np.max(k5), num=100)

        #print('k_bins5',k_bins5)

        #sys.exit()

        #k2 = np.fft.fftfreq(int(ny / 5),d=cf)  # , d=10000/ny)
        #k2 = np.fft.fftfreq(2000, d=cf)
        # k = fftshift(k)
        #k2 = np.sqrt(k2[:, None, None] ** 2 + k2[None, :, None] ** 2 + k2[None, None, :] ** 2)

        # Bin the power spectrum
        #k_bins2 = np.linspace(0, np.max(k2), num=50)

        #k1 = np.fft.fftfreq(int(ny / 10),d=cf)  # , d=10000/ny)
        #k1 = np.fft.fftfreq(1000, d=cf)  # , d=10000/ny)
        # k = fftshift(k)
        #k1 = np.sqrt(k1[:, None, None] ** 2 + k1[None, :, None] ** 2 + k1[None, None, :] ** 2)

        # Bin the power spectrum
        #k_bins1 = np.linspace(0, np.max(k1), num=25)

        #ekv_binned5 = np.zeros(len(k_bins5) - 1)
        #ekv_comp_binned5 = np.zeros(len(k_bins5) - 1)
        #ekv_sol_binned5 = np.zeros(len(k_bins5) - 1)

        #ekv_binned2 = np.zeros(len(k_bins2) - 1)
        #ekv_comp_binned2 = np.zeros(len(k_bins2) - 1)
        #ekv_sol_binned2 = np.zeros(len(k_bins2) - 1)

        #ekv_binned1 = np.zeros(len(k_bins1) - 1)
        #ekv_comp_binned1 = np.zeros(len(k_bins1) - 1)
        #ekv_sol_binned1 = np.zeros(len(k_bins1) - 1)

        #for i in range(len(k_bins5) - 1):
        #    mask = (k5 >= k_bins5[i]) & (k5 < k_bins5[i + 1])

        #    ekv_binned5[i] = np.mean(ekv5[mask])
        #    ekv_comp_binned5[i] = np.mean(ekv_comp5[mask])
        #    ekv_sol_binned5[i] = np.mean(ekv_sol5[mask])

        #for i in range(len(k_bins2) - 1):
            #print("i",i)
        #    mask = (k2 >= k_bins2[i]) & (k2 < k_bins2[i + 1])

            #print("len(k2)",len(k2))
            #print("len(k_bins2)",len(k_bins2))
            #print("len(ekv2)",len(ekv2))

        #    ekv_binned2[i] = np.mean(ekv2[mask])
        #    ekv_comp_binned2[i] = np.mean(ekv_comp2[mask])
        #    ekv_sol_binned2[i] = np.mean(ekv_sol2[mask])

        #for i in range(len(k_bins1) - 1):
        #    mask = (k1 >= k_bins1[i]) & (k1 < k_bins1[i + 1])

        #    ekv_binned1[i] = np.mean(ekv1[mask])
        #    ekv_comp_binned1[i] = np.mean(ekv_comp1[mask])
        #    ekv_sol_binned1[i] = np.mean(ekv_sol1[mask])

        def k_to_l(k):
            return 2 * np.pi / k

        def l_to_k(l):
            return 2 * np.pi / l

        #cf = 20000/nx #kpc per voxel in the matrix = physical distance between 2 points in the matrix


        plt.sca(axs[0,i])
        #plt.figure(figsize=(8, 6))

        plt.loglog(k5, ekv5, label='Total, 5Mpc',ls="solid", color="black",alpha=0.7,marker=".",ms=4)
        plt.loglog(k5, ekv_comp5, label='Compressive 5Mpc',color="blue",alpha=0.7,marker=".",ms=4)
        plt.loglog(k5, ekv_sol5, label='Solenoidal 5Mpc',color="red",alpha=0.7,marker=".",ms=4)

        secax = axs[0,i].secondary_xaxis('top', functions=(k_to_l, l_to_k))
        secax.set_xlabel(r'$L=\frac{2\pi}{k}$ [kpc]', fontsize=fs)
        secax.tick_params(labelsize=fs)

        title = "$\Delta x_{cen}$=" + str(round(2 * i - 4, 3)) + " Mpc"

        plt.title(title, fontsize=fs)
        plt.xticks([])

        plt.xlim(0.001,0.3)

        if i==0 :
            plt.ylabel('E(k)',fontsize=fs)
            plt.yticks(fontsize=fs)
        else:
            plt.yticks([])

        plt.legend(fontsize=fs)

        plt.sca(axs[1,i])

        plt.loglog(k2, ekv2, label='Total, 2Mpc',ls="dashed", color="black",alpha=0.7,marker="D",ms=2)
        plt.loglog(k2, ekv_comp2, label='Compressive 2Mpc',ls="dashed",color="blue",alpha=0.7,marker="D",ms=2)
        plt.loglog(k2, ekv_sol2, label='Solenoidal 2Mpc',ls="dashed",color="red",alpha=0.7,marker="D",ms=2)

        if i==0 :
            plt.ylabel('E(k)',fontsize=fs)
            plt.yticks(fontsize=fs)
        else:
            plt.yticks([])

        plt.xticks([])

        plt.legend(fontsize=fs)

        plt.xlim(0.001, 0.3)


        plt.sca(axs[2,i])

        plt.loglog(k1, ekv1, label='Total, 1Mpc',ls="dotted", color="black",alpha=0.7,marker="s",ms=2)
        plt.loglog(k1, ekv_comp1, label='Compressive 1Mpc',ls="dotted",color="blue",alpha=0.7,marker="s",ms=2)
        plt.loglog(k1, ekv_sol1, label='Solenoidal 1Mpc',ls="dotted",color="red",alpha=0.7,marker="s",ms=2)

        plt.xlabel("$k~\mathrm{[kpc^{-1}]}$", fontsize=fs)
        plt.xticks(fontsize=fs)

        if i==0 :
            plt.ylabel('E(k)',fontsize=fs)
            plt.yticks(fontsize=fs)
        else:
            plt.yticks([])

        plt.xlim(0.001, 0.3)



        plt.legend(fontsize=fs)
    #plt.grid(True)
    plt.suptitle('3D Velocity Power Spectrum',fontsize=fs+2)
    plt.show()


def energy_spectrum_2D():
    print('loading files')

    vx = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_12x12x20Mpc_cube.bin.npy')
    vy = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_12x12x20Mpc_cube.bin.npy')
    vz = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_12x12x20Mpc_cube.bin.npy')

    vx_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_comp_12x12x20Mpc_cube.bin.npy')
    vy_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_comp_12x12x20Mpc_cube.bin.npy')
    vz_comp = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_comp_12x12x20Mpc_cube.bin.npy')

    vx_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_sol_12x12x20Mpc_cube.bin.npy')
    vy_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_sol_12x12x20Mpc_cube.bin.npy')
    vz_sol = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_sol_12x12x20Mpc_cube.bin.npy')

    print('files loaded')

    nx, ny, nz = np.shape(vx)

    print("nx", nx, "ny", ny, "nz", nz)

    # Set centered cube of 5Mpc width

    fs = 10
    # Plot the power spectrum
    f, axs = plt.subplots(3, 8, figsize=(20, 12), constrained_layout=True)

    for i in range(0,8):

        print("i", i)

        offsety=0
        offsetz=0

        shiftx = nx / 20  # =1 Mpc
        shifty = nx / 20  # =1 Mpc
        shiftz = nx / 20

        if i == 0:
            shiftx *= -8
            shifty *= 3.5
            shiftz *= 1.5

            #print("shiftx",shiftx)
            #print("shifty",shifty)
            #print("shiftz",shiftz)

            #sys.exit()

        if i == 1:
            shiftx *= -6
            shifty *= 1.5
            shiftz *= 1

        if i == 2:
            shiftx *= -4
            shifty *= 1.5
            shiftz *= 0.5
            #offsety=1

        if i == 3:
            shiftx *= -2
            shifty *= 0
            shiftz *= 0

        if i == 4:
            shiftx *= 0
            shifty *= 0
            shiftz *= 0

        if i == 5:
            shiftx *= 2
            shifty *= 0
            shiftz *= 0

        if i == 6:
            shiftx *= 4
            shifty *= -1
            shiftz *= 0
            #offsety=1

        if i == 7:
            shiftx *= 6
            shifty *= -2.5
            shiftz *= -0.5

        # print("shiftx",shiftx)

        vx5 = np.array(vx[int(nx / 2 + shiftx), int(ny * (3.5/12) + shifty):int(ny * (8.5/12) + shifty - offsety), int(nz * (3.5/12) + shiftz):int(nz * (8.5/12) + shiftz )], dtype=np.float32)
        vy5 = np.array(vy[int(nx / 2 + shiftx), int(ny * (3.5/12) + shifty):int(ny * (8.5/12) + shifty - offsety), int(nz * (3.5/12) + shiftz):int(nz * (8.5/12) + shiftz)], dtype=np.float32)
        vz5 = np.array(vz[int(nx / 2 + shiftx), int(ny * (3.5/12) + shifty):int(ny * (8.5/12) + shifty - offsety), int(nz * (3.5/12) + shiftz):int(nz * (8.5/12) + shiftz)], dtype=np.float32)

        vx_comp5 = np.array(vx_comp[int(nx / 2 + shiftx), int(ny * (3.5/12) + shifty):int(ny * (8.5/12) + shifty - offsety), int(nz * (3.5/12) + shiftz):int(nz * (8.5/12) + shiftz)],dtype=np.float32)
        vy_comp5 = np.array(vy_comp[int(nx / 2 + shiftx), int(ny * (3.5/12) + shifty):int(ny * (8.5/12) + shifty - offsety), int(nz * (3.5/12) + shiftz):int(nz * (8.5/12) + shiftz)],dtype=np.float32)
        vz_comp5 = np.array(vz_comp[int(nx / 2 + shiftx), int(ny * (3.5/12) + shifty):int(ny * (8.5/12) + shifty - offsety), int(nz * (3.5/12) + shiftz):int(nz * (8.5/12) + shiftz)],dtype=np.float32)

        vx_sol5 = np.array(vx_sol[int(nx / 2 + shiftx), int(ny * (3.5/12) + shifty):int(ny * (8.5/12) + shifty - offsety), int(nz * (3.5/12) + shiftz):int(nz * (8.5/12) + shiftz)],dtype=np.float32)
        vy_sol5 = np.array(vy_sol[int(nx / 2 + shiftx), int(ny * (3.5/12) + shifty):int(ny * (8.5/12) + shifty - offsety), int(nz * (3.5/12) + shiftz):int(nz * (8.5/12) + shiftz)],dtype=np.float32)
        vz_sol5 = np.array(vz_sol[int(nx / 2 + shiftx), int(ny * (3.5/12) + shifty):int(ny * (8.5/12) + shifty - offsety), int(nz * (3.5/12) + shiftz):int(nz * (8.5/12) + shiftz)],dtype=np.float32)

        print("substracting mean")

        print("mean vx5",np.mean(vx5))

        vx5-=np.mean(vx5)

        print("mean vx5",np.mean(vx5))

        sys.exit()

        vy5-=np.mean(vy5)
        vz5-=np.mean(vz5)

        vx_comp5-=np.mean(vx_comp5)
        vy_comp5-=np.mean(vy_comp5)
        vz_comp5-=np.mean(vz_comp5)

        vx_sol5-=np.mean(vx_sol5)
        vy_sol5-=np.mean(vy_sol5)
        vz_sol5-=np.mean(vz_sol5)

        # Set centered cube of 2Mpc width
        offsetx = 0
        offsety = 0
        offsetz = 0
        v_sol2_offset = 0

        if i==0:
            v_sol2_offset = -1

        if i==1:
            v_sol2_offset = -1

        if i == 2:
            offsety = 1
            offsetz = 1
            v_sol2_offset = -1

        if i == 3:
            #offsetx = 1
            offsety = 1
            offsetz = 1

        if i == 4:
            offsetx = 1
            offsety = 1
            offsetz = 1

        if i == 5:
            offsetx = 1
            offsety = 1
            offsetz = 1

        if i == 6:
            offsetx = 1
            offsety = 1
            offsetz = 0
            v_sol2_offset = -1

        if i == 7:
            offsetz=1

        # print("shiftx",shiftx)

        vx2 = np.array(vx[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                       int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vy2 = np.array(vy[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                       int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vz2 = np.array(vz[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                       int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

        vx_comp2 = np.array(vx_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                            int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vy_comp2 = np.array(vy_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                            int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vz_comp2 = np.array(vz_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                            int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

        vx_sol2 = np.array(vx_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vy_sol2 = np.array(vy_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vz_sol2 = np.array(vz_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

        # Set centered cube of 1Mpc width

        offsetx = 0
        offsety = 0
        offsetz = 0

        if i == 2:
            offsetx = 0
            offsety = 1
            #offsetz = 1

        if i == 3:
            offsetx = 0
            offsety = 1
            offsetz = 1

        if i == 6:
            offsetx = 0
            offsety = 1
            #offsetz = 1

        #if i==7:

            #offsety=1

        vx1 = np.array(vx[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vy1 = np.array(vy[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vz1 = np.array(vz[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

        vx_comp1 = np.array(vx_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                            int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vy_comp1 = np.array(vy_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                            int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vz_comp1 = np.array(vz_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                            int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

        vx_sol1 = np.array(vx_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vy_sol1 = np.array(vy_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vz_sol1 = np.array(vz_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

        print("shape vx5", np.shape(vx5),"shape vy5", np.shape(vy5),"shape vz5", np.shape(vz5))
        print("shape vx_comp5", np.shape(vx_comp5),"shape vy_comp5", np.shape(vy_comp5),"shape vz_comp5", np.shape(vz_comp5))
        print("shape vx_sol5", np.shape(vx_sol5),"shape vy_sol5", np.shape(vy_sol5),"shape vz_sol5", np.shape(vz_sol5))

        print("shape vx2", np.shape(vx2), "shape vy2", np.shape(vy2), "shape vz2", np.shape(vz2))
        print("shape vx_comp2", np.shape(vx_comp2), "shape vy_comp2", np.shape(vy_comp2), "shape vz_comp2", np.shape(vz_comp2))
        print("shape vx_sol2", np.shape(vx_sol2), "shape vy_sol2", np.shape(vy_sol2), "shape vz_sol2", np.shape(vz_sol2))

        print("shape vx1", np.shape(vx1), "shape vy1", np.shape(vy1), "shape vz1", np.shape(vz1))
        print("shape vx_comp1", np.shape(vx_comp1), "shape vy_comp1", np.shape(vy_comp1), "shape vz_comp1", np.shape(vz_comp1))
        print("shape vx_sol1", np.shape(vx_sol1), "shape vy_sol1", np.shape(vy_sol1), "shape vz_sol1", np.shape(vz_sol1))

        # sys.exit()

        def manual_energy_spectrum_3D():
            print("fft")

            start = time.time()

            vxk5 = np.fft.fftn(vx5)
            vyk5 = np.fft.fftn(vy5)
            vzk5 = np.fft.fftn(vz5)

            vxk_comp5 = np.fft.fftn(vx_comp5)
            vyk_comp5 = np.fft.fftn(vy_comp5)
            vzk_comp5 = np.fft.fftn(vz_comp5)

            vxk_sol5 = np.fft.fftn(vx_sol5)
            vyk_sol5 = np.fft.fftn(vy_sol5)
            vzk_sol5 = np.fft.fftn(vz_sol5)

            vxk2 = np.fft.fftn(vx2)
            vyk2 = np.fft.fftn(vy2)
            vzk2 = np.fft.fftn(vz2)

            vxk_comp2 = np.fft.fftn(vx_comp2)
            vyk_comp2 = np.fft.fftn(vy_comp2)
            vzk_comp2 = np.fft.fftn(vz_comp2)

            vxk_sol2 = np.fft.fftn(vx_sol2)
            vyk_sol2 = np.fft.fftn(vy_sol2)
            vzk_sol2 = np.fft.fftn(vz_sol2)

            vxk1 = np.fft.fftn(vx1)
            vyk1 = np.fft.fftn(vy1)
            vzk1 = np.fft.fftn(vz1)

            vxk_comp1 = np.fft.fftn(vx_comp1)
            vyk_comp1 = np.fft.fftn(vy_comp1)
            vzk_comp1 = np.fft.fftn(vz_comp1)

            vxk_sol1 = np.fft.fftn(vx_sol1)
            vyk_sol1 = np.fft.fftn(vy_sol1)
            vzk_sol1 = np.fft.fftn(vz_sol1)

            end = time.time()

            print("fft done, time =", end - start)

            ekv5 = 0.5 * (np.abs(vxk5) ** 2 + np.abs(vyk5) ** 2 + np.abs(vzk5) ** 2)
            ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
            ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

            ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
            ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
            ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

            ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
            ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
            ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

        #Pk = PKL.Pk_plane(vpk, size)
        #k = Pk.k
        #Pk = Pk.Pk

        #Pkcomp = PKL.Pk_plane(vcomppk, size)
        #kcomp = Pkcomp.k
        #Pkcomp = Pkcomp.Pk

        #Pksol = PKL.Pk_plane(vsolpk, size)
        #ksol = Pksol.k
        #Pksol = Pksol.Pk

        size = 5000

        Pk = PKL.Pk_plane(vx5, size)
        k5 = Pk.k
        Pk_vx5 = Pk.Pk

        Pk = PKL.Pk_plane(vy5, size)
        Pk_vy5 = Pk.Pk

        Pk = PKL.Pk_plane(vz5, size)
        Pk_vz5 = Pk.Pk

        Pkcomp = PKL.Pk_plane(vx_comp5, size)
        kcomp = Pkcomp.k
        Pk_vx5_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vy_comp5, size)
        Pk_vy5_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vz_comp5, size)
        Pk_vz5_comp = Pkcomp.Pk

        Pksol = PKL.Pk_plane(vx_sol5, size)
        ksol = Pksol.k
        Pk_vx5_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vy_sol5, size)
        Pk_vy5_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vz_sol5, size)
        Pk_vz5_sol = Pksol.Pk

        ekv5 = 0.5 * (np.abs(Pk_vx5) + np.abs(Pk_vy5) + np.abs(Pk_vz5))

        #print("ekv5",ekv5)
        #test_ekv5 = 0.5 * (Pk_vx5 + Pk_vy5 + Pk_vz5)
        #print("test_ekv5",test_ekv5)
        #print("diff",ekv5-test_ekv5)
        #sys.exit()

        ekv_comp5 = 0.5 * (np.abs(Pk_vx5_comp) + np.abs(Pk_vy5_comp) + np.abs(Pk_vz5_comp))
        ekv_sol5 = 0.5 * (np.abs(Pk_vx5_sol) + np.abs(Pk_vy5_sol) + np.abs(Pk_vz5_sol))

        size = 2000

        Pk = PKL.Pk_plane(vx2, size)
        k2 = Pk.k
        Pk_vx2 = Pk.Pk

        Pk = PKL.Pk_plane(vy2, size)
        Pk_vy2 = Pk.Pk

        Pk = PKL.Pk_plane(vz2, size)
        Pk_vz2 = Pk.Pk

        Pkcomp = PKL.Pk_plane(vx_comp2, size)
        kcomp = Pkcomp.k
        Pk_vx2_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vy_comp2, size)
        Pk_vy2_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vz_comp2, size)
        Pk_vz2_comp = Pkcomp.Pk

        Pksol = PKL.Pk_plane(vx_sol2, size)
        ksol = Pksol.k
        Pk_vx2_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vy_sol2, size)
        Pk_vy2_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vz_sol2, size)
        Pk_vz2_sol = Pksol.Pk

        ekv2 = 0.5 * (np.abs(Pk_vx2) + np.abs(Pk_vy2) + np.abs(Pk_vz2))
        ekv_comp2 = 0.5 * (np.abs(Pk_vx2_comp) + np.abs(Pk_vy2_comp) + np.abs(Pk_vz2_comp))
        ekv_sol2 = 0.5 * (np.abs(Pk_vx2_sol) + np.abs(Pk_vy2_sol) + np.abs(Pk_vz2_sol))

        size = 1000

        Pk = PKL.Pk_plane(vx1, size)
        k1 = Pk.k
        Pk_vx1 = Pk.Pk

        Pk = PKL.Pk_plane(vy1, size)
        Pk_vy1 = Pk.Pk

        Pk = PKL.Pk_plane(vz1, size)
        Pk_vz1 = Pk.Pk

        Pkcomp = PKL.Pk_plane(vx_comp1, size)
        kcomp = Pkcomp.k
        Pk_vx1_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vy_comp1, size)
        Pk_vy1_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vz_comp1, size)
        Pk_vz1_comp = Pkcomp.Pk

        Pksol = PKL.Pk_plane(vx_sol1, size)
        ksol = Pksol.k
        Pk_vx1_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vy_sol1, size)
        Pk_vy1_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vz_sol1, size)
        Pk_vz1_sol = Pksol.Pk

        ekv1 = 0.5 * (np.abs(Pk_vx1) + np.abs(Pk_vy1) + np.abs(Pk_vz1))
        ekv_comp1 = 0.5 * (np.abs(Pk_vx1_comp) + np.abs(Pk_vy1_comp) + np.abs(Pk_vz1_comp))
        ekv_sol1 = 0.5 * (np.abs(Pk_vx1_sol) + np.abs(Pk_vy1_sol) + np.abs(Pk_vz1_sol))

        # ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
        # ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

        # ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
        # ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
        # ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

        # ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
        # ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
        # ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

        # ekv = 0.5*(vxk*np.conj(vxk)+vyk*np.conj(vyk)+vzk*np.conj(vzk))

        # print("ekv",ekv)
        # print("ekv_test",ekv_test)
        # print("diff",ekv-ekv_test)

        # sys.exit()

        # kx = np.fft.fftfreq(nx).reshape(nx, 1, 1)
        # ky = np.fft.fftfreq(ny).reshape(nz, 1)
        # kz = np.fft.fftfreq(nz)

        # print("shape kx",np.shape(kx))
        # print("shape ky",np.shape(ky))
        # print("shape kz",np.shape(kz))

        # k2 = kx ** 2 + ky ** 2 + kz ** 2

        # cf = 20000 / nx

        # cf = 1

        # print("cf",cf,"1/cf",1/cf)

        # sys.exit()

        # k5 = np.fft.fftfreq(int(ny/2),d=cf)

        # print('min k5',np.min(k5),'l max',2*np.pi/np.min(k5))
        # print('max k5',np.max(k5),'l min',2*np.pi/np.max(k5))

        # print('len k5',len(k5))
        # print('k5',k5)
        # sys.exit()
        # k5 = np.fft.fftfreq(5000, d=cf)
        # k = fftshift(k)
        # k5 = np.sqrt(k5[:, None, None] ** 2 + k5[None, :, None] ** 2 + k5[None, None, :] ** 2)
        # print('k5 sqrt',k5)

        # Bin the power spectrum
        # k_bins5 = np.linspace(0, np.max(k5), num=100)

        # print('k_bins5',k_bins5)

        # sys.exit()

        # k2 = np.fft.fftfreq(int(ny / 5),d=cf)  # , d=10000/ny)
        # k2 = np.fft.fftfreq(2000, d=cf)
        # k = fftshift(k)
        # k2 = np.sqrt(k2[:, None, None] ** 2 + k2[None, :, None] ** 2 + k2[None, None, :] ** 2)

        # Bin the power spectrum
        # k_bins2 = np.linspace(0, np.max(k2), num=50)

        # k1 = np.fft.fftfreq(int(ny / 10),d=cf)  # , d=10000/ny)
        # k1 = np.fft.fftfreq(1000, d=cf)  # , d=10000/ny)
        # k = fftshift(k)
        # k1 = np.sqrt(k1[:, None, None] ** 2 + k1[None, :, None] ** 2 + k1[None, None, :] ** 2)

        # Bin the power spectrum
        # k_bins1 = np.linspace(0, np.max(k1), num=25)

        # ekv_binned5 = np.zeros(len(k_bins5) - 1)
        # ekv_comp_binned5 = np.zeros(len(k_bins5) - 1)
        # ekv_sol_binned5 = np.zeros(len(k_bins5) - 1)

        # ekv_binned2 = np.zeros(len(k_bins2) - 1)
        # ekv_comp_binned2 = np.zeros(len(k_bins2) - 1)
        # ekv_sol_binned2 = np.zeros(len(k_bins2) - 1)

        # ekv_binned1 = np.zeros(len(k_bins1) - 1)
        # ekv_comp_binned1 = np.zeros(len(k_bins1) - 1)
        # ekv_sol_binned1 = np.zeros(len(k_bins1) - 1)

        # for i in range(len(k_bins5) - 1):
        #    mask = (k5 >= k_bins5[i]) & (k5 < k_bins5[i + 1])

        #    ekv_binned5[i] = np.mean(ekv5[mask])
        #    ekv_comp_binned5[i] = np.mean(ekv_comp5[mask])
        #    ekv_sol_binned5[i] = np.mean(ekv_sol5[mask])

        # for i in range(len(k_bins2) - 1):
        # print("i",i)
        #    mask = (k2 >= k_bins2[i]) & (k2 < k_bins2[i + 1])

        # print("len(k2)",len(k2))
        # print("len(k_bins2)",len(k_bins2))
        # print("len(ekv2)",len(ekv2))

        #    ekv_binned2[i] = np.mean(ekv2[mask])
        #    ekv_comp_binned2[i] = np.mean(ekv_comp2[mask])
        #    ekv_sol_binned2[i] = np.mean(ekv_sol2[mask])

        # for i in range(len(k_bins1) - 1):
        #    mask = (k1 >= k_bins1[i]) & (k1 < k_bins1[i + 1])

        #    ekv_binned1[i] = np.mean(ekv1[mask])
        #    ekv_comp_binned1[i] = np.mean(ekv_comp1[mask])
        #    ekv_sol_binned1[i] = np.mean(ekv_sol1[mask])

        def k_to_l(k):
            return 2 * np.pi / k

        def l_to_k(l):
            return 2 * np.pi / l

        # cf = 20000/nx #kpc per voxel in the matrix = physical distance between 2 points in the matrix

        plt.sca(axs[0, i])
        # plt.figure(figsize=(8, 6))

        l1 = plt.loglog(k5, ekv5, label='Total', ls="solid", color="black", alpha=0.7, marker=".", ms=4)
        l2 = plt.loglog(k5, ekv_comp5, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        l3 = plt.loglog(k5, ekv_sol5, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)


        secax = axs[0, i].secondary_xaxis('top', functions=(k_to_l, l_to_k))
        secax.set_xlabel(r'$L=\frac{2\pi}{k}$ [kpc]', fontsize=fs)
        secax.tick_params(labelsize=fs)

        title = "$\Delta x_{cen}$=" + str(round(2 * i - 8, 3)) + " Mpc"

        plt.title(title, fontsize=fs)
        #plt.xticks([])

        plt.xlim(0.0014, 0.1)
        plt.ylim(1e4,1e12)

        if i == 0:
            plt.ylabel('E(k)', fontsize=fs)
            plt.yticks(fontsize=fs)
        else:
            #plt.yticks([])
            axs[0, i].tick_params(labelleft=False)

        if i==7:
            plt.text(1.05, 0.5, '5 Mpc square maps', transform=axs[0, 7].transAxes, verticalalignment='center',rotation=270, fontsize=fs)

        #plt.yticks(fontsize=fs)
        #plt.xticks(fontsize=fs)

        axs[0, i].tick_params(labelbottom=False)

        #plt.legend(fontsize=fs)

        plt.sca(axs[1, i])

        plt.loglog(k2, ekv2, label='Total', ls="solid", color="black", alpha=0.7, marker=".", ms=4)
        plt.loglog(k2, ekv_comp2, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        plt.loglog(k2, ekv_sol2, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

        if i == 0:
            plt.ylabel('E(k)', fontsize=fs)
            plt.yticks(fontsize=fs)
        else:
            #plt.yticks([])
            axs[1, i].tick_params(labelleft=False)

        if i==7:
            plt.text(1.05, 0.5, '2 Mpc square maps', transform=axs[1, 7].transAxes, verticalalignment='center',rotation=270, fontsize=fs)

        if i==4:
            plt.legend(fontsize=fs)

        #plt.xticks([])
        #plt.yticks(fontsize=fs)

        axs[1, i].tick_params(labelbottom=False)

        #plt.legend(fontsize=fs)

        plt.xlim(0.0014, 0.1)
        plt.ylim(1e4,1e12)



        plt.sca(axs[2, i])

        plt.loglog(k1, ekv1, label='Total', ls="solid", color="black", alpha=0.7, marker=".", ms=4)
        plt.loglog(k1, ekv_comp1, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        plt.loglog(k1, ekv_sol1, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

        plt.xlabel("$k~\mathrm{[kpc^{-1}]}$", fontsize=fs)
        plt.xticks(fontsize=fs)

        if i == 0:
            plt.ylabel('E(k)', fontsize=fs)
            plt.yticks(fontsize=fs)
        else:
            #plt.yticks([])
            axs[2, i].tick_params(labelleft=False)

        if i==7:
            plt.text(1.05, 0.5, '1 Mpc square maps', transform=axs[2, 7].transAxes, verticalalignment='center',rotation=270, fontsize=fs)

        #plt.yticks(fontsize=fs)

        plt.xlim(0.0014, 0.1)
        plt.ylim(1e4,1e12)

        #plt.legend(fontsize=fs)
    # plt.grid(True)
    plt.suptitle('2D Velocity Power Spectrum', fontsize=fs + 2)
    #f.legend([l1,l2,l3], labels=['Total','Compressive','Solenoidal'], loc='upper right', fontsize=fs)#, bbox_to_anchor=(0.5, 0.5))
    plt.show()


def energy_spectrum_2D_two_col(type):
    print('loading files')

    vx = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_12x12x20Mpc_cube.bin.npy')
    vy = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_12x12x20Mpc_cube.bin.npy')
    vz = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_12x12x20Mpc_cube.bin.npy')

    vx_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_comp_12x12x20Mpc_cube.bin.npy')
    vy_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_comp_12x12x20Mpc_cube.bin.npy')
    vz_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_comp_12x12x20Mpc_cube.bin.npy')

    vx_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_sol_12x12x20Mpc_cube.bin.npy')
    vy_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_sol_12x12x20Mpc_cube.bin.npy')
    vz_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_sol_12x12x20Mpc_cube.bin.npy')

    print('files loaded')

    nx, ny, nz = np.shape(vx)

    print("nx", nx, "ny", ny, "nz", nz)

    # Set centered cube of 5Mpc width

    fs = 14
    # Plot the power spectrum
    f, axs = plt.subplots(3, 2, figsize=(8, 8), constrained_layout=True)
    #f, axs = plt.subplots(1, 1, figsize=(8, 8), constrained_layout=True)

    # Define a colormap from red to black
    cmap = plt.cm.get_cmap('Reds', 256)  # Using 'Reds' as the base colormap
    cmap = cmap(np.linspace(0.5, 1, 256))  # Adjusting the colormap to range from dark red to black

    # Create a gradient from red to black with 5 colors
    colors = [cmap[i] for i in np.linspace(0, len(cmap) - 1, 5, dtype=int)]

    def log_power_law(x,a,k):
        return np.log10(a)+k*np.log10(x)

    def power_law(x,a,k):
        return a*x**k

    k_fit_5 = np.zeros((8,2))
    k_fit_2 = np.zeros((8,2))
    k_fit_1 = np.zeros((8,2))

    a_fit_5 = np.zeros((8,2))
    a_fit_2 = np.zeros((8,2))
    a_fit_1 = np.zeros((8,2))


    for i in range(0, 5):

        def compute_ek():

            print("i", i)

            offsety = 0
            offsetz = 0

            shiftx = nx / 20  # =1 Mpc
            shifty = nx / 20  # =1 Mpc
            shiftz = nx / 20

            if i == 0:
                shiftx *= -8
                shifty *= 3.5
                shiftz *= 1.5

                # print("shiftx",shiftx)
                # print("shifty",shifty)
                # print("shiftz",shiftz)

                # sys.exit()

            if i == 1:
                shiftx *= -6
                shifty *= 1.5
                shiftz *= 1

            if i == 2:
                shiftx *= -4
                shifty *= 1.5
                shiftz *= 0.5
                # offsety=1

            if i == 3:
                shiftx *= -2
                shifty *= 0
                shiftz *= 0

            if i == 4:
                shiftx *= 0
                shifty *= 0
                shiftz *= 0

            if i == 5:
                shiftx *= 2
                shifty *= 0
                shiftz *= 0

            if i == 6:
                shiftx *= 4
                shifty *= -1
                shiftz *= 0
                # offsety=1

            if i == 7:
                shiftx *= 6
                shifty *= -2.5
                shiftz *= -0.5

            # print("shiftx",shiftx)

            vx5 = np.array(vx[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                           int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vy5 = np.array(vy[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                           int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vz5 = np.array(vz[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                           int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

            vx_comp5 = np.array(
                vx_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vy_comp5 = np.array(
                vy_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vz_comp5 = np.array(
                vz_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

            vx_sol5 = np.array(
                vx_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vy_sol5 = np.array(
                vy_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vz_sol5 = np.array(
                vz_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

            # Set centered cube of 2Mpc width
            offsetx = 0
            offsety = 0
            offsetz = 0
            v_sol2_offset = 0

            if i == 0:
                v_sol2_offset = -1

            if i == 1:
                v_sol2_offset = -1

            if i == 2:
                offsety = 1
                offsetz = 1
                v_sol2_offset = -1

            if i == 3:
                # offsetx = 1
                offsety = 1
                offsetz = 1

            if i == 4:
                offsetx = 1
                offsety = 1
                offsetz = 1

            if i == 5:
                offsetx = 1
                offsety = 1
                offsetz = 1

            if i == 6:
                offsetx = 1
                offsety = 1
                offsetz = 0
                v_sol2_offset = -1

            if i == 7:
                offsetz = 1

            # print("shiftx",shiftx)

            vx2 = np.array(vx[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vy2 = np.array(vy[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vz2 = np.array(vz[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

            vx_comp2 = np.array(vx_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                                int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vy_comp2 = np.array(vy_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                                int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vz_comp2 = np.array(vz_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                                int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

            vx_sol2 = np.array(vx_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                               int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vy_sol2 = np.array(vy_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                               int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vz_sol2 = np.array(vz_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                               int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

            # Set centered cube of 1Mpc width

            offsetx = 0
            offsety = 0
            offsetz = 0

            if i == 2:
                offsetx = 0
                offsety = 1
                # offsetz = 1

            if i == 3:
                offsetx = 0
                offsety = 1
                offsetz = 1

            if i == 6:
                offsetx = 0
                offsety = 1
                # offsetz = 1

            # if i==7:

            # offsety=1

            vx1 = np.array(vx[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vy1 = np.array(vy[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vz1 = np.array(vz[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

            vx_comp1 = np.array(vx_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vy_comp1 = np.array(vy_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vz_comp1 = np.array(vz_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

            vx_sol1 = np.array(vx_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vy_sol1 = np.array(vy_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vz_sol1 = np.array(vz_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

            print("shape vx5", np.shape(vx5), "shape vy5", np.shape(vy5), "shape vz5", np.shape(vz5))
            print("shape vx_comp5", np.shape(vx_comp5), "shape vy_comp5", np.shape(vy_comp5), "shape vz_comp5",
                  np.shape(vz_comp5))
            print("shape vx_sol5", np.shape(vx_sol5), "shape vy_sol5", np.shape(vy_sol5), "shape vz_sol5",
                  np.shape(vz_sol5))

            print("shape vx2", np.shape(vx2), "shape vy2", np.shape(vy2), "shape vz2", np.shape(vz2))
            print("shape vx_comp2", np.shape(vx_comp2), "shape vy_comp2", np.shape(vy_comp2), "shape vz_comp2",
                  np.shape(vz_comp2))
            print("shape vx_sol2", np.shape(vx_sol2), "shape vy_sol2", np.shape(vy_sol2), "shape vz_sol2",
                  np.shape(vz_sol2))

            print("shape vx1", np.shape(vx1), "shape vy1", np.shape(vy1), "shape vz1", np.shape(vz1))
            print("shape vx_comp1", np.shape(vx_comp1), "shape vy_comp1", np.shape(vy_comp1), "shape vz_comp1",
                  np.shape(vz_comp1))
            print("shape vx_sol1", np.shape(vx_sol1), "shape vy_sol1", np.shape(vy_sol1), "shape vz_sol1",
                  np.shape(vz_sol1))

            # sys.exit()

            def manual_energy_spectrum_3D():
                print("fft")

                start = time.time()

                vxk5 = np.fft.fftn(vx5)
                vyk5 = np.fft.fftn(vy5)
                vzk5 = np.fft.fftn(vz5)

                vxk_comp5 = np.fft.fftn(vx_comp5)
                vyk_comp5 = np.fft.fftn(vy_comp5)
                vzk_comp5 = np.fft.fftn(vz_comp5)

                vxk_sol5 = np.fft.fftn(vx_sol5)
                vyk_sol5 = np.fft.fftn(vy_sol5)
                vzk_sol5 = np.fft.fftn(vz_sol5)

                vxk2 = np.fft.fftn(vx2)
                vyk2 = np.fft.fftn(vy2)
                vzk2 = np.fft.fftn(vz2)

                vxk_comp2 = np.fft.fftn(vx_comp2)
                vyk_comp2 = np.fft.fftn(vy_comp2)
                vzk_comp2 = np.fft.fftn(vz_comp2)

                vxk_sol2 = np.fft.fftn(vx_sol2)
                vyk_sol2 = np.fft.fftn(vy_sol2)
                vzk_sol2 = np.fft.fftn(vz_sol2)

                vxk1 = np.fft.fftn(vx1)
                vyk1 = np.fft.fftn(vy1)
                vzk1 = np.fft.fftn(vz1)

                vxk_comp1 = np.fft.fftn(vx_comp1)
                vyk_comp1 = np.fft.fftn(vy_comp1)
                vzk_comp1 = np.fft.fftn(vz_comp1)

                vxk_sol1 = np.fft.fftn(vx_sol1)
                vyk_sol1 = np.fft.fftn(vy_sol1)
                vzk_sol1 = np.fft.fftn(vz_sol1)

                end = time.time()

                print("fft done, time =", end - start)

                ekv5 = 0.5 * (np.abs(vxk5) ** 2 + np.abs(vyk5) ** 2 + np.abs(vzk5) ** 2)
                ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
                ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

                ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
                ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
                ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

                ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
                ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
                ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

            # Pk = PKL.Pk_plane(vpk, size)
            # k = Pk.k
            # Pk = Pk.Pk

            # Pkcomp = PKL.Pk_plane(vcomppk, size)
            # kcomp = Pkcomp.k
            # Pkcomp = Pkcomp.Pk

            # Pksol = PKL.Pk_plane(vsolpk, size)
            # ksol = Pksol.k
            # Pksol = Pksol.Pk

            size = 5000

            Pk = PKL.Pk_plane(vx5, size)
            k5 = Pk.k
            Pk_vx5 = Pk.Pk

            Pk = PKL.Pk_plane(vy5, size)
            Pk_vy5 = Pk.Pk

            Pk = PKL.Pk_plane(vz5, size)
            Pk_vz5 = Pk.Pk

            Pkcomp = PKL.Pk_plane(vx_comp5, size)
            kcomp = Pkcomp.k
            Pk_vx5_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vy_comp5, size)
            Pk_vy5_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vz_comp5, size)
            Pk_vz5_comp = Pkcomp.Pk

            Pksol = PKL.Pk_plane(vx_sol5, size)
            ksol = Pksol.k
            Pk_vx5_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vy_sol5, size)
            Pk_vy5_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vz_sol5, size)
            Pk_vz5_sol = Pksol.Pk

            ekv5 = 0.5 * (np.abs(Pk_vx5) + np.abs(Pk_vy5) + np.abs(Pk_vz5))
            ekv_comp5 = 0.5 * (np.abs(Pk_vx5_comp) + np.abs(Pk_vy5_comp) + np.abs(Pk_vz5_comp))
            ekv_sol5 = 0.5 * (np.abs(Pk_vx5_sol) + np.abs(Pk_vy5_sol) + np.abs(Pk_vz5_sol))

            size = 2000

            Pk = PKL.Pk_plane(vx2, size)
            k2 = Pk.k
            Pk_vx2 = Pk.Pk

            Pk = PKL.Pk_plane(vy2, size)
            Pk_vy2 = Pk.Pk

            Pk = PKL.Pk_plane(vz2, size)
            Pk_vz2 = Pk.Pk

            Pkcomp = PKL.Pk_plane(vx_comp2, size)
            kcomp = Pkcomp.k
            Pk_vx2_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vy_comp2, size)
            Pk_vy2_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vz_comp2, size)
            Pk_vz2_comp = Pkcomp.Pk

            Pksol = PKL.Pk_plane(vx_sol2, size)
            ksol = Pksol.k
            Pk_vx2_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vy_sol2, size)
            Pk_vy2_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vz_sol2, size)
            Pk_vz2_sol = Pksol.Pk

            ekv2 = 0.5 * (np.abs(Pk_vx2) + np.abs(Pk_vy2) + np.abs(Pk_vz2))
            ekv_comp2 = 0.5 * (np.abs(Pk_vx2_comp) + np.abs(Pk_vy2_comp) + np.abs(Pk_vz2_comp))
            ekv_sol2 = 0.5 * (np.abs(Pk_vx2_sol) + np.abs(Pk_vy2_sol) + np.abs(Pk_vz2_sol))

            size = 1000

            Pk = PKL.Pk_plane(vx1, size)
            k1 = Pk.k
            Pk_vx1 = Pk.Pk

            Pk = PKL.Pk_plane(vy1, size)
            Pk_vy1 = Pk.Pk

            Pk = PKL.Pk_plane(vz1, size)
            Pk_vz1 = Pk.Pk

            Pkcomp = PKL.Pk_plane(vx_comp1, size)
            kcomp = Pkcomp.k
            Pk_vx1_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vy_comp1, size)
            Pk_vy1_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vz_comp1, size)
            Pk_vz1_comp = Pkcomp.Pk

            Pksol = PKL.Pk_plane(vx_sol1, size)
            ksol = Pksol.k
            Pk_vx1_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vy_sol1, size)
            Pk_vy1_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vz_sol1, size)
            Pk_vz1_sol = Pksol.Pk

            ekv1 = 0.5 * (np.abs(Pk_vx1) + np.abs(Pk_vy1) + np.abs(Pk_vz1))
            ekv_comp1 = 0.5 * (np.abs(Pk_vx1_comp) + np.abs(Pk_vy1_comp) + np.abs(Pk_vz1_comp))
            ekv_sol1 = 0.5 * (np.abs(Pk_vx1_sol) + np.abs(Pk_vy1_sol) + np.abs(Pk_vz1_sol))

            return k1, k2, k5, ekv5, ekv_comp5, ekv_sol5, ekv2, ekv_comp2, ekv_sol2, ekv1, ekv_comp1, ekv_sol1

        k1, k2, k5, ekv5, ekv_comp5, ekv_sol5, ekv2, ekv_comp2, ekv_sol2, ekv1, ekv_comp1, ekv_sol1 = compute_ek()

        # ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
        # ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

        # ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
        # ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
        # ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

        # ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
        # ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
        # ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

        # ekv = 0.5*(vxk*np.conj(vxk)+vyk*np.conj(vyk)+vzk*np.conj(vzk))

        # print("ekv",ekv)
        # print("ekv_test",ekv_test)
        # print("diff",ekv-ekv_test)

        # sys.exit()

        # kx = np.fft.fftfreq(nx).reshape(nx, 1, 1)
        # ky = np.fft.fftfreq(ny).reshape(nz, 1)
        # kz = np.fft.fftfreq(nz)

        # print("shape kx",np.shape(kx))
        # print("shape ky",np.shape(ky))
        # print("shape kz",np.shape(kz))

        # k2 = kx ** 2 + ky ** 2 + kz ** 2

        # cf = 20000 / nx

        # cf = 1

        # print("cf",cf,"1/cf",1/cf)

        # sys.exit()

        # k5 = np.fft.fftfreq(int(ny/2),d=cf)

        # print('min k5',np.min(k5),'l max',2*np.pi/np.min(k5))
        # print('max k5',np.max(k5),'l min',2*np.pi/np.max(k5))

        # print('len k5',len(k5))
        # print('k5',k5)
        # sys.exit()
        # k5 = np.fft.fftfreq(5000, d=cf)
        # k = fftshift(k)
        # k5 = np.sqrt(k5[:, None, None] ** 2 + k5[None, :, None] ** 2 + k5[None, None, :] ** 2)
        # print('k5 sqrt',k5)

        # Bin the power spectrum
        # k_bins5 = np.linspace(0, np.max(k5), num=100)

        # print('k_bins5',k_bins5)

        # sys.exit()

        # k2 = np.fft.fftfreq(int(ny / 5),d=cf)  # , d=10000/ny)
        # k2 = np.fft.fftfreq(2000, d=cf)
        # k = fftshift(k)
        # k2 = np.sqrt(k2[:, None, None] ** 2 + k2[None, :, None] ** 2 + k2[None, None, :] ** 2)

        # Bin the power spectrum
        # k_bins2 = np.linspace(0, np.max(k2), num=50)

        # k1 = np.fft.fftfreq(int(ny / 10),d=cf)  # , d=10000/ny)
        # k1 = np.fft.fftfreq(1000, d=cf)  # , d=10000/ny)
        # k = fftshift(k)
        # k1 = np.sqrt(k1[:, None, None] ** 2 + k1[None, :, None] ** 2 + k1[None, None, :] ** 2)

        # Bin the power spectrum
        # k_bins1 = np.linspace(0, np.max(k1), num=25)

        # ekv_binned5 = np.zeros(len(k_bins5) - 1)
        # ekv_comp_binned5 = np.zeros(len(k_bins5) - 1)
        # ekv_sol_binned5 = np.zeros(len(k_bins5) - 1)

        # ekv_binned2 = np.zeros(len(k_bins2) - 1)
        # ekv_comp_binned2 = np.zeros(len(k_bins2) - 1)
        # ekv_sol_binned2 = np.zeros(len(k_bins2) - 1)

        # ekv_binned1 = np.zeros(len(k_bins1) - 1)
        # ekv_comp_binned1 = np.zeros(len(k_bins1) - 1)
        # ekv_sol_binned1 = np.zeros(len(k_bins1) - 1)

        # for i in range(len(k_bins5) - 1):
        #    mask = (k5 >= k_bins5[i]) & (k5 < k_bins5[i + 1])

        #    ekv_binned5[i] = np.mean(ekv5[mask])
        #    ekv_comp_binned5[i] = np.mean(ekv_comp5[mask])
        #    ekv_sol_binned5[i] = np.mean(ekv_sol5[mask])

        # for i in range(len(k_bins2) - 1):
        # print("i",i)
        #    mask = (k2 >= k_bins2[i]) & (k2 < k_bins2[i + 1])

        # print("len(k2)",len(k2))
        # print("len(k_bins2)",len(k_bins2))
        # print("len(ekv2)",len(ekv2))

        #    ekv_binned2[i] = np.mean(ekv2[mask])
        #    ekv_comp_binned2[i] = np.mean(ekv_comp2[mask])
        #    ekv_sol_binned2[i] = np.mean(ekv_sol2[mask])

        # for i in range(len(k_bins1) - 1):
        #    mask = (k1 >= k_bins1[i]) & (k1 < k_bins1[i + 1])

        #    ekv_binned1[i] = np.mean(ekv1[mask])
        #    ekv_comp_binned1[i] = np.mean(ekv_comp1[mask])
        #    ekv_sol_binned1[i] = np.mean(ekv_sol1[mask])

        def k_to_l(k):
            return 2 * np.pi / k

        def l_to_k(l):
            return 2 * np.pi / l

        # cf = 20000/nx #kpc per voxel in the matrix = physical distance between 2 points in the matrix

        plt.sca(axs[0,0])


        # plt.figure(figsize=(8, 6))

        #label="x-x_{Virgo}=" + str(round(2 * i - 8, 3)) + " Mpc"

        label = str(round(2 * i - 8, 3))

        if type=='ratio_cs':
            l1 = plt.loglog(k5, ekv_comp5/ekv_sol5, label=label, ls="solid", alpha=1, marker=".", ms=4, color=colors[i])

        elif type=='ratio_st':

            l1 = plt.loglog(k5, ekv_sol5 / ekv5, label=label, ls="dashed", alpha=1, marker=".", ms=4,color=colors[i])

            #l1 = plt.loglog(k5, ekv_comp5 / ekv5, label=label, ls="dashed", alpha=0.6, marker=".", ms=4, color=colors[i])

        else:

            #print("k5",k5)

            #sys.exit()



            #popt, pcov = curve_fit(power_law, k5[cond], ekv5[cond])

            #x = np.log10(k5[cond])
            #y = np.log10(ekv5[cond])

           #print("x",x)
           #print("y",y)

            cond = np.logical_and(k5 > 0.0015, k5 < 0.095)

            #cond = np.logical_and(k5 > 0.0035, k5 < 0.095)

            print('test')

            popt, pcov = curve_fit(log_power_law, k5[cond], np.log10(ekv5[cond]), p0=[100,-3.5], bounds=([0, -10], [1e5, -2]))

            print("popt",popt)
            print("pcov",pcov)

            k_fit_5[i,0]=popt[1]
            k_fit_5[i,1]=np.sqrt(pcov[1,1])

            a_fit_5[i,0]=popt[0]
            a_fit_5[i,1]=np.sqrt(pcov[0,0])

            #print("k_fit",k_fit)

            #sys.exit()

            popt_test=[20,-3]


            l1 = plt.loglog(k5[cond], ekv5[cond], label=label, ls="solid", alpha=1, marker=".", ms=4, color=colors[i])

            plt.loglog(k5[cond], power_law(k5[cond], *popt), ls="dotted", color='green', alpha=0.7)
            #plt.loglog(k5[cond], power_law(k5[cond], *popt_test), ls="dotted", color='blue', alpha=0.7)
            #plt.loglog(k5, power_law(k5, *popt), ls="dotted", color='green', alpha=0.7)

            #plt.show()
            #sys.exit()

            x_target = 0.015
            y_target = 1e10

            # Adjusting the prefactor so the lines pass through the target point
            kolmogorov = y_target * (k5 / x_target) ** (-11 / 3)
            burgers = y_target * (k5 / x_target) ** (-4)

            cond = np.logical_and(k5 > 0.015, k5 < 0.06)

            plt.loglog(k5[cond], kolmogorov[cond], ls="dotted", color="grey", alpha=0.7)
            plt.loglog(k5[cond], burgers[cond], ls="dotted", color="grey", alpha=0.7)
            plt.text(0.061, 8e7, '$k^{-11/3}$', fontsize=fs,color='grey')
            plt.text(0.061, 3e7, '$k^{-4}$', fontsize=fs,color='grey')

        #l2 = plt.loglog(k5, ekv_comp5, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        #l3 = plt.loglog(k5, ekv_sol5, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

        if i==0:
            secax = axs[0,0].secondary_xaxis('top', functions=(k_to_l, l_to_k))
            secax.set_xlabel(r'$L=\frac{2\pi}{k}$ [kpc]', fontsize=fs)
            secax.tick_params(labelsize=fs)

        #title = "$\Delta x_{cen}$=" + str(round(2 * i - 8, 3)) + " Mpc"

        #plt.title(title, fontsize=fs)
        # plt.xticks([])

        #plt.xlim(0.0014, 0.21)
        #plt.ylim(3e4,1e12)

        if i == 0:
            if type=='ratio_cs':
                plt.ylabel('$P(k)_{compressive}/P(k)_{solenoidal}$', fontsize=fs)
                plt.ylim(3e-2, 1.5e1)
                plt.xlim(0.0014, 0.1)

            elif type=='ratio_st':
                plt.ylabel('$P(k)_{solenoidal}/P(k)_{total}$', fontsize=fs)
                plt.ylim(1e-2, 4)
                plt.xlim(0.0014, 0.1)

            else:
                plt.ylabel('Total P(k)', fontsize=fs)
                plt.ylim(1e5, 1e12)
                plt.xlim(0.0014, 0.1)

            plt.yticks(fontsize=fs)
        #else:
            # plt.yticks([])
        #    axs[0].tick_params(labelleft=False)

        #if i == 0:
        #    plt.text(1.05, 0.5, '5 Mpc square maps', transform=axs[0].transAxes, verticalalignment='center', rotation=270,
        #             fontsize=fs + 3)

        # plt.yticks(fontsize=fs)
        # plt.xticks(fontsize=fs)

        plt.title("Background filament", fontsize=fs)

        axs[0,0].tick_params(labelbottom=False)

        #plt.legend(fontsize=fs)

        plt.sca(axs[1,0])

        if type=='ratio_cs':
            plt.loglog(k2, ekv_comp2/ekv_sol2, label=label, ls="solid", alpha=1, marker=".", ms=4, color=colors[i])

        elif type=='ratio_st':

            plt.loglog(k2, ekv_sol2 / ekv2, label=label, ls="dashed", alpha=1, marker=".", ms=4,color=colors[i])

            #plt.loglog(k2, ekv_sol2 / ekv, label=label, ls="dotted", alpha=1, marker=".", ms=4, color=colors[i])

        else:
            #cond = np.logical_and(k2 > 0.0015, k2 < 0.095)
            cond = np.logical_and(k2 > 0.006, k2 < 0.095)

            popt, pcov = curve_fit(log_power_law, k2[cond], np.log10(ekv2[cond]), p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))

            print("popt",popt)
            print("pcov",pcov)

            k_fit_2[i, 0] = popt[1]
            k_fit_2[i, 1] = np.sqrt(pcov[1, 1])

            a_fit_2[i, 0] = popt[0]
            a_fit_2[i, 1] = np.sqrt(pcov[0, 0])

            plt.loglog(k2, ekv2, label=label, ls="solid", alpha=1, marker=".", ms=4, color=colors[i])

            plt.loglog(k2[cond], power_law(k2[cond], *popt), ls="dotted", color='green', alpha=0.7)

            x_target = 0.015
            y_target = 1e10

            # Adjusting the prefactor so the lines pass through the target point
            kolmogorov = y_target * (k5 / x_target) ** (-11 / 3)
            burgers = y_target * (k5 / x_target) ** (-4)

            cond = np.logical_and(k5 > 0.015, k5 < 0.06)

            plt.loglog(k5[cond], kolmogorov[cond], ls="dotted", color="grey", alpha=0.7)
            plt.loglog(k5[cond], burgers[cond], ls="dotted", color="grey", alpha=0.7)
            plt.text(0.061, 8e7, '$k^{-11/3}$', fontsize=fs, color='grey')
            plt.text(0.061, 3e7, '$k^{-4}$', fontsize=fs, color='grey')

        #plt.loglog(k2, ekv_comp2, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        #plt.loglog(k2, ekv_sol2, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

        if i == 0:
            if type=='ratio_cs':
                plt.ylabel('$P(k)_{compressive}/P(k)_{solenoidal}$', fontsize=fs)
                plt.ylim(3e-2, 1.5e1)
                plt.xlim(0.0014, 0.1)

            elif type=='ratio_st':
                plt.ylabel('$P(k)_{solenoidal}/P(k)_{total}$', fontsize=fs)
                plt.ylim(1e-2, 4)

                plt.xlim(0.0014, 0.1)

            else:
                plt.ylabel('Total P(k)', fontsize=fs)
                plt.ylim(1e5, 1e12)
                plt.xlim(0.0014, 0.1)

            plt.yticks(fontsize=fs)
        #else:
        #    # plt.yticks([])
        #    axs[1].tick_params(labelleft=False)

        #if i == 0:
        #    plt.text(1.05, 0.5, '2 Mpc square maps', transform=axs[1].transAxes, verticalalignment='center', rotation=270,
        #             fontsize=fs + 3)

        # plt.xticks([])
        # plt.yticks(fontsize=fs)

        axs[1,0].tick_params(labelbottom=False)

        #plt.legend(fontsize=fs)

        #plt.xlim(0.0014, 0.21)
        #plt.ylim(3e4,1e12)

        plt.sca(axs[2,0])

        if type=="ratio_cs":

            plt.loglog(k1, ekv_comp1/ekv_sol1, label=label, ls="solid", alpha=1, marker=".", ms=4, color=colors[i])

        elif type=='ratio_st':

            plt.loglog(k1, ekv_sol1 / ekv1, label=label, ls="dashed", alpha=1, marker=".", ms=4,color=colors[i])

        else:
            #cond = np.logical_and(k1 > 0.0015, k1 < 0.095)
            cond = np.logical_and(k1 > 0.006, k1 < 0.095)

            popt, pcov = curve_fit(log_power_law, k1[cond], np.log10(ekv1[cond]), p0=[100, -3.5],
                                   bounds=([0, -10], [1e5, -2]))

            print("popt",popt)
            print("pcov",pcov)

            k_fit_1[i, 0] = popt[1]
            k_fit_1[i, 1] = np.sqrt(pcov[1, 1])

            a_fit_1[i, 0] = popt[0]
            a_fit_1[i, 1] = np.sqrt(pcov[0, 0])

            plt.loglog(k1, ekv1, label=label, ls="solid", alpha=1, marker=".", ms=4, color=colors[i])

            plt.loglog(k1[cond], power_law(k1[cond], *popt), ls="dotted", color='green', alpha=0.7)

            x_target = 0.015
            y_target = 1e10

            # Adjusting the prefactor so the lines pass through the target point
            kolmogorov = y_target * (k5 / x_target) ** (-11 / 3)
            burgers = y_target * (k5 / x_target) ** (-4)

            cond = np.logical_and(k5 > 0.015, k5 < 0.06)

            plt.loglog(k5[cond], kolmogorov[cond], ls="dotted", color="grey", alpha=0.7)
            plt.loglog(k5[cond], burgers[cond], ls="dotted", color="grey", alpha=0.7)
            plt.text(0.061, 8e7, '$k^{-11/3}$', fontsize=fs, color='grey')
            plt.text(0.061, 3e7, '$k^{-4}$', fontsize=fs, color='grey')

        #plt.loglog(k1, ekv_comp1, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        #plt.loglog(k1, ekv_sol1, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

        plt.xlabel("$k~\mathrm{[kpc^{-1}]}$", fontsize=fs)
        plt.xticks(fontsize=fs)

        if i == 0:
            if type=='ratio_cs':
                plt.ylabel('$P(k)_{compressive}/P(k)_{solenoidal}$', fontsize=fs)
                plt.ylim(3e-2, 1.5e1)
                plt.xlim(0.0014, 0.1)

            elif type=='ratio_st':
                plt.ylabel('$P(k)_{solenoidal}/P(k)_{total}$', fontsize=fs)
                plt.ylim(1e-2, 4)

                plt.xlim(0.0014, 0.1)
            else:
                plt.ylabel('Total P(k)', fontsize=fs)
                plt.ylim(1e5, 1e12)
                plt.xlim(0.0014, 0.1)


            plt.yticks(fontsize=fs)
        #else:
        #    # plt.yticks([])
        #    axs[2].tick_params(labelleft=False)

        #if i == 0:
        #    plt.text(1.05, 0.5, '1 Mpc square maps', transform=axs[2].transAxes, verticalalignment='center', rotation=270,
        #             fontsize=fs + 3)

        # plt.yticks(fontsize=fs)

        plt.legend(fontsize=fs, title='$\Delta x_{cen}~[Mpc]$', title_fontsize=fs,loc='lower left')




        #plt.legend(fontsize=fs)
    # plt.grid(True)
    #plt.suptitle('2D Velocity Power Spectrum Comp/Sol ratio, left filament)', fontsize=fs + 2)
    #f.legend([l1, l2, l3], labels=['Total', 'Compressive', 'Solenoidal'], loc='upper right', fontsize=fs)  # , bbox_to_anchor=(0.5, 0.5))
    #plt.show()

    # Define a colormap from blue to black
    cmap = plt.cm.get_cmap('Blues', 256)  # Using 'Blues' as the base colormap
    cmap = cmap(np.linspace(0.5, 1, 256))  # Adjusting the colormap to range from dark blue to black

    # Create a gradient from blue to black with 4 colors
    colors = [cmap[i] for i in np.linspace(0, len(cmap) - 1, 4, dtype=int)]

    #plt.show()

    for i in range(4, 8):

        def compute_ek():

            print("i", i)

            offsety = 0
            offsetz = 0

            shiftx = nx / 20  # =1 Mpc
            shifty = nx / 20  # =1 Mpc
            shiftz = nx / 20

            if i == 0:
                shiftx *= -8
                shifty *= 3.5
                shiftz *= 1.5

                # print("shiftx",shiftx)
                # print("shifty",shifty)
                # print("shiftz",shiftz)

                # sys.exit()

            if i == 1:
                shiftx *= -6
                shifty *= 1.5
                shiftz *= 1

            if i == 2:
                shiftx *= -4
                shifty *= 1.5
                shiftz *= 0.5
                # offsety=1

            if i == 3:
                shiftx *= -2
                shifty *= 0
                shiftz *= 0

            if i == 4:
                shiftx *= 0
                shifty *= 0
                shiftz *= 0

            if i == 5:
                shiftx *= 2
                shifty *= 0
                shiftz *= 0

            if i == 6:
                shiftx *= 4
                shifty *= -1
                shiftz *= 0
                # offsety=1

            if i == 7:
                shiftx *= 6
                shifty *= -2.5
                shiftz *= -0.5

            # print("shiftx",shiftx)

            vx5 = np.array(vx[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                           int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vy5 = np.array(vy[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                           int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vz5 = np.array(vz[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                           int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

            vx_comp5 = np.array(
                vx_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vy_comp5 = np.array(
                vy_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vz_comp5 = np.array(
                vz_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

            vx_sol5 = np.array(
                vx_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vy_sol5 = np.array(
                vy_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
            vz_sol5 = np.array(
                vz_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

            # Set centered cube of 2Mpc width
            offsetx = 0
            offsety = 0
            offsetz = 0
            v_sol2_offset = 0

            if i == 0:
                v_sol2_offset = -1

            if i == 1:
                v_sol2_offset = -1

            if i == 2:
                offsety = 1
                offsetz = 1
                v_sol2_offset = -1

            if i == 3:
                # offsetx = 1
                offsety = 1
                offsetz = 1

            if i == 4:
                offsetx = 1
                offsety = 1
                offsetz = 1

            if i == 5:
                offsetx = 1
                offsety = 1
                offsetz = 1

            if i == 6:
                offsetx = 1
                offsety = 1
                offsetz = 0
                v_sol2_offset = -1

            if i == 7:
                offsetz = 1

            # print("shiftx",shiftx)

            vx2 = np.array(vx[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vy2 = np.array(vy[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vz2 = np.array(vz[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

            vx_comp2 = np.array(vx_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                                int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vy_comp2 = np.array(vy_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                                int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vz_comp2 = np.array(vz_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                                int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

            vx_sol2 = np.array(vx_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                               int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vy_sol2 = np.array(vy_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                               int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
            vz_sol2 = np.array(vz_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                               int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

            # Set centered cube of 1Mpc width

            offsetx = 0
            offsety = 0
            offsetz = 0

            if i == 2:
                offsetx = 0
                offsety = 1
                # offsetz = 1

            if i == 3:
                offsetx = 0
                offsety = 1
                offsetz = 1

            if i == 6:
                offsetx = 0
                offsety = 1
                # offsetz = 1

            # if i==7:

            # offsety=1

            vx1 = np.array(vx[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vy1 = np.array(vy[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vz1 = np.array(vz[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

            vx_comp1 = np.array(vx_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vy_comp1 = np.array(vy_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vz_comp1 = np.array(vz_comp[int(nx / 2 + shiftx),
                                int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

            vx_sol1 = np.array(vx_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vy_sol1 = np.array(vy_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vz_sol1 = np.array(vz_sol[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

            print("shape vx5", np.shape(vx5), "shape vy5", np.shape(vy5), "shape vz5", np.shape(vz5))
            print("shape vx_comp5", np.shape(vx_comp5), "shape vy_comp5", np.shape(vy_comp5), "shape vz_comp5",
                  np.shape(vz_comp5))
            print("shape vx_sol5", np.shape(vx_sol5), "shape vy_sol5", np.shape(vy_sol5), "shape vz_sol5",
                  np.shape(vz_sol5))

            print("shape vx2", np.shape(vx2), "shape vy2", np.shape(vy2), "shape vz2", np.shape(vz2))
            print("shape vx_comp2", np.shape(vx_comp2), "shape vy_comp2", np.shape(vy_comp2), "shape vz_comp2",
                  np.shape(vz_comp2))
            print("shape vx_sol2", np.shape(vx_sol2), "shape vy_sol2", np.shape(vy_sol2), "shape vz_sol2",
                  np.shape(vz_sol2))

            print("shape vx1", np.shape(vx1), "shape vy1", np.shape(vy1), "shape vz1", np.shape(vz1))
            print("shape vx_comp1", np.shape(vx_comp1), "shape vy_comp1", np.shape(vy_comp1), "shape vz_comp1",
                  np.shape(vz_comp1))
            print("shape vx_sol1", np.shape(vx_sol1), "shape vy_sol1", np.shape(vy_sol1), "shape vz_sol1",
                  np.shape(vz_sol1))

            # sys.exit()

            def manual_energy_spectrum_3D():
                print("fft")

                start = time.time()

                vxk5 = np.fft.fftn(vx5)
                vyk5 = np.fft.fftn(vy5)
                vzk5 = np.fft.fftn(vz5)

                vxk_comp5 = np.fft.fftn(vx_comp5)
                vyk_comp5 = np.fft.fftn(vy_comp5)
                vzk_comp5 = np.fft.fftn(vz_comp5)

                vxk_sol5 = np.fft.fftn(vx_sol5)
                vyk_sol5 = np.fft.fftn(vy_sol5)
                vzk_sol5 = np.fft.fftn(vz_sol5)

                vxk2 = np.fft.fftn(vx2)
                vyk2 = np.fft.fftn(vy2)
                vzk2 = np.fft.fftn(vz2)

                vxk_comp2 = np.fft.fftn(vx_comp2)
                vyk_comp2 = np.fft.fftn(vy_comp2)
                vzk_comp2 = np.fft.fftn(vz_comp2)

                vxk_sol2 = np.fft.fftn(vx_sol2)
                vyk_sol2 = np.fft.fftn(vy_sol2)
                vzk_sol2 = np.fft.fftn(vz_sol2)

                vxk1 = np.fft.fftn(vx1)
                vyk1 = np.fft.fftn(vy1)
                vzk1 = np.fft.fftn(vz1)

                vxk_comp1 = np.fft.fftn(vx_comp1)
                vyk_comp1 = np.fft.fftn(vy_comp1)
                vzk_comp1 = np.fft.fftn(vz_comp1)

                vxk_sol1 = np.fft.fftn(vx_sol1)
                vyk_sol1 = np.fft.fftn(vy_sol1)
                vzk_sol1 = np.fft.fftn(vz_sol1)

                end = time.time()

                print("fft done, time =", end - start)

                ekv5 = 0.5 * (np.abs(vxk5) ** 2 + np.abs(vyk5) ** 2 + np.abs(vzk5) ** 2)
                ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
                ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

                ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
                ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
                ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

                ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
                ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
                ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

            # Pk = PKL.Pk_plane(vpk, size)
            # k = Pk.k
            # Pk = Pk.Pk

            # Pkcomp = PKL.Pk_plane(vcomppk, size)
            # kcomp = Pkcomp.k
            # Pkcomp = Pkcomp.Pk

            # Pksol = PKL.Pk_plane(vsolpk, size)
            # ksol = Pksol.k
            # Pksol = Pksol.Pk

            size = 5000

            Pk = PKL.Pk_plane(vx5, size)
            k5 = Pk.k
            Pk_vx5 = Pk.Pk

            Pk = PKL.Pk_plane(vy5, size)
            Pk_vy5 = Pk.Pk

            Pk = PKL.Pk_plane(vz5, size)
            Pk_vz5 = Pk.Pk

            Pkcomp = PKL.Pk_plane(vx_comp5, size)
            kcomp = Pkcomp.k
            Pk_vx5_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vy_comp5, size)
            Pk_vy5_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vz_comp5, size)
            Pk_vz5_comp = Pkcomp.Pk

            Pksol = PKL.Pk_plane(vx_sol5, size)
            ksol = Pksol.k
            Pk_vx5_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vy_sol5, size)
            Pk_vy5_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vz_sol5, size)
            Pk_vz5_sol = Pksol.Pk

            ekv5 = 0.5 * (np.abs(Pk_vx5) + np.abs(Pk_vy5) + np.abs(Pk_vz5))
            ekv_comp5 = 0.5 * (np.abs(Pk_vx5_comp) + np.abs(Pk_vy5_comp) + np.abs(Pk_vz5_comp))
            ekv_sol5 = 0.5 * (np.abs(Pk_vx5_sol) + np.abs(Pk_vy5_sol) + np.abs(Pk_vz5_sol))

            size = 2000

            Pk = PKL.Pk_plane(vx2, size)
            k2 = Pk.k
            Pk_vx2 = Pk.Pk

            Pk = PKL.Pk_plane(vy2, size)
            Pk_vy2 = Pk.Pk

            Pk = PKL.Pk_plane(vz2, size)
            Pk_vz2 = Pk.Pk

            Pkcomp = PKL.Pk_plane(vx_comp2, size)
            kcomp = Pkcomp.k
            Pk_vx2_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vy_comp2, size)
            Pk_vy2_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vz_comp2, size)
            Pk_vz2_comp = Pkcomp.Pk

            Pksol = PKL.Pk_plane(vx_sol2, size)
            ksol = Pksol.k
            Pk_vx2_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vy_sol2, size)
            Pk_vy2_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vz_sol2, size)
            Pk_vz2_sol = Pksol.Pk

            ekv2 = 0.5 * (np.abs(Pk_vx2) + np.abs(Pk_vy2) + np.abs(Pk_vz2))
            ekv_comp2 = 0.5 * (np.abs(Pk_vx2_comp) + np.abs(Pk_vy2_comp) + np.abs(Pk_vz2_comp))
            ekv_sol2 = 0.5 * (np.abs(Pk_vx2_sol) + np.abs(Pk_vy2_sol) + np.abs(Pk_vz2_sol))

            size = 1000

            Pk = PKL.Pk_plane(vx1, size)
            k1 = Pk.k
            Pk_vx1 = Pk.Pk

            Pk = PKL.Pk_plane(vy1, size)
            Pk_vy1 = Pk.Pk

            Pk = PKL.Pk_plane(vz1, size)
            Pk_vz1 = Pk.Pk

            Pkcomp = PKL.Pk_plane(vx_comp1, size)
            kcomp = Pkcomp.k
            Pk_vx1_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vy_comp1, size)
            Pk_vy1_comp = Pkcomp.Pk

            Pkcomp = PKL.Pk_plane(vz_comp1, size)
            Pk_vz1_comp = Pkcomp.Pk

            Pksol = PKL.Pk_plane(vx_sol1, size)
            ksol = Pksol.k
            Pk_vx1_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vy_sol1, size)
            Pk_vy1_sol = Pksol.Pk

            Pksol = PKL.Pk_plane(vz_sol1, size)
            Pk_vz1_sol = Pksol.Pk

            ekv1 = 0.5 * (np.abs(Pk_vx1) + np.abs(Pk_vy1) + np.abs(Pk_vz1))
            ekv_comp1 = 0.5 * (np.abs(Pk_vx1_comp) + np.abs(Pk_vy1_comp) + np.abs(Pk_vz1_comp))
            ekv_sol1 = 0.5 * (np.abs(Pk_vx1_sol) + np.abs(Pk_vy1_sol) + np.abs(Pk_vz1_sol))

            return k1, k2, k5, ekv5, ekv_comp5, ekv_sol5, ekv2, ekv_comp2, ekv_sol2, ekv1, ekv_comp1, ekv_sol1

        k1, k2, k5, ekv5, ekv_comp5, ekv_sol5, ekv2, ekv_comp2, ekv_sol2, ekv1, ekv_comp1, ekv_sol1 = compute_ek()

        # ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
        # ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

        # ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
        # ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
        # ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

        # ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
        # ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
        # ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

        # ekv = 0.5*(vxk*np.conj(vxk)+vyk*np.conj(vyk)+vzk*np.conj(vzk))

        # print("ekv",ekv)
        # print("ekv_test",ekv_test)
        # print("diff",ekv-ekv_test)

        # sys.exit()

        # kx = np.fft.fftfreq(nx).reshape(nx, 1, 1)
        # ky = np.fft.fftfreq(ny).reshape(nz, 1)
        # kz = np.fft.fftfreq(nz)

        # print("shape kx",np.shape(kx))
        # print("shape ky",np.shape(ky))
        # print("shape kz",np.shape(kz))

        # k2 = kx ** 2 + ky ** 2 + kz ** 2

        # cf = 20000 / nx

        # cf = 1

        # print("cf",cf,"1/cf",1/cf)

        # sys.exit()

        # k5 = np.fft.fftfreq(int(ny/2),d=cf)

        # print('min k5',np.min(k5),'l max',2*np.pi/np.min(k5))
        # print('max k5',np.max(k5),'l min',2*np.pi/np.max(k5))

        # print('len k5',len(k5))
        # print('k5',k5)
        # sys.exit()
        # k5 = np.fft.fftfreq(5000, d=cf)
        # k = fftshift(k)
        # k5 = np.sqrt(k5[:, None, None] ** 2 + k5[None, :, None] ** 2 + k5[None, None, :] ** 2)
        # print('k5 sqrt',k5)

        # Bin the power spectrum
        # k_bins5 = np.linspace(0, np.max(k5), num=100)

        # print('k_bins5',k_bins5)

        # sys.exit()

        # k2 = np.fft.fftfreq(int(ny / 5),d=cf)  # , d=10000/ny)
        # k2 = np.fft.fftfreq(2000, d=cf)
        # k = fftshift(k)
        # k2 = np.sqrt(k2[:, None, None] ** 2 + k2[None, :, None] ** 2 + k2[None, None, :] ** 2)

        # Bin the power spectrum
        # k_bins2 = np.linspace(0, np.max(k2), num=50)

        # k1 = np.fft.fftfreq(int(ny / 10),d=cf)  # , d=10000/ny)
        # k1 = np.fft.fftfreq(1000, d=cf)  # , d=10000/ny)
        # k = fftshift(k)
        # k1 = np.sqrt(k1[:, None, None] ** 2 + k1[None, :, None] ** 2 + k1[None, None, :] ** 2)

        # Bin the power spectrum
        # k_bins1 = np.linspace(0, np.max(k1), num=25)

        # ekv_binned5 = np.zeros(len(k_bins5) - 1)
        # ekv_comp_binned5 = np.zeros(len(k_bins5) - 1)
        # ekv_sol_binned5 = np.zeros(len(k_bins5) - 1)

        # ekv_binned2 = np.zeros(len(k_bins2) - 1)
        # ekv_comp_binned2 = np.zeros(len(k_bins2) - 1)
        # ekv_sol_binned2 = np.zeros(len(k_bins2) - 1)

        # ekv_binned1 = np.zeros(len(k_bins1) - 1)
        # ekv_comp_binned1 = np.zeros(len(k_bins1) - 1)
        # ekv_sol_binned1 = np.zeros(len(k_bins1) - 1)

        # for i in range(len(k_bins5) - 1):
        #    mask = (k5 >= k_bins5[i]) & (k5 < k_bins5[i + 1])

        #    ekv_binned5[i] = np.mean(ekv5[mask])
        #    ekv_comp_binned5[i] = np.mean(ekv_comp5[mask])
        #    ekv_sol_binned5[i] = np.mean(ekv_sol5[mask])

        # for i in range(len(k_bins2) - 1):
        # print("i",i)
        #    mask = (k2 >= k_bins2[i]) & (k2 < k_bins2[i + 1])

        # print("len(k2)",len(k2))
        # print("len(k_bins2)",len(k_bins2))
        # print("len(ekv2)",len(ekv2))

        #    ekv_binned2[i] = np.mean(ekv2[mask])
        #    ekv_comp_binned2[i] = np.mean(ekv_comp2[mask])
        #    ekv_sol_binned2[i] = np.mean(ekv_sol2[mask])

        # for i in range(len(k_bins1) - 1):
        #    mask = (k1 >= k_bins1[i]) & (k1 < k_bins1[i + 1])

        #    ekv_binned1[i] = np.mean(ekv1[mask])
        #    ekv_comp_binned1[i] = np.mean(ekv_comp1[mask])
        #    ekv_sol_binned1[i] = np.mean(ekv_sol1[mask])

        def k_to_l(k):
            return 2 * np.pi / k

        def l_to_k(l):
            return 2 * np.pi / l

        # cf = 20000/nx #kpc per voxel in the matrix = physical distance between 2 points in the matrix

        plt.sca(axs[0,1])
        # plt.figure(figsize=(8, 6))

        #label="x-x_{Virgo}=" + str(round(2 * i - 8, 3)) + " Mpc"

        label = str(round(2 * i - 8, 3))

        if type=="ratio_cs":

            l1 = plt.loglog(k5, ekv_comp5/ekv_sol5, label=label, ls="solid", alpha=1, marker=".", ms=4, color=colors[3-(i-4)])

        elif type=="ratio_st":

            l1 = plt.loglog(k5, ekv_sol5/ekv5, label=label, ls="dashed", alpha=1, marker=".", ms=4, color=colors[3-(i-4)])

        else:

            cond = np.logical_and(k5 > 0.0015, k5 < 0.095)

            #cond = np.logical_and(k5 > 0.0035, k5 < 0.095)

            popt, pcov = curve_fit(log_power_law, k5[cond], np.log10(ekv5[cond]), p0=[100, -3.5],
                                   bounds=([0, -10], [1e5, -2]))

            #print("popt",popt)
            #print("pcov",pcov)

            k_fit_5[i, 0] = popt[1]
            k_fit_5[i, 1] = np.sqrt(pcov[1, 1])

            a_fit_5[i, 0] = popt[0]
            a_fit_5[i, 1] = np.sqrt(pcov[0, 0])

            l1 = plt.loglog(k5[cond], ekv5[cond], label=label, ls="solid", alpha=1, marker=".", ms=4,color=colors[3-(i-4)])

            plt.loglog(k5[cond], power_law(k5[cond], *popt), ls="dotted", color='green', alpha=0.7)

            x_target = 0.015
            y_target = 1e10

            # Adjusting the prefactor so the lines pass through the target point
            kolmogorov = y_target * (k5 / x_target) ** (-11 / 3)
            burgers = y_target * (k5 / x_target) ** (-4)

            cond = np.logical_and(k5 > 0.015, k5 < 0.06)

            plt.loglog(k5[cond], kolmogorov[cond], ls="dotted", color="grey", alpha=0.7)
            plt.loglog(k5[cond], burgers[cond], ls="dotted", color="grey", alpha=0.7)
            plt.text(0.061, 8e7, '$k^{-11/3}$', fontsize=fs, color='grey')
            plt.text(0.061, 3e7, '$k^{-4}$', fontsize=fs, color='grey')

        #l2 = plt.loglog(k5, ekv_comp5, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        #l3 = plt.loglog(k5, ekv_sol5, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

        if i==4:
            secax = axs[0,1].secondary_xaxis('top', functions=(k_to_l, l_to_k))
            secax.set_xlabel(r'$L=\frac{2\pi}{k}$ [kpc]', fontsize=fs)
            secax.tick_params(labelsize=fs)

        #title = "$\Delta x_{cen}$=" + str(round(2 * i - 8, 3)) + " Mpc"

        #plt.title(title, fontsize=fs)
        # plt.xticks([])

        #plt.xlim(0.0014, 0.21)
        #plt.ylim(3e4,1e12)

        if i == 4:
            if type=='ratio_cs':
        #        plt.ylabel('$E(k)_c/E(k)_s$', fontsize=fs)
                plt.ylim(3e-2, 1.5e1)
                plt.xlim(0.0014, 0.1)
            elif type == 'ratio_st':
        #        plt.ylabel('$E(k)_s/E(k)$', fontsize=fs)
                plt.ylim(1e-2, 4)

                plt.xlim(0.0014, 0.1)

            else:

        #       plt.ylabel('E(k)', fontsize=fs)
                plt.ylim(1e5, 1e12)
                plt.xlim(0.0014, 0.1)

            plt.yticks(fontsize=fs)
        #else:
        plt.yticks([])
        #    axs[0].tick_params(labelleft=False)

        if i == 4:
            plt.text(1.05, 0.5, '5 Mpc square maps', transform=axs[0,1].transAxes, verticalalignment='center', rotation=270,
                     fontsize=fs)

        # plt.yticks(fontsize=fs)
        # plt.xticks(fontsize=fs)
        plt.title("Foreground filament",fontsize=fs)

        axs[0,1].tick_params(labelbottom=False)

        #plt.legend(fontsize=fs)

        plt.sca(axs[1,1])

        if type=="ratio_cs":

            plt.loglog(k2, ekv_comp2/ekv_sol2, label=label, ls="solid", alpha=1, marker=".", ms=4, color=colors[3-(i-4)])

        elif type=="ratio_st":

            plt.loglog(k2, ekv_sol2/ekv2, label=label, ls="dashed", alpha=1, marker=".", ms=4, color=colors[3-(i-4)])

        else:
            #cond = np.logical_and(k2 > 0.0015, k2 < 0.095)
            cond = np.logical_and(k2 > 0.006, k2 < 0.095)

            popt, pcov = curve_fit(log_power_law, k2[cond], np.log10(ekv2[cond]), p0=[100, -3.5],
                                   bounds=([0, -10], [1e5, -2]))

            print("popt",popt)
            print("pcov",pcov)

            k_fit_2[i, 0] = popt[1]
            k_fit_2[i, 1] = np.sqrt(pcov[1, 1])

            a_fit_2[i, 0] = popt[0]
            a_fit_2[i, 1] = np.sqrt(pcov[0, 0])

            plt.loglog(k2, ekv2, label=label, ls="solid", alpha=1, marker=".", ms=4,color=colors[3-(i-4)])

            plt.loglog(k2[cond], power_law(k2[cond], *popt), ls="dotted", color='green', alpha=0.7)

            x_target = 0.015
            y_target = 1e10

            # Adjusting the prefactor so the lines pass through the target point
            kolmogorov = y_target * (k5 / x_target) ** (-11 / 3)
            burgers = y_target * (k5 / x_target) ** (-4)

            cond = np.logical_and(k5 > 0.015, k5 < 0.06)

            plt.loglog(k5[cond], kolmogorov[cond], ls="dotted", color="grey", alpha=0.7)
            plt.loglog(k5[cond], burgers[cond], ls="dotted", color="grey", alpha=0.7)
            plt.text(0.061, 8e7, '$k^{-11/3}$', fontsize=fs, color='grey')
            plt.text(0.061, 3e7, '$k^{-4}$', fontsize=fs, color='grey')

        #plt.loglog(k2, ekv_comp2, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        #plt.loglog(k2, ekv_sol2, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

        if i == 4:
            if type=='ratio_cs':
                #plt.ylabel('$E(k)_c/E(k)_s$', fontsize=fs)
                plt.ylim(3e-2, 1.5e1)
                plt.xlim(0.0014, 0.1)

            elif type == 'ratio_st':
                # plt.ylabel('$E(k)_s/E(k)$', fontsize=fs)
                plt.ylim(1e-2, 4)

                plt.xlim(0.0014, 0.1)

            else:
                #plt.ylabel('E(k)', fontsize=fs)
                plt.ylim(1e5, 1e12)
                plt.xlim(0.0014, 0.1)

            plt.yticks(fontsize=fs)
        #else:
        plt.yticks([])
        #    axs[1].tick_params(labelleft=False)

        if i == 4:
            plt.text(1.05, 0.5, '2 Mpc square maps', transform=axs[1,1].transAxes, verticalalignment='center', rotation=270,
                     fontsize=fs)

        # plt.xticks([])
        # plt.yticks(fontsize=fs)

        axs[1,1].tick_params(labelbottom=False)



        #plt.xlim(0.0014, 0.21)
        #plt.ylim(3e4,1e12)

        plt.sca(axs[2,1])

        if type=="ratio_cs":

            plt.loglog(k1, ekv_comp1/ekv_sol1, label=label, ls="solid", alpha=1, marker=".", ms=4, color=colors[3-(i-4)])

        elif type=="ratio_st":

            plt.loglog(k1, ekv_sol1/ekv1, label=label, ls="dashed", alpha=1, marker=".", ms=4, color=colors[3-(i-4)])

        else:
            #cond = np.logical_and(k1 > 0.0015, k1 < 0.095)
            cond = np.logical_and(k1 > 0.006, k1 < 0.095)

            popt, pcov = curve_fit(log_power_law, k1[cond], np.log10(ekv1[cond]), p0=[100, -3.5],
                                   bounds=([0, -10], [1e5, -2]))

            print("popt",popt)
            print("pcov",pcov)

            k_fit_1[i, 0] = popt[1]
            k_fit_1[i, 1] = np.sqrt(pcov[1, 1])

            a_fit_1[i, 0] = popt[0]
            a_fit_1[i, 1] = np.sqrt(pcov[0, 0])

            plt.loglog(k1, ekv1, label=label, ls="solid", alpha=1, marker=".", ms=4,color=colors[3-(i-4)])

            plt.loglog(k1[cond], power_law(k1[cond], *popt), ls="dotted", color='green', alpha=0.7)

            x_target = 0.015
            y_target = 1e10

            # Adjusting the prefactor so the lines pass through the target point
            kolmogorov = y_target * (k5 / x_target) ** (-11 / 3)
            burgers = y_target * (k5 / x_target) ** (-4)

            cond = np.logical_and(k5 > 0.015, k5 < 0.06)

            plt.loglog(k5[cond], kolmogorov[cond], ls="dotted", color="grey", alpha=0.7)
            plt.loglog(k5[cond], burgers[cond], ls="dotted", color="grey", alpha=0.7)
            plt.text(0.061, 8e7, '$k^{-11/3}$', fontsize=fs, color='grey')
            plt.text(0.061, 3e7, '$k^{-4}$', fontsize=fs, color='grey')

        #plt.loglog(k1, ekv_comp1, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        #plt.loglog(k1, ekv_sol1, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

        plt.xlabel("$k~\mathrm{[kpc^{-1}]}$", fontsize=fs)
        plt.xticks(fontsize=fs)

        if i == 4:
            if type=='ratio_cs':
                #plt.ylabel('$E(k)_c/E(k)_s$', fontsize=fs)
                plt.ylim(3e-2, 1.5e1)
                plt.xlim(0.0014, 0.1)

            elif type=='ratio_st':

                plt.ylim(1e-2, 4)

                plt.xlim(0.0014, 0.1)
            else:
                #plt.ylabel('E(k)', fontsize=fs)
                plt.ylim(1e5, 1e12)
                plt.xlim(0.0014, 0.1)


            plt.yticks(fontsize=fs)
        #else:
        plt.yticks([])
        #    axs[2].tick_params(labelleft=False)

        if i == 4:
            plt.text(1.05, 0.5, '1 Mpc square maps', transform=axs[2,1].transAxes, verticalalignment='center', rotation=270,
                     fontsize=fs)

        # plt.yticks(fontsize=fs)

        plt.legend(fontsize=fs, title='$\Delta x_{cen}~[Mpc]$', title_fontsize=fs, loc="lower left")

    # plt.grid(True)
    if type=="ratio_cs":
        plt.suptitle('Compressive to solenoidal 2D Velocity power spectra ratio', fontsize=fs + 2)
    elif type=="ratio_st":
        plt.suptitle('Solenoidal to total 2D Velocity power spectra ratio', fontsize=fs + 2)
    #f.legend([l1, l2, l3], labels=['Total', 'Compressive', 'Solenoidal'], loc='upper right', fontsize=fs)  # , bbox_to_anchor=(0.5, 0.5))

    print("k_fit_5",k_fit_5)
    print("k_fit_2",k_fit_2)
    print("k_fit_1",k_fit_1)

    print("a_fit_5",a_fit_5)
    print("a_fit_2",a_fit_2)
    print("a_fit_1",a_fit_1)


    plt.show()

def energy_spectrum_2D_one_row():
    print('loading files')

    vx = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_12x12x20Mpc_cube.bin.npy')
    vy = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_12x12x20Mpc_cube.bin.npy')
    vz = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_12x12x20Mpc_cube.bin.npy')

    vx_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_comp_12x12x20Mpc_cube.bin.npy')
    vy_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_comp_12x12x20Mpc_cube.bin.npy')
    vz_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_comp_12x12x20Mpc_cube.bin.npy')

    vx_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_sol_12x12x20Mpc_cube.bin.npy')
    vy_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_sol_12x12x20Mpc_cube.bin.npy')
    vz_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_sol_12x12x20Mpc_cube.bin.npy')

    print('files loaded')

    nx, ny, nz = np.shape(vx)

    print("nx", nx, "ny", ny, "nz", nz)

    # Set centered cube of 5Mpc width

    fs = 10
    # Plot the power spectrum
    f, axs = plt.subplots(1, 8, figsize=(16, 4), constrained_layout=True)

    for i in range(0, 8):

        print("i", i)

        offsety = 0
        offsetz = 0

        shiftx = nx / 20  # =1 Mpc
        shifty = nx / 20  # =1 Mpc
        shiftz = nx / 20

        if i == 0:
            shiftx *= -8
            shifty *= 3.5
            shiftz *= 1.5

            # print("shiftx",shiftx)
            # print("shifty",shifty)
            # print("shiftz",shiftz)

            # sys.exit()

        if i == 1:
            shiftx *= -6
            shifty *= 1.5
            shiftz *= 1

        if i == 2:
            shiftx *= -4
            shifty *= 1.5
            shiftz *= 0.5
            # offsety=1

        if i == 3:
            shiftx *= -2
            shifty *= 0
            shiftz *= 0

        if i == 4:
            shiftx *= 0
            shifty *= 0
            shiftz *= 0

        if i == 5:
            shiftx *= 2
            shifty *= 0
            shiftz *= 0

        if i == 6:
            shiftx *= 4
            shifty *= -1
            shiftz *= 0
            # offsety=1

        if i == 7:
            shiftx *= 6
            shifty *= -2.5
            shiftz *= -0.5

        # print("shiftx",shiftx)

        vx5 = np.array(vx[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                       int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
        vy5 = np.array(vy[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                       int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
        vz5 = np.array(vz[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                       int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

        vx_comp5 = np.array(
            vx_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
            int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
        vy_comp5 = np.array(
            vy_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
            int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
        vz_comp5 = np.array(
            vz_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
            int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

        vx_sol5 = np.array(
            vx_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
            int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
        vy_sol5 = np.array(
            vy_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
            int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
        vz_sol5 = np.array(
            vz_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
            int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

        # Set centered cube of 2Mpc width
        offsetx = 0
        offsety = 0
        offsetz = 0
        v_sol2_offset = 0

        if i == 0:
            v_sol2_offset = -1

        if i == 1:
            v_sol2_offset = -1

        if i == 2:
            offsety = 1
            offsetz = 1
            v_sol2_offset = -1

        if i == 3:
            # offsetx = 1
            offsety = 1
            offsetz = 1

        if i == 4:
            offsetx = 1
            offsety = 1
            offsetz = 1

        if i == 5:
            offsetx = 1
            offsety = 1
            offsetz = 1

        if i == 6:
            offsetx = 1
            offsety = 1
            offsetz = 0
            v_sol2_offset = -1

        if i == 7:
            offsetz = 1

        # print("shiftx",shiftx)

        vx2 = np.array(vx[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                       int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vy2 = np.array(vy[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                       int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vz2 = np.array(vz[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                       int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

        vx_comp2 = np.array(vx_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                            int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vy_comp2 = np.array(vy_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                            int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vz_comp2 = np.array(vz_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                            int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

        vx_sol2 = np.array(vx_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vy_sol2 = np.array(vy_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)
        vz_sol2 = np.array(vz_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                           int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)], dtype=np.float32)

        # Set centered cube of 1Mpc width

        offsetx = 0
        offsety = 0
        offsetz = 0

        if i == 2:
            offsetx = 0
            offsety = 1
            # offsetz = 1

        if i == 3:
            offsetx = 0
            offsety = 1
            offsetz = 1

        if i == 6:
            offsetx = 0
            offsety = 1
            # offsetz = 1

        # if i==7:

        # offsety=1

        vx1 = np.array(vx[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vy1 = np.array(vy[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vz1 = np.array(vz[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

        vx_comp1 = np.array(vx_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                            int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vy_comp1 = np.array(vy_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                            int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vz_comp1 = np.array(vz_comp[int(nx / 2 + shiftx),
                            int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                            int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

        vx_sol1 = np.array(vx_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vy_sol1 = np.array(vy_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
        vz_sol1 = np.array(vz_sol[int(nx / 2 + shiftx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

        print("shape vx5", np.shape(vx5), "shape vy5", np.shape(vy5), "shape vz5", np.shape(vz5))
        print("shape vx_comp5", np.shape(vx_comp5), "shape vy_comp5", np.shape(vy_comp5), "shape vz_comp5",
              np.shape(vz_comp5))
        print("shape vx_sol5", np.shape(vx_sol5), "shape vy_sol5", np.shape(vy_sol5), "shape vz_sol5",
              np.shape(vz_sol5))

        print("shape vx2", np.shape(vx2), "shape vy2", np.shape(vy2), "shape vz2", np.shape(vz2))
        print("shape vx_comp2", np.shape(vx_comp2), "shape vy_comp2", np.shape(vy_comp2), "shape vz_comp2",
              np.shape(vz_comp2))
        print("shape vx_sol2", np.shape(vx_sol2), "shape vy_sol2", np.shape(vy_sol2), "shape vz_sol2",
              np.shape(vz_sol2))

        print("shape vx1", np.shape(vx1), "shape vy1", np.shape(vy1), "shape vz1", np.shape(vz1))
        print("shape vx_comp1", np.shape(vx_comp1), "shape vy_comp1", np.shape(vy_comp1), "shape vz_comp1",
              np.shape(vz_comp1))
        print("shape vx_sol1", np.shape(vx_sol1), "shape vy_sol1", np.shape(vy_sol1), "shape vz_sol1",
              np.shape(vz_sol1))

        # sys.exit()

        def manual_energy_spectrum_3D():
            print("fft")

            start = time.time()

            vxk5 = np.fft.fftn(vx5)
            vyk5 = np.fft.fftn(vy5)
            vzk5 = np.fft.fftn(vz5)

            vxk_comp5 = np.fft.fftn(vx_comp5)
            vyk_comp5 = np.fft.fftn(vy_comp5)
            vzk_comp5 = np.fft.fftn(vz_comp5)

            vxk_sol5 = np.fft.fftn(vx_sol5)
            vyk_sol5 = np.fft.fftn(vy_sol5)
            vzk_sol5 = np.fft.fftn(vz_sol5)

            vxk2 = np.fft.fftn(vx2)
            vyk2 = np.fft.fftn(vy2)
            vzk2 = np.fft.fftn(vz2)

            vxk_comp2 = np.fft.fftn(vx_comp2)
            vyk_comp2 = np.fft.fftn(vy_comp2)
            vzk_comp2 = np.fft.fftn(vz_comp2)

            vxk_sol2 = np.fft.fftn(vx_sol2)
            vyk_sol2 = np.fft.fftn(vy_sol2)
            vzk_sol2 = np.fft.fftn(vz_sol2)

            vxk1 = np.fft.fftn(vx1)
            vyk1 = np.fft.fftn(vy1)
            vzk1 = np.fft.fftn(vz1)

            vxk_comp1 = np.fft.fftn(vx_comp1)
            vyk_comp1 = np.fft.fftn(vy_comp1)
            vzk_comp1 = np.fft.fftn(vz_comp1)

            vxk_sol1 = np.fft.fftn(vx_sol1)
            vyk_sol1 = np.fft.fftn(vy_sol1)
            vzk_sol1 = np.fft.fftn(vz_sol1)

            end = time.time()

            print("fft done, time =", end - start)

            ekv5 = 0.5 * (np.abs(vxk5) ** 2 + np.abs(vyk5) ** 2 + np.abs(vzk5) ** 2)
            ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
            ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

            ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
            ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
            ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

            ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
            ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
            ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

        # Pk = PKL.Pk_plane(vpk, size)
        # k = Pk.k
        # Pk = Pk.Pk

        # Pkcomp = PKL.Pk_plane(vcomppk, size)
        # kcomp = Pkcomp.k
        # Pkcomp = Pkcomp.Pk

        # Pksol = PKL.Pk_plane(vsolpk, size)
        # ksol = Pksol.k
        # Pksol = Pksol.Pk

        size = 5000

        Pk = PKL.Pk_plane(vx5, size)
        k5 = Pk.k
        Pk_vx5 = Pk.Pk

        Pk = PKL.Pk_plane(vy5, size)
        Pk_vy5 = Pk.Pk

        Pk = PKL.Pk_plane(vz5, size)
        Pk_vz5 = Pk.Pk

        Pkcomp = PKL.Pk_plane(vx_comp5, size)
        kcomp = Pkcomp.k
        Pk_vx5_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vy_comp5, size)
        Pk_vy5_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vz_comp5, size)
        Pk_vz5_comp = Pkcomp.Pk

        Pksol = PKL.Pk_plane(vx_sol5, size)
        ksol = Pksol.k
        Pk_vx5_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vy_sol5, size)
        Pk_vy5_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vz_sol5, size)
        Pk_vz5_sol = Pksol.Pk

        ekv5 = 0.5 * (np.abs(Pk_vx5) + np.abs(Pk_vy5) + np.abs(Pk_vz5))

        # print("ekv5",ekv5)
        # test_ekv5 = 0.5 * (Pk_vx5 + Pk_vy5 + Pk_vz5)
        # print("test_ekv5",test_ekv5)
        # print("diff",ekv5-test_ekv5)
        # sys.exit()

        ekv_comp5 = 0.5 * (np.abs(Pk_vx5_comp) + np.abs(Pk_vy5_comp) + np.abs(Pk_vz5_comp))
        ekv_sol5 = 0.5 * (np.abs(Pk_vx5_sol) + np.abs(Pk_vy5_sol) + np.abs(Pk_vz5_sol))

        size = 2000

        Pk = PKL.Pk_plane(vx2, size)
        k2 = Pk.k
        Pk_vx2 = Pk.Pk

        Pk = PKL.Pk_plane(vy2, size)
        Pk_vy2 = Pk.Pk

        Pk = PKL.Pk_plane(vz2, size)
        Pk_vz2 = Pk.Pk

        Pkcomp = PKL.Pk_plane(vx_comp2, size)
        kcomp = Pkcomp.k
        Pk_vx2_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vy_comp2, size)
        Pk_vy2_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vz_comp2, size)
        Pk_vz2_comp = Pkcomp.Pk

        Pksol = PKL.Pk_plane(vx_sol2, size)
        ksol = Pksol.k
        Pk_vx2_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vy_sol2, size)
        Pk_vy2_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vz_sol2, size)
        Pk_vz2_sol = Pksol.Pk

        ekv2 = 0.5 * (np.abs(Pk_vx2) + np.abs(Pk_vy2) + np.abs(Pk_vz2))
        ekv_comp2 = 0.5 * (np.abs(Pk_vx2_comp) + np.abs(Pk_vy2_comp) + np.abs(Pk_vz2_comp))
        ekv_sol2 = 0.5 * (np.abs(Pk_vx2_sol) + np.abs(Pk_vy2_sol) + np.abs(Pk_vz2_sol))

        size = 1000

        Pk = PKL.Pk_plane(vx1, size)
        k1 = Pk.k
        Pk_vx1 = Pk.Pk

        Pk = PKL.Pk_plane(vy1, size)
        Pk_vy1 = Pk.Pk

        Pk = PKL.Pk_plane(vz1, size)
        Pk_vz1 = Pk.Pk

        Pkcomp = PKL.Pk_plane(vx_comp1, size)
        kcomp = Pkcomp.k
        Pk_vx1_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vy_comp1, size)
        Pk_vy1_comp = Pkcomp.Pk

        Pkcomp = PKL.Pk_plane(vz_comp1, size)
        Pk_vz1_comp = Pkcomp.Pk

        Pksol = PKL.Pk_plane(vx_sol1, size)
        ksol = Pksol.k
        Pk_vx1_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vy_sol1, size)
        Pk_vy1_sol = Pksol.Pk

        Pksol = PKL.Pk_plane(vz_sol1, size)
        Pk_vz1_sol = Pksol.Pk

        ekv1 = 0.5 * (np.abs(Pk_vx1) + np.abs(Pk_vy1) + np.abs(Pk_vz1))
        ekv_comp1 = 0.5 * (np.abs(Pk_vx1_comp) + np.abs(Pk_vy1_comp) + np.abs(Pk_vz1_comp))
        ekv_sol1 = 0.5 * (np.abs(Pk_vx1_sol) + np.abs(Pk_vy1_sol) + np.abs(Pk_vz1_sol))

        # ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
        # ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

        # ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
        # ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
        # ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

        # ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
        # ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
        # ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

        # ekv = 0.5*(vxk*np.conj(vxk)+vyk*np.conj(vyk)+vzk*np.conj(vzk))

        # print("ekv",ekv)
        # print("ekv_test",ekv_test)
        # print("diff",ekv-ekv_test)

        # sys.exit()

        # kx = np.fft.fftfreq(nx).reshape(nx, 1, 1)
        # ky = np.fft.fftfreq(ny).reshape(nz, 1)
        # kz = np.fft.fftfreq(nz)

        # print("shape kx",np.shape(kx))
        # print("shape ky",np.shape(ky))
        # print("shape kz",np.shape(kz))

        # k2 = kx ** 2 + ky ** 2 + kz ** 2

        # cf = 20000 / nx

        # cf = 1

        # print("cf",cf,"1/cf",1/cf)

        # sys.exit()

        # k5 = np.fft.fftfreq(int(ny/2),d=cf)

        # print('min k5',np.min(k5),'l max',2*np.pi/np.min(k5))
        # print('max k5',np.max(k5),'l min',2*np.pi/np.max(k5))

        # print('len k5',len(k5))
        # print('k5',k5)
        # sys.exit()
        # k5 = np.fft.fftfreq(5000, d=cf)
        # k = fftshift(k)
        # k5 = np.sqrt(k5[:, None, None] ** 2 + k5[None, :, None] ** 2 + k5[None, None, :] ** 2)
        # print('k5 sqrt',k5)

        # Bin the power spectrum
        # k_bins5 = np.linspace(0, np.max(k5), num=100)

        # print('k_bins5',k_bins5)

        # sys.exit()

        # k2 = np.fft.fftfreq(int(ny / 5),d=cf)  # , d=10000/ny)
        # k2 = np.fft.fftfreq(2000, d=cf)
        # k = fftshift(k)
        # k2 = np.sqrt(k2[:, None, None] ** 2 + k2[None, :, None] ** 2 + k2[None, None, :] ** 2)

        # Bin the power spectrum
        # k_bins2 = np.linspace(0, np.max(k2), num=50)

        # k1 = np.fft.fftfreq(int(ny / 10),d=cf)  # , d=10000/ny)
        # k1 = np.fft.fftfreq(1000, d=cf)  # , d=10000/ny)
        # k = fftshift(k)
        # k1 = np.sqrt(k1[:, None, None] ** 2 + k1[None, :, None] ** 2 + k1[None, None, :] ** 2)

        # Bin the power spectrum
        # k_bins1 = np.linspace(0, np.max(k1), num=25)

        # ekv_binned5 = np.zeros(len(k_bins5) - 1)
        # ekv_comp_binned5 = np.zeros(len(k_bins5) - 1)
        # ekv_sol_binned5 = np.zeros(len(k_bins5) - 1)

        # ekv_binned2 = np.zeros(len(k_bins2) - 1)
        # ekv_comp_binned2 = np.zeros(len(k_bins2) - 1)
        # ekv_sol_binned2 = np.zeros(len(k_bins2) - 1)

        # ekv_binned1 = np.zeros(len(k_bins1) - 1)
        # ekv_comp_binned1 = np.zeros(len(k_bins1) - 1)
        # ekv_sol_binned1 = np.zeros(len(k_bins1) - 1)

        # for i in range(len(k_bins5) - 1):
        #    mask = (k5 >= k_bins5[i]) & (k5 < k_bins5[i + 1])

        #    ekv_binned5[i] = np.mean(ekv5[mask])
        #    ekv_comp_binned5[i] = np.mean(ekv_comp5[mask])
        #    ekv_sol_binned5[i] = np.mean(ekv_sol5[mask])

        # for i in range(len(k_bins2) - 1):
        # print("i",i)
        #    mask = (k2 >= k_bins2[i]) & (k2 < k_bins2[i + 1])

        # print("len(k2)",len(k2))
        # print("len(k_bins2)",len(k_bins2))
        # print("len(ekv2)",len(ekv2))

        #    ekv_binned2[i] = np.mean(ekv2[mask])
        #    ekv_comp_binned2[i] = np.mean(ekv_comp2[mask])
        #    ekv_sol_binned2[i] = np.mean(ekv_sol2[mask])

        # for i in range(len(k_bins1) - 1):
        #    mask = (k1 >= k_bins1[i]) & (k1 < k_bins1[i + 1])

        #    ekv_binned1[i] = np.mean(ekv1[mask])
        #    ekv_comp_binned1[i] = np.mean(ekv_comp1[mask])
        #    ekv_sol_binned1[i] = np.mean(ekv_sol1[mask])

        def k_to_l(k):
            return 2 * np.pi / k

        def l_to_k(l):
            return 2 * np.pi / l

        # cf = 20000/nx #kpc per voxel in the matrix = physical distance between 2 points in the matrix

        plt.sca(axs[i])
        # plt.figure(figsize=(8, 6))

        l1 = plt.loglog(k5, ekv5, label='Total 5', ls="solid", color="black", alpha=0.7, marker=".", ms=4)
        l2 = plt.loglog(k5, ekv_comp5, label='Compressive 5', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
        l3 = plt.loglog(k5, ekv_sol5, label='Solenoidal 5', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

        secax = axs[i].secondary_xaxis('top', functions=(k_to_l, l_to_k))
        secax.set_xlabel(r'$L=\frac{2\pi}{k}$ [kpc]', fontsize=fs)
        secax.tick_params(labelsize=fs)

        title = "$\Delta x_{cen}$=" + str(round(2 * i - 8, 3)) + " Mpc"

        plt.title(title, fontsize=fs)
        # plt.xticks([])

        plt.xlim(0.001, 0.3)
        plt.ylim(1e4,1e12)

        if i == 0:
            plt.ylabel('P(k)', fontsize=fs)
            plt.yticks(fontsize=fs)
        else:
            # plt.yticks([])
            axs[i].tick_params(labelleft=False)

        #if i == 7:
        #    plt.text(1.05, 0.5, '5 Mpc square maps', transform=axs[0, 7].transAxes, verticalalignment='center', rotation=270,fontsize=fs + 3)

        # plt.yticks(fontsize=fs)
        # plt.xticks(fontsize=fs)

        #axs[0, i].tick_params(labelbottom=False)

        # plt.legend(fontsize=fs)

        #plt.sca(axs[1, i])

        plt.loglog(k2, ekv2, label='Total 2', ls="dashed", color="black", alpha=0.7, marker=".", ms=4)
        plt.loglog(k2, ekv_comp2, label='Compressive 2', ls="dashed", color="blue", alpha=0.7, marker=".", ms=4)
        plt.loglog(k2, ekv_sol2, label='Solenoidal 2', ls="dashed", color="red", alpha=0.7, marker=".", ms=4)

        #if i == 0:
        #    plt.ylabel('E(k)', fontsize=fs)
        #    plt.yticks(fontsize=fs)
        #else:
            # plt.yticks([])
        #    axs[i].tick_params(labelleft=False)

        #if i == 7:
        #    plt.text(1.05, 0.5, '2 Mpc square maps', transform=axs[1, 7].transAxes, verticalalignment='center', rotation=270,fontsize=fs + 3)

        if i == 4:
            plt.legend(fontsize=fs)

        # plt.xticks([])
        # plt.yticks(fontsize=fs)

        #axs[1, i].tick_params(labelbottom=False)

        # plt.legend(fontsize=fs)

        plt.xlim(0.001, 0.3)
        plt.ylim(1e4,1e12)

        #plt.sca(axs[2, i])

        plt.loglog(k1, ekv1, label='Total 1', ls="dotted", color="black", alpha=0.7, marker=".", ms=4)
        plt.loglog(k1, ekv_comp1, label='Compressive 1', ls="dotted", color="blue", alpha=0.7, marker=".", ms=4)
        plt.loglog(k1, ekv_sol1, label='Solenoidal 1', ls="dotted", color="red", alpha=0.7, marker=".", ms=4)

        plt.xlabel("$k~\mathrm{[kpc^{-1}]}$", fontsize=fs)
        plt.xticks(fontsize=fs)

        #if i == 0:
        #    plt.ylabel('E(k)', fontsize=fs)
        #    plt.yticks(fontsize=fs)
        #else:
            # plt.yticks([])
        #    axs[2, i].tick_params(labelleft=False)

        #if i == 7:
        #    plt.text(1.05, 0.5, '1 Mpc square maps', transform=axs[2, 7].transAxes, verticalalignment='center', rotation=270,
        #             fontsize=fs + 3)

        # plt.yticks(fontsize=fs)

        plt.xlim(0.001, 0.3)
        plt.ylim(1e4,1e12)

        if i == 4:
            plt.legend(fontsize=fs)

        # plt.legend(fontsize=fs)
    # plt.grid(True)
    plt.suptitle('2D Velocity Power Spectrum', fontsize=fs + 2)
    # f.legend([l1,l2,l3], labels=['Total','Compressive','Solenoidal'], loc='upper right', fontsize=fs)#, bbox_to_anchor=(0.5, 0.5))
    plt.show()

def energy_spectrum_2D_vs_3D_core_test():
    print('loading files')

    vx = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_12x12x20Mpc_cube.bin.npy')
    vy = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_12x12x20Mpc_cube.bin.npy')
    vz = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_12x12x20Mpc_cube.bin.npy')

    vx_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_comp_12x12x20Mpc_cube.bin.npy')
    vy_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_comp_12x12x20Mpc_cube.bin.npy')
    vz_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_comp_12x12x20Mpc_cube.bin.npy')

    vx_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_sol_12x12x20Mpc_cube.bin.npy')
    vy_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_sol_12x12x20Mpc_cube.bin.npy')
    vz_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_sol_12x12x20Mpc_cube.bin.npy')

    print('files loaded')

    def log_power_law(x,a,k):
        return np.log10(a)+k*np.log10(x)

    def power_law(x,a,k):
        return a*x**k

    nx, ny, nz = np.shape(vx)

    print("nx", nx, "ny", ny, "nz", nz)

    shiftx = 0
    shifty = 0
    shiftz = 0

    offsetx = 1
    offsety = 0
    offsetz = 0

    vx1 = np.array(vx[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx - offsetx),
                   int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                   int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vy1 = np.array(vy[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                   int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                   int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vz1 = np.array(vz[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                   int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                   int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

    vx_comp1 = np.array(vx_comp[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                        int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                        int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vy_comp1 = np.array(vy_comp[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                        int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                        int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vz_comp1 = np.array(vz_comp[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                        int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                        int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

    vx_sol1 = np.array(vx_sol[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vy_sol1 = np.array(vy_sol[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vz_sol1 = np.array(vz_sol[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

    print("shape vx1", np.shape(vx1), "shape vy1", np.shape(vy1), "shape vz1", np.shape(vz1))
    print("shape vx_comp1", np.shape(vx_comp1), "shape vy_comp1", np.shape(vy_comp1), "shape vz_comp1",
          np.shape(vz_comp1))
    print("shape vx_sol1", np.shape(vx_sol1), "shape vy_sol1", np.shape(vy_sol1), "shape vz_sol1",
          np.shape(vz_sol1))


    size = 1000

    Pk = PKL.Pk(vx1, size)
    k1 = Pk.k3D
    Pk_vx1 = Pk.Pk[:, 0]

    Pk = PKL.Pk(vy1, size)
    Pk_vy1 = Pk.Pk[:, 0]

    Pk = PKL.Pk(vz1, size)
    Pk_vz1 = Pk.Pk[:, 0]

    Pkcomp = PKL.Pk(vx_comp1, size)
    kcomp = Pkcomp.k3D
    Pk_vx1_comp = Pkcomp.Pk[:, 0]

    Pkcomp = PKL.Pk(vy_comp1, size)
    Pk_vy1_comp = Pkcomp.Pk[:, 0]

    Pkcomp = PKL.Pk(vz_comp1, size)
    Pk_vz1_comp = Pkcomp.Pk[:, 0]

    Pksol = PKL.Pk(vx_sol1, size)
    ksol = Pksol.k3D
    Pk_vx1_sol = Pksol.Pk[:, 0]

    Pksol = PKL.Pk(vy_sol1, size)
    Pk_vy1_sol = Pksol.Pk[:, 0]

    Pksol = PKL.Pk(vz_sol1, size)
    Pk_vz1_sol = Pksol.Pk[:, 0]

    ekv1 = 0.5 * (np.abs(Pk_vx1) + np.abs(Pk_vy1) + np.abs(Pk_vz1))
    ekv_comp1 = 0.5 * (np.abs(Pk_vx1_comp) + np.abs(Pk_vy1_comp) + np.abs(Pk_vz1_comp))
    ekv_sol1 = 0.5 * (np.abs(Pk_vx1_sol) + np.abs(Pk_vy1_sol) + np.abs(Pk_vz1_sol))

    plt.loglog(k1, ekv1, ls="dashed", color="black", alpha=0.7, marker=".", ms=4, label="3D P(k), total velocity")
    #plt.loglog(k1, ekv_comp1, label='Compressive', ls="dashed", color="blue", alpha=0.7, marker=".", ms=4)
    #plt.loglog(k1, ekv_sol1, label='Solenoidal', ls="dashed", color="red", alpha=0.7, marker=".", ms=4)

    cond = np.logical_and(k1 > 0.0015, k1 < 0.095)

    popt, pcov = curve_fit(log_power_law, k1[cond], np.log10(ekv1[cond]), p0=[100, -3.5],
                           bounds=([0, -10], [1e5, -2]))

    print("popt",popt)
    print("pcov",pcov)

    #k_fit_1[i, 0] = popt[1]
    #k_fit_1[i, 1] = pcov[1, 1]

    label_fit=r'3D slope fit: $\alpha$=' + str(round(popt[1], 2))

    #plt.loglog(k1[cond], power_law(k1[cond], *popt), ls="dotted", color='orange', alpha=0.7,label=label_fit)




    shiftx = 0
    shifty = 0
    shiftz = 0

    offsetx = 0
    offsety = 0
    offsetz = 0

    vx1 = np.array(vx[int(nx / 2 + shiftx),
                   int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                   int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vy1 = np.array(vy[int(nx / 2 + shiftx),
                   int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                   int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vz1 = np.array(vz[int(nx / 2 + shiftx),
                   int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                   int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

    vx_comp1 = np.array(vx_comp[int(nx / 2 + shiftx),
                        int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                        int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vy_comp1 = np.array(vy_comp[int(nx / 2 + shiftx),
                        int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                        int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vz_comp1 = np.array(vz_comp[int(nx / 2 + shiftx),
                        int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                        int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

    vx_sol1 = np.array(vx_sol[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vy_sol1 = np.array(vy_sol[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
    vz_sol1 = np.array(vz_sol[int(nx / 2 + shiftx),
                       int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                       int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

    print("shape vx1", np.shape(vx1), "shape vy1", np.shape(vy1), "shape vz1", np.shape(vz1))
    print("shape vx_comp1", np.shape(vx_comp1), "shape vy_comp1", np.shape(vy_comp1), "shape vz_comp1",
          np.shape(vz_comp1))
    print("shape vx_sol1", np.shape(vx_sol1), "shape vy_sol1", np.shape(vy_sol1), "shape vz_sol1",
          np.shape(vz_sol1))

    size = 1000

    Pk = PKL.Pk_plane(vx1, size)
    k1 = Pk.k
    Pk_vx1 = Pk.Pk

    Pk = PKL.Pk_plane(vy1, size)
    Pk_vy1 = Pk.Pk

    Pk = PKL.Pk_plane(vz1, size)
    Pk_vz1 = Pk.Pk

    Pkcomp = PKL.Pk_plane(vx_comp1, size)
    kcomp = Pkcomp.k
    Pk_vx1_comp = Pkcomp.Pk

    Pkcomp = PKL.Pk_plane(vy_comp1, size)
    Pk_vy1_comp = Pkcomp.Pk

    Pkcomp = PKL.Pk_plane(vz_comp1, size)
    Pk_vz1_comp = Pkcomp.Pk

    Pksol = PKL.Pk_plane(vx_sol1, size)
    ksol = Pksol.k
    Pk_vx1_sol = Pksol.Pk

    Pksol = PKL.Pk_plane(vy_sol1, size)
    Pk_vy1_sol = Pksol.Pk

    Pksol = PKL.Pk_plane(vz_sol1, size)
    Pk_vz1_sol = Pksol.Pk

    ekv1 = 0.5 * (np.abs(Pk_vx1) + np.abs(Pk_vy1) + np.abs(Pk_vz1))
    ekv_comp1 = 0.5 * (np.abs(Pk_vx1_comp) + np.abs(Pk_vy1_comp) + np.abs(Pk_vz1_comp))
    ekv_sol1 = 0.5 * (np.abs(Pk_vx1_sol) + np.abs(Pk_vy1_sol) + np.abs(Pk_vz1_sol))

    fs=14

    plt.loglog(k1, ekv1, ls="solid", color="black", alpha=0.7, marker=".", ms=4, label="2D P(k), total velocity")
    #plt.loglog(k1, ekv_comp1, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
    #plt.loglog(k1, ekv_sol1, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

    cond = np.logical_and(k1 > 0.0015, k1 < 0.095)

    popt, pcov = curve_fit(log_power_law, k1[cond], np.log10(ekv1[cond]), p0=[100, -3.5],
                           bounds=([0, -10], [1e5, -2]))

    print("popt", popt)
    print("pcov", pcov)

    # k_fit_1[i, 0] = popt[1]
    # k_fit_1[i, 1] = pcov[1, 1]

    label_fit=r'2D slope fit: $\alpha$=' + str(round(popt[1], 2))

    #plt.loglog(k1[cond], power_law(k1[cond], *popt), ls="dotted", color='green', alpha=0.7, label=label_fit)

    plt.xlabel("$k~\mathrm{[kpc^{-1}]}$", fontsize=fs)
    plt.ylabel("P(k)", fontsize=fs)
    #plt.xlim(0.001, 0.3)
    #plt.xlim(0.007, 0.1)
    plt.xticks(fontsize=fs)

    plt.axvline(x=0.1,color='grey',ls='dashed')
    plt.text(0.1,5e8,"Range of validity",color='grey',rotation=270)

    plt.axvline(x=0.1395, color='grey', ls='dotted')
    plt.text(0.1395,5e8,'Nyquist frequency',rotation=270,color='grey')
    plt.title("3D (2D) power spectra in 5Mpc cubed size box \n (squared size map) centred on the core of Virgo")

    plt.legend()

    plt.show()


def energy_spectrum_2D_vs_3D_test_all_slices():
    print('loading files')

    vx = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_12x12x20Mpc_cube.bin.npy')
    vy = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_12x12x20Mpc_cube.bin.npy')
    vz = np.load('./maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_12x12x20Mpc_cube.bin.npy')

    vx_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_comp_12x12x20Mpc_cube.bin.npy')
    vy_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_comp_12x12x20Mpc_cube.bin.npy')
    vz_comp = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_comp_12x12x20Mpc_cube.bin.npy')

    vx_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vx_sol_12x12x20Mpc_cube.bin.npy')
    vy_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vy_sol_12x12x20Mpc_cube.bin.npy')
    vz_sol = np.load(
        './maps/high_res/filament/3D_fields/map_3D_high_15_xyz_right_minus_0Mpc_vz_sol_12x12x20Mpc_cube.bin.npy')

    print('files loaded')

    def log_power_law(x,a,k):
        return np.log10(a)+k*np.log10(x)

    def power_law(x,a,k):
        return a*x**k


    nx, ny, nz = np.shape(vx)

    print("nx", nx, "ny", ny, "nz", nz)

    f, axs = plt.subplots(2, 4, figsize=(8, 8), constrained_layout=True)

    alpha_3D=np.zeros(8)
    alpha_2D=np.zeros(8)
    var_alpha_3D=np.zeros(8)
    var_alpha_2D=np.zeros(8)

    for j in range(0,2):

        for i in range(0,4):

            l = i + 4 * j

            print("i",i,"j",j,"l",l)

            print("3D")



            plt.sca(axs[j,i])

            shiftx = nx / 20  # =1 Mpc
            shifty = nx / 20  # =1 Mpc
            shiftz = nx / 20

            if l == 0:
                shiftx *= -8
                shifty *= 3.5
                shiftz *= 1.5

                # print("shiftx",shiftx)
                # print("shifty",shifty)
                # print("shiftz",shiftz)

                # sys.exit()

            if l == 1:
                shiftx *= -6
                shifty *= 1.5
                shiftz *= 1

            if l == 2:
                shiftx *= -4
                shifty *= 1.5
                shiftz *= 0.5
                # offsety=1

            if l == 3:
                shiftx *= -2
                shifty *= 0
                shiftz *= 0

            if l == 4:
                shiftx *= 0
                shifty *= 0
                shiftz *= 0

            if l == 5:
                shiftx *= 2
                shifty *= 0
                shiftz *= 0

            if l == 6:
                shiftx *= 4
                shifty *= -1
                shiftz *= 0
                # offsety=1

            if l == 7:
                shiftx *= 6
                shifty *= -2.5
                shiftz *= -0.5

            offsetx = 0
            offsety = 0
            offsetz = 0

            if l==3 or l==4 or l==5:
                offsetx = 1

            if l==1 :
                offsetx=-1

            if l==2 or l==6:
                offsety=1

            #if l==3:
            #    offsetx = 1



            vx1 = np.array(vx[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx - offsetx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vy1 = np.array(vy[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vz1 = np.array(vz[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                           int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                           int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

            vx_comp1 = np.array(vx_comp[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                                int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vy_comp1 = np.array(vy_comp[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                                int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vz_comp1 = np.array(vz_comp[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                                int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

            vx_sol1 = np.array(vx_sol[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vy_sol1 = np.array(vy_sol[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)
            vz_sol1 = np.array(vz_sol[int(nx / 2 -ny/24+ shiftx):int(nx / 2 +ny/24 + shiftx-offsetx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)], dtype=np.float32)

            print("shape vx1", np.shape(vx1), "shape vy1", np.shape(vy1), "shape vz1", np.shape(vz1))
            print("shape vx_comp1", np.shape(vx_comp1), "shape vy_comp1", np.shape(vy_comp1), "shape vz_comp1",
                  np.shape(vz_comp1))
            print("shape vx_sol1", np.shape(vx_sol1), "shape vy_sol1", np.shape(vy_sol1), "shape vz_sol1",
                  np.shape(vz_sol1))


            size = 1000

            Pk = PKL.Pk(vx1, size)
            k1 = Pk.k3D
            Pk_vx1 = Pk.Pk[:, 0]

            Pk = PKL.Pk(vy1, size)
            Pk_vy1 = Pk.Pk[:, 0]

            Pk = PKL.Pk(vz1, size)
            Pk_vz1 = Pk.Pk[:, 0]

            Pkcomp = PKL.Pk(vx_comp1, size)
            kcomp = Pkcomp.k3D
            Pk_vx1_comp = Pkcomp.Pk[:, 0]

            Pkcomp = PKL.Pk(vy_comp1, size)
            Pk_vy1_comp = Pkcomp.Pk[:, 0]

            Pkcomp = PKL.Pk(vz_comp1, size)
            Pk_vz1_comp = Pkcomp.Pk[:, 0]

            Pksol = PKL.Pk(vx_sol1, size)
            ksol = Pksol.k3D
            Pk_vx1_sol = Pksol.Pk[:, 0]

            Pksol = PKL.Pk(vy_sol1, size)
            Pk_vy1_sol = Pksol.Pk[:, 0]

            Pksol = PKL.Pk(vz_sol1, size)
            Pk_vz1_sol = Pksol.Pk[:, 0]

            ekv1 = 0.5 * (np.abs(Pk_vx1) + np.abs(Pk_vy1) + np.abs(Pk_vz1))
            ekv_comp1 = 0.5 * (np.abs(Pk_vx1_comp) + np.abs(Pk_vy1_comp) + np.abs(Pk_vz1_comp))
            ekv_sol1 = 0.5 * (np.abs(Pk_vx1_sol) + np.abs(Pk_vy1_sol) + np.abs(Pk_vz1_sol))

            plt.loglog(k1, ekv1, ls="dashed", color="black", alpha=0.7, marker=".", ms=4, label="3D P(k), total velocity")
            #plt.loglog(k1, ekv_comp1, label='Compressive', ls="dashed", color="blue", alpha=0.7, marker=".", ms=4)
            #plt.loglog(k1, ekv_sol1, label='Solenoidal', ls="dashed", color="red", alpha=0.7, marker=".", ms=4)

            cond = np.logical_and(k1 > 0.0015, k1 < 0.095)

            popt, pcov = curve_fit(log_power_law, k1[cond], np.log10(ekv1[cond]), p0=[100, -3.5],
                                   bounds=([0, -10], [1e5, -2]))

            print("popt",popt)
            print("pcov",pcov)



            #k_fit_1[i, 0] = popt[1]
            #k_fit_1[i, 1] = pcov[1, 1]

            label_fit=r'3D slope fit: $\alpha$=' + str(round(popt[1], 2))

            alpha_3D[l]=popt[1]
            var_alpha_3D[l]=pcov[1,1]

            plt.loglog(k1[cond], power_law(k1[cond], *popt), ls="dotted", color='orange', alpha=0.7,label=label_fit)

            print("2D")

            def compute_ek(i):

                print("i", i)

                offsety = 0
                offsetz = 0

                shiftx = nx / 20  # =1 Mpc
                shifty = nx / 20  # =1 Mpc
                shiftz = nx / 20

                if i == 0:
                    shiftx *= -8
                    shifty *= 3.5
                    shiftz *= 1.5

                    # print("shiftx",shiftx)
                    # print("shifty",shifty)
                    # print("shiftz",shiftz)

                    # sys.exit()

                if i == 1:
                    shiftx *= -6
                    shifty *= 1.5
                    shiftz *= 1

                if i == 2:
                    shiftx *= -4
                    shifty *= 1.5
                    shiftz *= 0.5
                    # offsety=1

                if i == 3:
                    shiftx *= -2
                    shifty *= 0
                    shiftz *= 0

                if i == 4:
                    shiftx *= 0
                    shifty *= 0
                    shiftz *= 0

                if i == 5:
                    shiftx *= 2
                    shifty *= 0
                    shiftz *= 0

                if i == 6:
                    shiftx *= 4
                    shifty *= -1
                    shiftz *= 0
                    # offsety=1

                if i == 7:
                    shiftx *= 6
                    shifty *= -2.5
                    shiftz *= -0.5

                print("shiftx",shiftx)

                vx5 = np.array(
                    vx[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                    int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
                vy5 = np.array(
                    vy[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                    int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
                vz5 = np.array(
                    vz[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                    int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

                vx_comp5 = np.array(
                    vx_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                    int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
                vy_comp5 = np.array(
                    vy_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                    int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
                vz_comp5 = np.array(
                    vz_comp[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                    int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

                vx_sol5 = np.array(
                    vx_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                    int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
                vy_sol5 = np.array(
                    vy_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                    int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)
                vz_sol5 = np.array(
                    vz_sol[int(nx / 2 + shiftx), int(ny * (3.5 / 12) + shifty):int(ny * (8.5 / 12) + shifty - offsety),
                    int(nz * (3.5 / 12) + shiftz):int(nz * (8.5 / 12) + shiftz)], dtype=np.float32)

                # Set centered cube of 2Mpc width
                offsetx = 0
                offsety = 0
                offsetz = 0
                v_sol2_offset = 0

                if i == 0:
                    v_sol2_offset = -1

                if i == 1:
                    v_sol2_offset = -1

                if i == 2:
                    offsety = 1
                    offsetz = 1
                    v_sol2_offset = -1

                if i == 3:
                    # offsetx = 1
                    offsety = 1
                    offsetz = 1

                if i == 4:
                    offsetx = 1
                    offsety = 1
                    offsetz = 1

                if i == 5:
                    offsetx = 1
                    offsety = 1
                    offsetz = 1

                if i == 6:
                    offsetx = 1
                    offsety = 1
                    offsetz = 0
                    v_sol2_offset = -1

                if i == 7:
                    offsetz = 1

                # print("shiftx",shiftx)

                vx2 = np.array(vx[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                               int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)],
                               dtype=np.float32)
                vy2 = np.array(vy[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                               int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)],
                               dtype=np.float32)
                vz2 = np.array(vz[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                               int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)],
                               dtype=np.float32)

                vx_comp2 = np.array(vx_comp[int(nx / 2 + shiftx),
                                    int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                                    int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)],
                                    dtype=np.float32)
                vy_comp2 = np.array(vy_comp[int(nx / 2 + shiftx),
                                    int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                                    int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)],
                                    dtype=np.float32)
                vz_comp2 = np.array(vz_comp[int(nx / 2 + shiftx),
                                    int(ny / 2 - ny / 12 + shifty):int(ny / 2 + ny / 12 - offsety + shifty),
                                    int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)],
                                    dtype=np.float32)

                vx_sol2 = np.array(vx_sol[int(nx / 2 + shiftx),
                                   int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                                   int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)],
                                   dtype=np.float32)
                vy_sol2 = np.array(vy_sol[int(nx / 2 + shiftx),
                                   int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                                   int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)],
                                   dtype=np.float32)
                vz_sol2 = np.array(vz_sol[int(nx / 2 + shiftx),
                                   int(ny / 2 - ny / 12):int(ny / 2 + ny / 12 - offsety - v_sol2_offset),
                                   int(nz / 2 - nz / 12 + shiftz):int(nz / 2 + nz / 12 + shiftz - offsetz)],
                                   dtype=np.float32)

                # Set centered cube of 1Mpc width

                offsetx = 0
                offsety = 0
                offsetz = 0

                if i == 2:
                    offsetx = 0
                    offsety = 1
                    # offsetz = 1

                if i == 3:
                    offsetx = 0
                    offsety = 1
                    offsetz = 1

                if i == 6:
                    offsetx = 0
                    offsety = 1
                    # offsetz = 1

                # if i==7:

                # offsety=1

                vx1 = np.array(vx[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)],
                               dtype=np.float32)
                vy1 = np.array(vy[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)],
                               dtype=np.float32)
                vz1 = np.array(vz[int(nx / 2 + shiftx),
                               int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                               int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)],
                               dtype=np.float32)

                vx_comp1 = np.array(vx_comp[int(nx / 2 + shiftx),
                                    int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                    int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)],
                                    dtype=np.float32)
                vy_comp1 = np.array(vy_comp[int(nx / 2 + shiftx),
                                    int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                    int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)],
                                    dtype=np.float32)
                vz_comp1 = np.array(vz_comp[int(nx / 2 + shiftx),
                                    int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                    int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)],
                                    dtype=np.float32)

                vx_sol1 = np.array(vx_sol[int(nx / 2 + shiftx),
                                   int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                   int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)],
                                   dtype=np.float32)
                vy_sol1 = np.array(vy_sol[int(nx / 2 + shiftx),
                                   int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                   int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)],
                                   dtype=np.float32)
                vz_sol1 = np.array(vz_sol[int(nx / 2 + shiftx),
                                   int(ny / 2 - ny / 24 + shifty):int(ny / 2 + ny / 24 + shifty - offsety),
                                   int(nz / 2 - nz / 24 + shiftz):int(nz / 2 + nz / 24 + shiftz - offsetz)],
                                   dtype=np.float32)

                #print("shape vx5", np.shape(vx5), "shape vy5", np.shape(vy5), "shape vz5", np.shape(vz5))
                #print("shape vx_comp5", np.shape(vx_comp5), "shape vy_comp5", np.shape(vy_comp5), "shape vz_comp5",
                #      np.shape(vz_comp5))
                #print("shape vx_sol5", np.shape(vx_sol5), "shape vy_sol5", np.shape(vy_sol5), "shape vz_sol5",
                #      np.shape(vz_sol5))

                #print("shape vx2", np.shape(vx2), "shape vy2", np.shape(vy2), "shape vz2", np.shape(vz2))
                #print("shape vx_comp2", np.shape(vx_comp2), "shape vy_comp2", np.shape(vy_comp2), "shape vz_comp2",
                #      np.shape(vz_comp2))
                #print("shape vx_sol2", np.shape(vx_sol2), "shape vy_sol2", np.shape(vy_sol2), "shape vz_sol2",
                #      np.shape(vz_sol2))

                print("shape vx1", np.shape(vx1), "shape vy1", np.shape(vy1), "shape vz1", np.shape(vz1))
                print("shape vx_comp1", np.shape(vx_comp1), "shape vy_comp1", np.shape(vy_comp1), "shape vz_comp1",
                      np.shape(vz_comp1))
                print("shape vx_sol1", np.shape(vx_sol1), "shape vy_sol1", np.shape(vy_sol1), "shape vz_sol1",
                      np.shape(vz_sol1))

                # sys.exit()

                def manual_energy_spectrum_3D():
                    print("fft")

                    start = time.time()

                    vxk5 = np.fft.fftn(vx5)
                    vyk5 = np.fft.fftn(vy5)
                    vzk5 = np.fft.fftn(vz5)

                    vxk_comp5 = np.fft.fftn(vx_comp5)
                    vyk_comp5 = np.fft.fftn(vy_comp5)
                    vzk_comp5 = np.fft.fftn(vz_comp5)

                    vxk_sol5 = np.fft.fftn(vx_sol5)
                    vyk_sol5 = np.fft.fftn(vy_sol5)
                    vzk_sol5 = np.fft.fftn(vz_sol5)

                    vxk2 = np.fft.fftn(vx2)
                    vyk2 = np.fft.fftn(vy2)
                    vzk2 = np.fft.fftn(vz2)

                    vxk_comp2 = np.fft.fftn(vx_comp2)
                    vyk_comp2 = np.fft.fftn(vy_comp2)
                    vzk_comp2 = np.fft.fftn(vz_comp2)

                    vxk_sol2 = np.fft.fftn(vx_sol2)
                    vyk_sol2 = np.fft.fftn(vy_sol2)
                    vzk_sol2 = np.fft.fftn(vz_sol2)

                    vxk1 = np.fft.fftn(vx1)
                    vyk1 = np.fft.fftn(vy1)
                    vzk1 = np.fft.fftn(vz1)

                    vxk_comp1 = np.fft.fftn(vx_comp1)
                    vyk_comp1 = np.fft.fftn(vy_comp1)
                    vzk_comp1 = np.fft.fftn(vz_comp1)

                    vxk_sol1 = np.fft.fftn(vx_sol1)
                    vyk_sol1 = np.fft.fftn(vy_sol1)
                    vzk_sol1 = np.fft.fftn(vz_sol1)

                    end = time.time()

                    print("fft done, time =", end - start)

                    ekv5 = 0.5 * (np.abs(vxk5) ** 2 + np.abs(vyk5) ** 2 + np.abs(vzk5) ** 2)
                    ekv_comp5 = 0.5 * (np.abs(vxk_comp5) ** 2 + np.abs(vyk_comp5) ** 2 + np.abs(vzk_comp5) ** 2)
                    ekv_sol5 = 0.5 * (np.abs(vxk_sol5) ** 2 + np.abs(vyk_sol5) ** 2 + np.abs(vzk_sol5) ** 2)

                    ekv2 = 0.2 * (np.abs(vxk2) ** 2 + np.abs(vyk2) ** 2 + np.abs(vzk2) ** 2)
                    ekv_comp2 = 0.2 * (np.abs(vxk_comp2) ** 2 + np.abs(vyk_comp2) ** 2 + np.abs(vzk_comp2) ** 2)
                    ekv_sol2 = 0.2 * (np.abs(vxk_sol2) ** 2 + np.abs(vyk_sol2) ** 2 + np.abs(vzk_sol2) ** 2)

                    ekv1 = 0.1 * (np.abs(vxk1) ** 2 + np.abs(vyk1) ** 2 + np.abs(vzk1) ** 2)
                    ekv_comp1 = 0.1 * (np.abs(vxk_comp1) ** 2 + np.abs(vyk_comp1) ** 2 + np.abs(vzk_comp1) ** 2)
                    ekv_sol1 = 0.1 * (np.abs(vxk_sol1) ** 2 + np.abs(vyk_sol1) ** 2 + np.abs(vzk_sol1) ** 2)

                # Pk = PKL.Pk_plane(vpk, size)
                # k = Pk.k
                # Pk = Pk.Pk

                # Pkcomp = PKL.Pk_plane(vcomppk, size)
                # kcomp = Pkcomp.k
                # Pkcomp = Pkcomp.Pk

                # Pksol = PKL.Pk_plane(vsolpk, size)
                # ksol = Pksol.k
                # Pksol = Pksol.Pk

                ### not needed for this function #####

                #size = 5000

                #Pk = PKL.Pk_plane(vx5, size)
                #k5 = Pk.k
                #Pk_vx5 = Pk.Pk

                #Pk = PKL.Pk_plane(vy5, size)
                #Pk_vy5 = Pk.Pk

                #Pk = PKL.Pk_plane(vz5, size)
                #Pk_vz5 = Pk.Pk

                #Pkcomp = PKL.Pk_plane(vx_comp5, size)
                #kcomp = Pkcomp.k
                #Pk_vx5_comp = Pkcomp.Pk

                #Pkcomp = PKL.Pk_plane(vy_comp5, size)
                #Pk_vy5_comp = Pkcomp.Pk

                #Pkcomp = PKL.Pk_plane(vz_comp5, size)
                #Pk_vz5_comp = Pkcomp.Pk

                #Pksol = PKL.Pk_plane(vx_sol5, size)
                #ksol = Pksol.k
                #Pk_vx5_sol = Pksol.Pk

                #Pksol = PKL.Pk_plane(vy_sol5, size)
                #Pk_vy5_sol = Pksol.Pk

                #Pksol = PKL.Pk_plane(vz_sol5, size)
                #Pk_vz5_sol = Pksol.Pk

                #ekv5 = 0.5 * (np.abs(Pk_vx5) + np.abs(Pk_vy5) + np.abs(Pk_vz5))
                #ekv_comp5 = 0.5 * (np.abs(Pk_vx5_comp) + np.abs(Pk_vy5_comp) + np.abs(Pk_vz5_comp))
                #ekv_sol5 = 0.5 * (np.abs(Pk_vx5_sol) + np.abs(Pk_vy5_sol) + np.abs(Pk_vz5_sol))

                #size = 2000

                #Pk = PKL.Pk_plane(vx2, size)
                #k2 = Pk.k
                #Pk_vx2 = Pk.Pk

                #Pk = PKL.Pk_plane(vy2, size)
                #Pk_vy2 = Pk.Pk

                #Pk = PKL.Pk_plane(vz2, size)
                #Pk_vz2 = Pk.Pk

                #Pkcomp = PKL.Pk_plane(vx_comp2, size)
                #kcomp = Pkcomp.k
                #Pk_vx2_comp = Pkcomp.Pk

                #kcomp = PKL.Pk_plane(vy_comp2, size)
                #Pk_vy2_comp = Pkcomp.Pk

                #Pkcomp = PKL.Pk_plane(vz_comp2, size)
                #Pk_vz2_comp = Pkcomp.Pk

                #Pksol = PKL.Pk_plane(vx_sol2, size)
                #ksol = Pksol.k
                #Pk_vx2_sol = Pksol.Pk

                #Pksol = PKL.Pk_plane(vy_sol2, size)
                #Pk_vy2_sol = Pksol.Pk

                #Pksol = PKL.Pk_plane(vz_sol2, size)
                #Pk_vz2_sol = Pksol.Pk

                #ekv2 = 0.5 * (np.abs(Pk_vx2) + np.abs(Pk_vy2) + np.abs(Pk_vz2))
                #ekv_comp2 = 0.5 * (np.abs(Pk_vx2_comp) + np.abs(Pk_vy2_comp) + np.abs(Pk_vz2_comp))
                #ekv_sol2 = 0.5 * (np.abs(Pk_vx2_sol) + np.abs(Pk_vy2_sol) + np.abs(Pk_vz2_sol))

                size = 1000

                Pk = PKL.Pk_plane(vx1, size)
                k1 = Pk.k
                Pk_vx1 = Pk.Pk

                Pk = PKL.Pk_plane(vy1, size)
                Pk_vy1 = Pk.Pk

                Pk = PKL.Pk_plane(vz1, size)
                Pk_vz1 = Pk.Pk

                #Pkcomp = PKL.Pk_plane(vx_comp1, size)
                #kcomp = Pkcomp.k
                #Pk_vx1_comp = Pkcomp.Pk

                #Pkcomp = PKL.Pk_plane(vy_comp1, size)
                #Pk_vy1_comp = Pkcomp.Pk

                #Pkcomp = PKL.Pk_plane(vz_comp1, size)
                #Pk_vz1_comp = Pkcomp.Pk

                #Pksol = PKL.Pk_plane(vx_sol1, size)
                #ksol = Pksol.k
                #Pk_vx1_sol = Pksol.Pk

                #Pksol = PKL.Pk_plane(vy_sol1, size)
                #Pk_vy1_sol = Pksol.Pk

                #Pksol = PKL.Pk_plane(vz_sol1, size)
                #Pk_vz1_sol = Pksol.Pk

                ekv1 = 0.5 * (np.abs(Pk_vx1) + np.abs(Pk_vy1) + np.abs(Pk_vz1))
                #ekv_comp1 = 0.5 * (np.abs(Pk_vx1_comp) + np.abs(Pk_vy1_comp) + np.abs(Pk_vz1_comp))
                #ekv_sol1 = 0.5 * (np.abs(Pk_vx1_sol) + np.abs(Pk_vy1_sol) + np.abs(Pk_vz1_sol))

                return k1, ekv1 #k1, k2, k5, ekv5, ekv_comp5, ekv_sol5, ekv2, ekv_comp2, ekv_sol2, ekv1, ekv_comp1, ekv_sol1

            k1, ekv1 = compute_ek(l)

            fs=14

            plt.loglog(k1, ekv1, ls="solid", color="black", alpha=0.7, marker=".", ms=4, label="2D P(k), total velocity")
            #plt.loglog(k1, ekv_comp1, label='Compressive', ls="solid", color="blue", alpha=0.7, marker=".", ms=4)
            #plt.loglog(k1, ekv_sol1, label='Solenoidal', ls="solid", color="red", alpha=0.7, marker=".", ms=4)

            cond = np.logical_and(k1 > 0.0015, k1 < 0.095)

            popt, pcov = curve_fit(log_power_law, k1[cond], np.log10(ekv1[cond]), p0=[100, -3.5],
                                   bounds=([0, -10], [1e5, -2]))

            print("popt", popt)
            print("pcov", pcov)

            # k_fit_1[i, 0] = popt[1]
            # k_fit_1[i, 1] = pcov[1, 1]

            label_fit=r'2D slope fit: $\alpha$=' + str(round(popt[1], 2))

            alpha_2D[l]=popt[1]
            var_alpha_2D[l]=pcov[1,1]

            plt.loglog(k1[cond], power_law(k1[cond], *popt), ls="dotted", color='green', alpha=0.7, label=label_fit)

            if j==1:
                plt.xlabel("$k~\mathrm{[kpc^{-1}]}$", fontsize=fs)
                plt.xticks(fontsize=fs)
            else :
                plt.xticks([])

            if i==0:
                plt.ylabel("P(k)", fontsize=fs)
                plt.yticks(fontsize=fs)
            else:
                plt.yticks([])

            #plt.xlim(0.001, 0.3)
            plt.xlim(0.007, 0.1)
            plt.ylim(1e5,4e12)

            pos=-8+2*l
            title=r'$\Delta x_{cen}$= '+str(pos) + ' Mpc'
            plt.title(title, fontsize=fs)



            plt.legend(fontsize=10)


    print("alpha 2D", alpha_2D)
    print("var alpha 2D", var_alpha_2D)
    print("alpha 3D", alpha_3D)
    print("var alpha 3D", var_alpha_3D)
    print("alpha ratios", alpha_2D/alpha_3D)

    var_ratio=(alpha_2D/alpha_3D)*((var_alpha_2D/alpha_2D)+(var_alpha_3D/alpha_3D))
    print("var alpha ratios", var_ratio)
    plt.show()

    sys.exit()

def convolution_test():
    def kolmog(A, k):
        return A * k ** (-5 / 3)

    xkolmo=np.linspace(0.0015, 0.095, 100000)

    xsinc=np.linspace(-100, 100, 100000)

    test = (1/(2*np.pi))*np.convolve(kolmog(1e5, xkolmo), np.sinc(22.4*xsinc), mode='same')

    f,axs = plt.subplots(1,2,figsize=(8,6),tight_layout=True)

    plt.sca(axs[0])

    plt.plot(xsinc,np.sinc(22.4*xsinc), label='sinc(22.4k)')
    plt.xlabel('k [kpc$^{-1}$]')
    plt.ylabel('sinc(22.4k)')
    plt.xlim(-1,1)

    plt.sca(axs[1])

    plt.plot(xkolmo, kolmog(1, xkolmo), label='Kolmogorov')
    plt.plot(xkolmo, test, label="convolution product")
    #plt.plot(xsinc,np.sinc(22.4*xsinc), label='sinc')
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('k [kpc$^{-1}$]')
    plt.ylabel('E(k)')
    plt.legend()

    plt.show()
    sys.exit()

def check_gal_pos_in_slice():
    list_gal = np.loadtxt("/data/cluster/byopic/SIMS/VirgoClone/HighRes/list_gal_251.dat_js_nocontam")

    print(list_gal[0])
    print(len(list_gal[:,0]))

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    zmin=z_cen-(6.78e-5*2)
    zmax=z_cen+(6.78e-5*2)
    xmin=x_cen-(0.01356/2)
    xmax=x_cen-(6.78e-3/5)
    ymin=y_cen-(6.78e-3/2)
    ymax=y_cen+(6.78e-3/2)

    print("zmin",zmin,"zmax",zmax)

    n=0

    for i in range(len(list_gal[:,0])):
        if list_gal[i,5]>zmin and list_gal[i,5]<zmax and list_gal[i,3]>xmin and list_gal[i,3]<xmax and list_gal[i,4]>ymin and list_gal[i,4]<ymax:
            print("x ", (list_gal[i,3] - x_cen) * (unit_l / 3.08567758128E21),"y ",(list_gal[i,4] - y_cen) * (unit_l / 3.08567758128E21),"z ",(list_gal[i,5] - z_cen) * (unit_l / 3.08567758128E21))
            n=n+1
    print("n",n)


    sys.exit()

# Project 4 : VSF in Virgo's core (w S.Ettori)

def VSF(order):  #adaptation of Jade's code
    #file = "./maps/high_res/velocity/map_high_19_z_core_map_vz.bin"
    #file = "./maps/high_res/velocity/map_high_16_z_map_vz.bin"

    #file = "./maps/high_res/velocity/map_high_16f16_z_map_vz_ew.bin"
    file = "./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_mw_Tsup7_5Mpc2.bin"
    savefile = "./vel_Virgo_core_project/VSF_data/jan25_run/VSF1_vx_mw_lvl15.npy"

    proj="x"

    h = FortranFile(file, 'r')

    nx, ny, nz = h.read_ints()
    print("nx", nx, "ny", ny, "nz", nz,"proj",proj)
    #sys.exit()
    cen_x, cen_y, cen_z = h.read_reals()
    if proj=="z":
        ncell = nx * ny
    if proj=="y":
        ncell = nx * nz
    if proj=="x":
        ncell = ny * nz
    map = np.zeros(ncell)
    map = ftp.f90_to_py.read_map_file(ncell, file, 0)

    matrice = np.array(map)
    matrice_size = int(math.sqrt(len(map)))
    shape = (matrice_size, matrice_size)
    matrice.reshape(shape)
    donnees_array = np.array(matrice)

    # Redimensionner le tableau en un tableau 2D
    if proj=="z":
        image = donnees_array.reshape((nx, ny))
    if proj=="y":
        image = donnees_array.reshape((nx, nz))
    if proj=="x":
        image = donnees_array.reshape((ny, nz))

    # Initialisation de la matrice 1966x1966
    #print("image shape", image.shape)
    #print("image", image)

    matrix_large = image
    # Taille de la sous-matrice
    #sub_matrix_size = 245
    sub_matrix_size = 222

    # Calcul des indices de début et de fin
    n=int(np.sqrt(ncell))
    start_index = (n - sub_matrix_size) // 2
    end_index = start_index + sub_matrix_size

    # Extraction de la sous-matrice
    sub_matrix = np.array(matrix_large[start_index:end_index, start_index:end_index])

    #print("sub matrix shape",sub_matrix.shape)

    # Initialisation de la matrice et des coordonnées
    matrix = sub_matrix
    #matrix = image

    #print("matrix shape",matrix.shape)
    #print("matrix",matrix)
    #sys.exit()
    rows, cols = matrix.shape
    x = np.array([np.arange(0, cols) for i in range(cols)])
    y = np.array([[j for i in range(cols)] for j in range(cols)])
    x = x.reshape(-1)
    y = y.reshape(-1)
    #print(x)

    #sys.exit()

    matrix_list = matrix.reshape(-1)

    max_dist = np.sqrt(2*sub_matrix_size**2)

    bins = np.logspace(0, np.log10(max_dist), 101)
    bin_cen = 0.5 * (bins[1:] + bins[:-1])
    sum_v = np.zeros(len(bin_cen))
    results = [[] for i in range(len(bin_cen))]
    #nb = np.zeros(len(bin_cen))
    map_width=sub_matrix_size
    mean = np.zeros(len(bin_cen))
    std = np.zeros(len(bin_cen))
    n_pairs_per_bin = np.zeros(len(bin_cen))

    #print("mean",mean,"std",std)

    #sys.exit()

    #print("bins",bins)
    #print("bin_cen",bin_cen)

    #sys.exit()

    @njit(fastmath=True)
    def fonction(x, y, matrix): #Jade's function
        sum_v_dict = {}
        nb_dict = {}
        index = 0
        for i in range(len(x) - 1):
            #print("i",i)
            for j in range(i + 1, len(x)):

                dist = np.sqrt((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2)
                diff = np.abs(matrix[i // cols, i % cols] - matrix[j // cols, j % cols])
                if dist in sum_v_dict:
                    sum_v_dict[dist] += diff
                    nb_dict[dist] += 1
                else:
                    sum_v_dict[dist] = diff
                    nb_dict[dist] = 1

                #print("dist",dist,"diff",diff)

            # Les listes dist et diff sont automatiquement réinitialisées à chaque itération
        unique_d = (np.array(list(sum_v_dict.keys())))
        sum_v = np.array([sum_v_dict[d] for d in unique_d])
        nb = np.array([nb_dict[d] for d in unique_d])

        # Multiplication de unique_d par (737441 / 2^19)
        unique_d = unique_d * (737441 / pow(2, 19))

        # Division de sum_v par nb
        #sum_v = sum_v / nb

        return unique_d, sum_v, nb

    #@njit(fastmath=True)
    def compute_VSF(x, y, matrix):
        sum_v_dict = {}
        nb_dict = {}
        index = 0
        for i in prange(len(x) - 1):
            # print("i",i)
            x1 = x[i:len(x)-1]
            x2 = x[i+1::]
            y1 = y[i:len(y)-1]
            y2 = y[i+1::]

            dist = jnp.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)

            matrix_list1 = matrix_list[i:len(matrix_list)-1]
            matrix_list2 = matrix_list[i+1::]

            diff = jnp.abs(matrix_list1 - matrix_list2)

            dist=np.array(dist)
            print("dist",dist)

            diff=np.array(diff)

            print("diff",diff)

            for j in range(len(dist)):

                #dist = jnp.sqrt((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2)
                #diff = np.abs(matrix[i // cols, i % cols] - matrix[j // cols, j % cols])
                #print("matrix i",matrix[i // cols, i % cols],"matrix j",matrix[j // cols, j % cols])
                #print("matrix_list i",matrix_list[i],"matrix_list j",matrix_list[j])
                #diff = jnp.abs(matrix_list[i] - matrix_list[j])

                if dist[j] in sum_v_dict:
                    sum_v_dict[dist[j]] += diff[j]
                    nb_dict[dist[j]] += 1
                else:
                    sum_v_dict[dist[j]] = diff[j]
                    nb_dict[dist[j]] = 1

            # Les listes dist et diff sont automatiquement réinitialisées à chaque itération

        #print("sum_v_dict",sum_v_dict)

        unique_d = (np.array(list(sum_v_dict.keys())))

        #print("unique_d", unique_d)
        sum_v = np.array([sum_v_dict[d] for d in unique_d])
        nb = np.array([nb_dict[d] for d in unique_d])

        # Multiplication de unique_d par (737441 / 2^19)
        unique_d = unique_d * (737441 / pow(2, 19))

        # Division de sum_v par nb
        sum_v = sum_v / nb

        return unique_d, sum_v, nb

    @njit(fastmath=True)
    def j_loop_jit(x, y, matrix_list,i,dist,diff,n):

        for j in prange(i + 1, len(x)):

            dist[j - i - 1] = np.sqrt((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2)
            diff[j - i - 1] = np.abs(matrix_list[i] - matrix_list[j])**n

        return dist, diff

    #@njit
    def k_loop_jit(dist,diff,sum_v,nb,bins):
        for k in range(0, len(sum_v)):
            cond = np.logical_and(dist >= bins[k], dist < bins[k + 1])
            sum_v[k] += np.sum(diff[cond])
            nb[k] += len(diff[cond])
            #sum_v[k] += np.sum(diff[index == k + 1])
            #nb[k] += len(diff[index == k + 1])

    #@njit(fastmath=True)
    def j_loop_jit_2(x, y, matrix_list,i,bins,results):

        for j in prange(i + 1, len(x)):

            dist = np.sqrt((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2)
            diff = np.abs(matrix_list[i] - matrix_list[j])
            for k in range(len(sum_v)):
                if bins[k] <= dist < bins[k + 1]:
                    results[k].append(diff)
                    #nb[k] += 1
                    break

        return dist, diff


    #@njit
    def k_loop_jit_2(dist, diff, results, bins):
        for i in range(len(dist)):
            for k in range(len(sum_v)):
                if bins[k] <= dist[i] < bins[k + 1]:
                    #sum_v[k] += diff[i]
                    #nb[k] += 1
                    results[k].append(diff[i])
                    break


    #@njit(fastmath=True)
    def VSF_opti(x, y, matrix_list,mean,std,order,bin_cen):
        n_pairs=map_width**2*(map_width**2-1)*0.5
        print(n_pairs)
        dist_large=np.zeros(int(n_pairs))
        diff_large=np.zeros(int(n_pairs))
        mem_size_dist=sys.getsizeof(dist_large)
        mem_size_diff=sys.getsizeof(diff_large)
        print("mem_size_dist",mem_size_dist,'mem_size_diff',mem_size_diff)
        #sys.exit()
        #print("results",results)
        #results[:].append(0)
        #print("results",results)
        n=0
        #sum_v_dict = {}
        #nb_dict = {}
        #index = 0
        start_i_loop=time.time()
        for i in range(len(x) - 1):
        #for i in range(100):


            #start=time.time()
            #dist=np.sqrt((x[i] - x[i+1::]) ** 2 + (y[i] - y[i+1::]) ** 2)
            #diff=np.abs(matrix_list[i] - matrix_list[i+1::])


            #print("time",time.time()-start)

            start=time.time()

            dist = np.zeros(len(x) - i - 1)
            diff = np.zeros(len(x) - i - 1)


            #print("i",i)
            #dist=0
            #diff=0
            #index=np.zeros(1)

            j_loop_jit(x, y, matrix_list,i,dist,diff,order)

            dist_large[n:n+len(dist)]=dist
            diff_large[n:n+len(diff)]=diff
            n+=len(dist)

            #print("time j loop 1",time.time()-start)

            #sys.exit()

            #j_loop_jit_2(x, y, matrix_list,i,bins)

            #for j in range(i + 1, len(x)):

                #dist[j-i-1] = np.sqrt((x[i] - x[j]) ** 2 + (y[i] - y[j]) ** 2)
                #diff = jnp.abs(matrix[i // cols, i % cols] - matrix[j // cols, j % cols])
                #diff[j-i-1] = np.abs(matrix_list[i] - matrix_list[j])

            #index = np.digitize(dist,bin_cen)

            #print("index len",len(index))
            #print("index",index)
            #print(diff[index==1])

            #start=time.time()

            #k_loop_jit(dist,diff,sum_v,nb,bins)

            #print('time k loop 1',time.time()-start)

            #start = time.time()

            #k_loop_jit_2(dist, diff, results, bins)

            #print('time', time.time() - start)



            #if i==10:
            #    sys.exit()

            #for k in range(0,len(sum_v)):
            #    sum_v[k]+=np.sum(diff[index==k+1])
            #    nb[k]+=len(diff[index==k])
                #sys.exit()
            #sum_v[np.digitize(dist,bin_cen)]+=diff
            #nb[np.digitize(dist,bin_cen)]+=1


                #dist= np.float(dist)
                #if dist in sum_v_dict:
                #    sum_v_dict[dist] += diff
                #    nb_dict[dist] += 1
                #else:
                #    sum_v_dict[dist] = diff
                #    nb_dict[dist] = 1

                #print("dist",dist,"diff",diff)

            # Les listes dist et diff sont automatiquement réinitialisées à chaque itération
        #unique_d = np.array(list(sum_v_dict.keys()))
        #sum_v = np.array([sum_v_dict[d] for d in unique_d])
        #nb = np.array([nb_dict[d] for d in unique_d])

        # Multiplication de unique_d par (737441 / 2^19)
        #unique_d = unique_d * (737441 / pow(2, 19))

        # Division de sum_v par nb
        #sum_v = sum_v / nb
        print("time i loop",time.time()-start_i_loop)

        start_mean_loop = time.time()

        index = np.digitize(dist_large, bins)-1

        print("RAM allocation time", time.time() - start_mean_loop)

        print("indexing done")

        for k in range(len(bin_cen)):
            start_k_loop = time.time()
            mean[k]=np.mean(diff_large[index == k])
            std[k]=np.std(diff_large[index == k])
            n_pairs_per_bin[k]=len(diff_large[index == k])
            if k%10==0:
                print("k",k)
                print("time k loop", time.time() - start_k_loop)

            #sys.exit()



        print("total time mean loop",time.time()-start_mean_loop)



        #results = [[] for i in range(len(bin_cen))]
        #mean= np.array([np.mean(results[i]) for i in range(len(bin_cen))])
        #std = np.array([np.std(results[i]) for i in range(len(bin_cen))])

        return mean,std
    def speed_comparison_plot():
        n = np.array([50, 100, 200])
        t = np.array([2.78, 14.21, 212.45]) #300 : 1199s
        t2 = np.array([0.79, 3.08, 37.14])

        plt.plot(n, t, label="Jade's")
        plt.plot(n, t2, label="Jade's optimized")
        plt.xlabel("map width in pixels")
        plt.ylabel("execution time in seconds")
        plt.legend()
        plt.show()

        sys.exit()
    def nb_val_per_bin_plot():
        n_pairs_per_bin = np.load("n_pairs_per_bin.npy")
        vx_ew = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vx_ew_lvl15.npy")

        matrix_size = 222
        max_dist = np.sqrt(2 * matrix_size ** 2)

        bins = np.logspace(0, np.log10(max_dist), 101)
        bin_cen = 0.5 * (bins[1:] + bins[:-1])

        pxlvl = 15
        bin_cen *= (737441 / 2 ** pxlvl)

        f, ax = plt.subplots(2, 1, figsize=(8, 8), constrained_layout='True', gridspec_kw={'height_ratios': [3, 1], "hspace": 0})

        plt.sca(ax[0])

        plt.plot(bin_cen, vx_ew[:, 0], label='$v_x$ EW' , marker='.', color='red', ls="dashed", ms=7, alpha=0.6)
        plt.fill_between(bin_cen, vx_ew[:, 0] - vx_ew[:, 1], vx_ew[:, 0] + vx_ew[:, 1], alpha=0.6, color='red')


        plt.title("Definition of the range of validity")
        plt.ylim(0, 450)
        plt.xlim(20, 7300)
        plt.ylabel("$\delta v^1(r)$ $[\mathrm{km\,s^{-1}}]$")
        # plt.xlabel("Separation [kpc]")
        plt.xscale("log")
        plt.legend(loc='upper left')
        plt.xticks([])
        plt.axvline(x=100, color='grey', ls='dashed')
        plt.axvline(x=4000, color='grey', ls='dashed')
        plt.text(350, 400, "Range of validity")
        ax[0].xaxis.set_visible(False)

        plt.sca(ax[1])

        print("n pairs per bin", n_pairs_per_bin)
        plt.plot(bin_cen, n_pairs_per_bin, marker='.', ls=None, color='black')
        plt.xscale('log')
        plt.yscale('log')
        plt.xlabel('Separation [kpc]')
        plt.ylabel('Number of values per bin')
        plt.axvline(x=100, color='grey', ls='dashed')
        plt.axvline(x=4000, color='grey', ls='dashed')
        plt.text(350, 1e5, "Range of validity")
        plt.xlim(20, 7300)
        plt.show()
        sys.exit()

    def power_law(x,a,alpha):
        return a*x**alpha

    def log_power_law(x,a,k):
        return np.log10(a)+k*np.log10(x)

    def VSF_compare_plot():
        data_vx_ew = np.load("./vel_Virgo_core_project/VSF_data/VSF1_vx_ew.npy")
        data_vy_ew = np.load("./vel_Virgo_core_project/VSF_data/VSF1_vy_ew.npy")
        data_vz_ew = np.load("./vel_Virgo_core_project/VSF_data/VSF1_vz_ew.npy")
        data_vz_ew_Tsup7 = np.load("./vel_Virgo_core_project/VSF_data/VSF1_vz_ew_Tsup7.npy")
        data_vz_mw = np.load("./vel_Virgo_core_project/VSF_data/VSF1_vz_mw.npy")

        #data_vz_ew_15 = np.load("./vel_Virgo_core_project/VSF_data/VSF1_vz_ew_15_200.npy")
        #data_vx_ew_15 = np.load("./vel_Virgo_core_project/VSF_data/VSF1_vx_ew_15_200.npy")
        #data_vy_ew_15 = np.load("./vel_Virgo_core_project/VSF_data/VSF1_vy_ew_15_200.npy")

        data_vx_ew_15_2 = np.load("./vel_Virgo_core_project/VSF_data/VSF2_vx_ew_15_200.npy")
        data_vy_ew_15_2 = np.load("./vel_Virgo_core_project/VSF_data/VSF2_vy_ew_15_200.npy")
        data_vz_ew_15_2 = np.load("./vel_Virgo_core_project/VSF_data/VSF2_vz_ew_15_200.npy")

        data_vz_ew_15 = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vz_ew_lvl15.npy")
        data_vx_ew_15 = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vx_ew_lvl15.npy")
        data_vy_ew_15 = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vy_ew_lvl15.npy")

        data_vz_mw_15 = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vz_mw_lvl15.npy")
        data_vx_mw_15 = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vx_mw_lvl15.npy")
        data_vy_mw_15 = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vy_mw_lvl15.npy")

        #binning for 100x100 matrix




        plot_type="mw_vs_ew_comp_15_222_1"

        if plot_type=="z_comp":
            sub_matrix_size = 100

            max_dist = np.sqrt(2 * sub_matrix_size ** 2)

            bins = np.logspace(0, np.log10(max_dist), 101)
            bin_cen = 0.5 * (bins[1:] + bins[:-1])

            pxlvl = 16
            bin_cen *= (737441 / 2 ** pxlvl)

            plt.scatter(bin_cen, data_vz_ew[:, 0], label='z EW', marker='.', color='green')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vz_ew[:, 0] - data_vz_ew[:, 1], data_vz_ew[:, 0] + data_vz_ew[:, 1],alpha=0.2, color='green')

            plt.scatter(bin_cen, data_vz_ew_Tsup7[:, 0], label='z Tsup7', marker='.', color='purple')
            plt.fill_between(bin_cen, data_vz_ew_Tsup7[:, 0] - data_vz_ew_Tsup7[:, 1],data_vz_ew_Tsup7[:, 0] + data_vz_ew_Tsup7[:, 1], alpha=0.2, color='purple')

            plt.scatter(bin_cen, data_vz_mw[:, 0], label='z MW', marker='.', color='orange')
            plt.fill_between(bin_cen, data_vz_mw[:, 0] - data_vz_mw[:, 1], data_vz_mw[:, 0] + data_vz_mw[:, 1],alpha=0.2, color='orange')

            plt.title("1st order VSF, z sightline velocity comparisons")
            plt.ylim(-50, 6.2e2)
            plt.ylabel("\delta v^1(r) $[\mathrm{km\,s^{-1}}]$")

        if plot_type=="ew_comp":
            sub_matrix_size = 100

            max_dist = np.sqrt(2 * sub_matrix_size ** 2)

            bins = np.logspace(0, np.log10(max_dist), 101)
            bin_cen = 0.5 * (bins[1:] + bins[:-1])

            pxlvl = 16
            bin_cen *= (737441 / 2 ** pxlvl)

            plt.scatter(bin_cen, data_vx_ew[:,0], label='x', marker='.',color='blue')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vx_ew[:,0] - data_vx_ew[:,1], data_vx_ew[:,0] + data_vx_ew[:,1], alpha=0.2, color='blue')

            plt.scatter(bin_cen, data_vy_ew[:, 0], label='y', marker='.',color='red')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vy_ew[:, 0] - data_vy_ew[:, 1], data_vy_ew[:, 0] + data_vy_ew[:, 1],alpha=0.2, color='red')

            plt.scatter(bin_cen, data_vz_ew[:, 0], label='z', marker='.', color='green')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vz_ew[:, 0] - data_vz_ew[:, 1], data_vz_ew[:, 0] + data_vz_ew[:, 1],alpha=0.2, color='green')

            plt.title("1st order VSF, EW sightline velocity")
            plt.ylim(-50, 6.2e2)
            plt.ylabel("Velocity difference $[\mathrm{km\,s^{-1}}]$")

        if plot_type=="ew_comp_15_200":
            sub_matrix_size = 200

            max_dist = np.sqrt(2 * sub_matrix_size ** 2)

            bins = np.logspace(0, np.log10(max_dist), 101)
            bin_cen = 0.5 * (bins[1:] + bins[:-1])

            pxlvl = 15
            bin_cen *= (737441 / 2 ** pxlvl)

            plt.scatter(bin_cen, data_vx_ew_15[:,0], label='x', marker='.',color='blue')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vx_ew_15[:,0] - data_vx_ew_15[:,1], data_vx_ew_15[:,0] + data_vx_ew_15[:,1], alpha=0.2, color='blue')

            plt.scatter(bin_cen, data_vy_ew_15[:, 0], label='y', marker='.',color='red')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vy_ew_15[:, 0] - data_vy_ew_15[:, 1], data_vy_ew_15[:, 0] + data_vy_ew_15[:, 1],alpha=0.2, color='red')

            plt.scatter(bin_cen, data_vz_ew_15[:, 0], label='z', marker='.', color='green')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vz_ew_15[:, 0] - data_vz_ew_15[:, 1], data_vz_ew_15[:, 0] + data_vz_ew_15[:, 1],alpha=0.2, color='green')

            plt.title("1st order VSF, EW sightline velocity")
            plt.ylim(-50, 6.2e2)
            plt.ylabel("Velocity difference $[\mathrm{km\,s^{-1}}]$")

        if plot_type=="ew_comp_15_200_2":
            sub_matrix_size = 200

            max_dist = np.sqrt(2 * sub_matrix_size ** 2)

            bins = np.logspace(0, np.log10(max_dist), 101)
            bin_cen = 0.5 * (bins[1:] + bins[:-1])

            pxlvl = 15
            bin_cen *= (737441 / 2 ** pxlvl)

            plt.scatter(bin_cen, data_vx_ew_15_2[:,0], label='x', marker='.',color='blue')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vx_ew_15_2[:,0] - data_vx_ew_15_2[:,1], data_vx_ew_15_2[:,0] + data_vx_ew_15_2[:,1], alpha=0.2, color='blue')

            plt.scatter(bin_cen, data_vy_ew_15_2[:, 0], label='y', marker='.',color='red')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vy_ew_15_2[:, 0] - data_vy_ew_15_2[:, 1], data_vy_ew_15_2[:, 0] + data_vy_ew_15_2[:, 1],alpha=0.2, color='red')

            plt.scatter(bin_cen, data_vz_ew_15_2[:, 0], label='z', marker='.', color='green')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vz_ew_15_2[:, 0] - data_vz_ew_15_2[:, 1], data_vz_ew_15_2[:, 0] + data_vz_ew_15_2[:, 1],alpha=0.2, color='green')

            plt.title("2nd order VSF, EW sightline velocity")
            plt.ylim(-100, 2e5)
            plt.ylabel("Squared velocity difference $[\mathrm{km^2\,s^{-2}}]$")


        if plot_type=="ew_comp_15_222_1":
            sub_matrix_size = 222

            max_dist = np.sqrt(2 * sub_matrix_size ** 2)

            bins = np.logspace(0, np.log10(max_dist), 101)
            bin_cen = 0.5 * (bins[1:] + bins[:-1])

            pxlvl = 16
            bin_cen *= (737441 / 2 ** pxlvl)

            plt.scatter(bin_cen, data_vx_ew_15[:,0], label='x', marker='.',color='blue')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vx_ew_15[:,0] - data_vx_ew_15[:,1], data_vx_ew_15[:,0] + data_vx_ew_15[:,1], alpha=0.2, color='blue')

            plt.scatter(bin_cen, data_vy_ew_15[:, 0], label='y', marker='.',color='red')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vy_ew_15[:, 0] - data_vy_ew_15[:, 1], data_vy_ew_15[:, 0] + data_vy_ew_15[:, 1],alpha=0.2, color='red')

            plt.scatter(bin_cen, data_vz_ew_15[:, 0], label='z', marker='.', color='green')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vz_ew_15[:, 0] - data_vz_ew_15[:, 1], data_vz_ew_15[:, 0] + data_vz_ew_15[:, 1],alpha=0.2, color='green')

            plt.title("1st order VSF, EW sightline velocity")
            plt.ylim(-50, 6.2e2)
            plt.ylabel("Velocity difference $[\mathrm{km\,s^{-1}}]$")

        if plot_type=="mw_comp_15_222_1":
            sub_matrix_size = 222

            max_dist = np.sqrt(2 * sub_matrix_size ** 2)

            bins = np.logspace(0, np.log10(max_dist), 101)
            bin_cen = 0.5 * (bins[1:] + bins[:-1])

            pxlvl = 16
            bin_cen *= (737441 / 2 ** pxlvl)

            plt.scatter(bin_cen, data_vx_mw_15[:,0], label='x', marker='.',color='blue')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vx_mw_15[:,0] - data_vx_mw_15[:,1], data_vx_mw_15[:,0] + data_vx_mw_15[:,1], alpha=0.2, color='blue')

            plt.scatter(bin_cen, data_vy_mw_15[:, 0], label='y', marker='.',color='red')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vy_mw_15[:, 0] - data_vy_mw_15[:, 1], data_vy_mw_15[:, 0] + data_vy_mw_15[:, 1],alpha=0.2, color='red')

            plt.scatter(bin_cen, data_vz_mw_15[:, 0], label='z', marker='.', color='green')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            plt.fill_between(bin_cen, data_vz_mw_15[:, 0] - data_vz_mw_15[:, 1], data_vz_mw_15[:, 0] + data_vz_mw_15[:, 1],alpha=0.2, color='green')

            plt.title("1st order VSF, MW sightline velocity")
            plt.ylim(-50, 6.2e2)
            plt.ylabel("Velocity difference $[\mathrm{km\,s^{-1}}]$")

        if plot_type=="mw_vs_ew_comp_15_222_1":
            sub_matrix_size = 222

            max_dist = np.sqrt(2 * sub_matrix_size ** 2)

            bins = np.logspace(0, np.log10(max_dist), 101)
            bin_cen = 0.5 * (bins[1:] + bins[:-1])

            pxlvl = 16
            bin_cen *= (737441 / 2 ** pxlvl)

            plt.plot(bin_cen, data_vx_mw_15[:,0], label='x mw', marker='.',color='blue',ls='solid')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            #plt.fill_between(bin_cen, data_vx_mw_15[:,0] - data_vx_mw_15[:,1], data_vx_mw_15[:,0] + data_vx_mw_15[:,1], alpha=0.2, color='blue')

            plt.plot(bin_cen, data_vy_mw_15[:, 0], label='y mw', marker='.',color='red',ls='solid')
            #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            #plt.fill_between(bin_cen, data_vy_mw_15[:, 0] - data_vy_mw_15[:, 1], data_vy_mw_15[:, 0] + data_vy_mw_15[:, 1],alpha=0.2, color='red')

            plt.plot(bin_cen, data_vz_mw_15[:, 0], label='z mw', marker='.', color='green',ls='solid')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            #plt.fill_between(bin_cen, data_vz_mw_15[:, 0] - data_vz_mw_15[:, 1], data_vz_mw_15[:, 0] + data_vz_mw_15[:, 1],alpha=0.2, color='green')

            plt.plot(bin_cen, data_vx_ew_15[:, 0], label='x ew', marker='+', color='blue',ls='solid')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            # plt.fill_between(bin_cen, data_vx_ew_15[:, 0] - data_vx_ew_15[:, 1], data_vx_ew_15[:, 0] + data_vx_ew_15[:, 1], alpha=0.2, color='blue')

            plt.plot(bin_cen, data_vy_ew_15[:, 0], label='y ew', marker='+', color='red',ls='solid')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            # plt.fill_between(bin_cen, data_vy_ew_15[:, 0] - data_vy_ew_15[:, 1], data_vy_ew_15[:, 0] + data_vy_ew_15[:, 1], alpha=0.2, color='red')

            plt.plot(bin_cen, data_vz_ew_15[:, 0], label='z ew', marker='+', color='green',ls='solid')
            # plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
            # plt.fill_between(bin_cen, data_vz_ew_15[:, 0] - data_vz_ew_15[:, 1], data_vz_ew_15[:, 0] + data_vz_ew_15[:, 1], alpha=0.2, color='green')

            plt.title("1st order VSF, sightline velocity")
            plt.ylim(-50, 6.2e2)
            plt.ylabel("Velocity difference $[\mathrm{km\,s^{-1}}]$")






        plt.xlabel("Separation [kpc]")

        plt.xscale("log")
        # plt.yscale("log")


        plt.legend(loc='upper left')
        plt.show()

        sys.exit()

    #VSF_compare_plot()

    def VSF1_EW_vs_MW_plot():
        matrix_size = 222
        max_dist = np.sqrt(2 * matrix_size ** 2)
        bins = np.logspace(0, np.log10(max_dist), 101)
        bin_cen = 0.5 * (bins[1:] + bins[:-1])
        pxlvl = 15
        bin_cen *= (737441 / 2 ** pxlvl)

        #print('max dist',max_dist*(737441 / 2 ** pxlvl))
        #print("bins",bins*(737441 / 2 ** pxlvl))
        #print("bin_cen",bin_cen)
        #sys.exit()

        vx_ew = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vx_ew_lvl15.npy")
        vy_ew = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vy_ew_lvl15.npy")
        vz_ew = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vz_ew_lvl15.npy")
        vcen_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF1_vcen_ew_lvl15.npy")

        vx_mw = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vx_mw_lvl15.npy")
        vy_mw = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vy_mw_lvl15.npy")
        vz_mw = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vz_mw_lvl15.npy")
        vcen_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF1_vcen_mw_lvl15.npy")

        #print("bin_cen",bin_cen)

        #fitting range 1 [400,600]kpc : i=26 (103kpc), i=56 (579kpc)
        #fitting range 2 [600,4000]kpc : i=57 (613kpc), i=89 (3865kpc)

        print("extrem bins in fitting ranges : i=26 ",bin_cen[26],"i=56",bin_cen[56],"i=57",bin_cen[57],"i=89",bin_cen[89])
        #sys.exit()

        poptx1, pcovx1 = curve_fit(power_law, bin_cen[26:57], vx_ew[26:57,0]) #, p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vx in[100,600]: a",poptx1[0],"±",pcovx1[0,0],", slope:", poptx1[1],"±",pcovx1[1,1])
        poptx2, pcovx2 = curve_fit(power_law, bin_cen[57:90], vx_ew[57:90,0])#, p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vx in [600,4000]: a", poptx2[0], "±", pcovx2[0, 0], ", slope:", poptx2[1], "±", pcovx2[1, 1])

        popty1, pcovy1 = curve_fit(power_law, bin_cen[26:57], vy_ew[26:57,0]) #, p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vy in[100,600]: a",popty1[0],"±",pcovy1[0,0],", slope:", popty1[1],"±",pcovy1[1,1])
        popty2, pcovy2 = curve_fit(power_law, bin_cen[57:90], vy_ew[57:90,0])#, p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vy in [600,4000]: a", popty2[0], "±", pcovy2[0, 0], ", slope:", popty2[1], "±", pcovy2[1, 1])

        poptz1, pcovz1 = curve_fit(power_law, bin_cen[26:57], vz_ew[26:57,0]) #, p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vz in[100,600]: a",poptz1[0],"±",pcovz1[0,0],", slope:", poptz1[1],"±",pcovz1[1,1])
        poptz2, pcovz2 = curve_fit(power_law, bin_cen[57:90], vz_ew[57:90,0])#, p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vz in [600,4000]: a", poptz2[0], "±", pcovz2[0, 0], ", slope:", poptz2[1], "±", pcovz2[1, 1])

        poptcen1, pcovcen1 = curve_fit(power_law, bin_cen[26:57], vcen_ew[26:57,0]) #, p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vcen in[100,600]: a",poptcen1[0],"±",pcovcen1[0,0],", slope:", poptcen1[1],"±",pcovcen1[1,1])
        poptcen2, pcovcen2 = curve_fit(power_law, bin_cen[57:90], vcen_ew[57:90,0])#, p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vcen in [600,4000]: a", poptcen2[0], "±", pcovcen2[0, 0], ", slope:", poptcen2[1], "±", pcovcen2[1, 1])


        f,ax = plt.subplots(1,2,figsize=(12,6),tight_layout='True',gridspec_kw = {'wspace':0, 'hspace':0})

        ax[0].plot(bin_cen, vx_ew[:,0], label='x', marker='.',color='red',ls="dashed",ms=7,alpha=0.5)
        ax[0].fill_between(bin_cen, vx_ew[:,0] - vx_ew[:,1], vx_ew[:,0] + vx_ew[:,1], alpha=0.5, color='red')
        ax[0].plot(bin_cen, vy_ew[:,0], label='y', marker='.',color='blue',ls="dashed",ms=7,alpha=0.5)
        ax[0].fill_between(bin_cen, vy_ew[:,0] - vy_ew[:,1], vy_ew[:,0] + vy_ew[:,1], alpha=0.5, color='blue')
        ax[0].plot(bin_cen, vz_ew[:,0], label='z', marker='.',color='green',ls="dashed",ms=7,alpha=0.5)
        ax[0].fill_between(bin_cen, vz_ew[:,0] - vz_ew[:,1], vz_ew[:,0] + vz_ew[:,1], alpha=0.5, color='green')
        ax[0].plot(bin_cen, vcen_ew[:,0], label='cen', marker='.',color='pink',ls="dashed",ms=7,alpha=0.5)
        ax[0].fill_between(bin_cen, vcen_ew[:,0] - vcen_ew[:,1], vcen_ew[:,0] + vcen_ew[:,1], alpha=0.5, color='pink')
        #ax[0].axvline(x=100, color='grey', ls='dashed')
        #ax[0].axvline(x=4000, color='grey', ls='dashed')
        ax[0].axvline(x=600, color='black', ls='dotted',alpha=0.7)#,ymin=0.2,ymax=0.2)
        #ax[0].text(300,450,"Validity range",color="grey",size=14)
        ax[0].text(170,480,"Fitting range 1",color="black",size=12)
        ax[0].text(1100, 480, "Fitting range 2", color="black",size=12)

        plot_fit=0

        if plot_fit==1 :

            ax[0].plot(bin_cen[26:57],power_law(bin_cen[26:57],*poptx1),ls='solid',color="black",marker=None)
            ax[0].plot(bin_cen[57:89], power_law(bin_cen[57:89], *poptx2), ls='solid', color="black", marker=None)
            ax[0].plot(bin_cen[26:57],power_law(bin_cen[26:57],*popty1),ls='solid',color="black",marker=None)
            ax[0].plot(bin_cen[57:89], power_law(bin_cen[57:89], *popty2), ls='solid', color="black", marker=None)
            ax[0].plot(bin_cen[26:57],power_law(bin_cen[26:57],*poptz1),ls='solid',color="black",marker=None)
            ax[0].plot(bin_cen[57:89], power_law(bin_cen[57:89], *poptz2), ls='solid', color="black", marker=None)
            ax[0].plot(bin_cen[26:57],power_law(bin_cen[26:57],*poptcen1),ls='solid',color="black",marker=None)
            ax[0].plot(bin_cen[57:89], power_law(bin_cen[57:89], *poptcen2), ls='solid', color="black", marker=None)

        ax[0].set_title("1st order VSF, EW sightline velocity")
        ax[0].set_ylim(30, 5.1e2)
        ax[0].set_xlim(100,4000)
        ax[0].set_ylabel("$\delta v^1(r) \, [\mathrm{km\,s^{-1}}]$")
        ax[0].set_xlabel("Separation [kpc]")
        ax[0].set_xscale("log")
        #ax[0].set_yscale("log")
        #ax[0].legend(loc='lower right')

        poptx1, pcovx1 = curve_fit(power_law, bin_cen[26:57], vx_mw[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vx in[100,600]: a", poptx1[0], "±", pcovx1[0, 0], ", slope:", poptx1[1], "±", pcovx1[1, 1])
        poptx2, pcovx2 = curve_fit(power_law, bin_cen[57:90], vx_mw[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vx in [600,4000]: a", poptx2[0], "±", pcovx2[0, 0], ", slope:", poptx2[1], "±", pcovx2[1, 1])

        popty1, pcovy1 = curve_fit(power_law, bin_cen[26:57], vy_mw[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vy in[100,600]: a", popty1[0], "±", pcovy1[0, 0], ", slope:", popty1[1], "±", pcovy1[1, 1])
        popty2, pcovy2 = curve_fit(power_law, bin_cen[57:90], vy_mw[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vy in [600,4000]: a", popty2[0], "±", pcovy2[0, 0], ", slope:", popty2[1], "±", pcovy2[1, 1])

        poptz1, pcovz1 = curve_fit(power_law, bin_cen[26:57], vz_mw[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vz in[100,600]: a", poptz1[0], "±", pcovz1[0, 0], ", slope:", poptz1[1], "±", pcovz1[1, 1])
        poptz2, pcovz2 = curve_fit(power_law, bin_cen[57:90], vz_mw[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vz in [600,4000]: a", poptz2[0], "±", pcovz2[0, 0], ", slope:", poptz2[1], "±", pcovz2[1, 1])

        poptcen1, pcovcen1 = curve_fit(power_law, bin_cen[26:57], vcen_mw[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vcen in[100,600]: a", poptcen1[0], "±", pcovcen1[0, 0], ", slope:", poptcen1[1], "±", pcovcen1[1, 1])
        poptcen2, pcovcen2 = curve_fit(power_law, bin_cen[57:90], vcen_mw[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vcen in [600,4000]: a", poptcen2[0], "±", pcovcen2[0, 0], ", slope:", poptcen2[1], "±", pcovcen2[1, 1])

        ax[1].plot(bin_cen, vx_mw[:,0], label='$v_x$', marker='.',color='red',ls="dashed",ms=7,alpha=0.5)
        ax[1].fill_between(bin_cen, vx_mw[:,0] - vx_mw[:,1], vx_mw[:,0] + vx_mw[:,1], alpha=0.5, color='red')
        ax[1].plot(bin_cen, vy_mw[:,0], label='$v_y$', marker='.',color='blue',ls="dashed",ms=7,alpha=0.5)
        ax[1].fill_between(bin_cen, vy_mw[:,0] - vy_mw[:,1], vy_mw[:,0] + vy_mw[:,1], alpha=0.5, color='blue')
        ax[1].plot(bin_cen, vz_mw[:,0], label='$v_z$', marker='.',color='green',ls="dashed",ms=7,alpha=0.5)
        ax[1].fill_between(bin_cen, vz_mw[:,0] - vz_mw[:,1], vz_mw[:,0] + vz_mw[:,1], alpha=0.5, color='green')
        ax[1].plot(bin_cen, vcen_mw[:,0], label='$v_{cen}$', marker='.',color='pink',ls="dashed",ms=7,alpha=0.5)
        ax[1].fill_between(bin_cen, vcen_mw[:,0] - vcen_mw[:,1], vcen_mw[:,0] + vcen_mw[:,1], alpha=0.5, color='pink')
        ax[1].axvline(x=100, color='grey', ls='dashed')
        ax[1].axvline(x=4000, color='grey', ls='dashed')
        #ax[1].text(320,450,"Validity range",color="grey",size=14)
        #ax[1].text(170,430,"Fitting range 1",color="black",size=12)
        #ax[1].text(1100,430, "Fitting range 2", color="black",size=12)
        ax[1].axvline(x=600, color='black', ls='dotted', alpha=0.7)#,ymin=20/510,ymax=400/510)

        if plot_fit==1:
            ax[1].plot(bin_cen[26:57],power_law(bin_cen[26:57],*poptx1),ls='solid',color="black",marker=None)
            ax[1].plot(bin_cen[57:89], power_law(bin_cen[57:89], *poptx2), ls='solid', color="black", marker=None)
            ax[1].plot(bin_cen[26:57],power_law(bin_cen[26:57],*popty1),ls='solid',color="black",marker=None)
            ax[1].plot(bin_cen[57:89], power_law(bin_cen[57:89], *popty2), ls='solid', color="black", marker=None)
            ax[1].plot(bin_cen[26:57],power_law(bin_cen[26:57],*poptz1),ls='solid',color="black",marker=None)
            ax[1].plot(bin_cen[57:89], power_law(bin_cen[57:89], *poptz2), ls='solid', color="black", marker=None)
            ax[1].plot(bin_cen[26:57],power_law(bin_cen[26:57],*poptcen1),ls='solid',color="black",marker=None)
            ax[1].plot(bin_cen[57:89], power_law(bin_cen[57:89], *poptcen2), ls='solid', color="black", marker=None)

        ax[1].set_title("1st order VSF, MW sightline velocity")
        ax[1].set_ylim(30, 5.1e2)
        ax[1].set_xlim(100, 4000)
        ax[1].set_yticks([])
        ax[1].set_xlabel("Separation [kpc]")
        ax[1].set_xscale("log")
        ax[1].legend(loc="upper left")

        #f.subplots_adjust(wspace=0, hspace=0)
        plt.show()
        sys.exit()

    def VSF2_EW_vs_MW_plot():

        bins = np.logspace(0, np.log10(max_dist), 101)
        bin_cen = 0.5 * (bins[1:] + bins[:-1])
        pxlvl = 15
        bin_cen *= (737441 / 2 ** pxlvl)

        vx_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vx_ew_lvl15.npy")
        vy_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vy_ew_lvl15.npy")
        vz_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vz_ew_lvl15.npy")
        vcen_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vcen_ew_lvl15.npy")

        vx_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vx_mw_lvl15.npy")
        vy_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vy_mw_lvl15.npy")
        vz_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vz_mw_lvl15.npy")
        vcen_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vcen_mw_lvl15.npy")

        print("extrem bins in fitting ranges : i=26 ", bin_cen[26], "i=56", bin_cen[56], "i=57", bin_cen[57], "i=89", bin_cen[89])
        # sys.exit()

        poptx1, pcovx1 = curve_fit(power_law, bin_cen[26:57], vx_ew[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vx in[100,600]: a", poptx1[0], "±", pcovx1[0, 0], ", slope:", poptx1[1], "±", pcovx1[1, 1])
        poptx2, pcovx2 = curve_fit(power_law, bin_cen[57:90], vx_ew[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vx in [600,4000]: a", poptx2[0], "±", pcovx2[0, 0], ", slope:", poptx2[1], "±", pcovx2[1, 1])

        popty1, pcovy1 = curve_fit(power_law, bin_cen[26:57], vy_ew[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vy in[100,600]: a", popty1[0], "±", pcovy1[0, 0], ", slope:", popty1[1], "±", pcovy1[1, 1])
        popty2, pcovy2 = curve_fit(power_law, bin_cen[57:90], vy_ew[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vy in [600,4000]: a", popty2[0], "±", pcovy2[0, 0], ", slope:", popty2[1], "±", pcovy2[1, 1])

        poptz1, pcovz1 = curve_fit(power_law, bin_cen[26:57], vz_ew[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vz in[100,600]: a", poptz1[0], "±", pcovz1[0, 0], ", slope:", poptz1[1], "±", pcovz1[1, 1])
        poptz2, pcovz2 = curve_fit(power_law, bin_cen[57:90], vz_ew[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vz in [600,4000]: a", poptz2[0], "±", pcovz2[0, 0], ", slope:", poptz2[1], "±", pcovz2[1, 1])

        poptcen1, pcovcen1 = curve_fit(power_law, bin_cen[26:57], vcen_ew[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vcen in[100,600]: a", poptcen1[0], "±", pcovcen1[0, 0], ", slope:", poptcen1[1], "±", pcovcen1[1, 1])
        poptcen2, pcovcen2 = curve_fit(power_law, bin_cen[57:90], vcen_ew[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vcen in [600,4000]: a", poptcen2[0], "±", pcovcen2[0, 0], ", slope:", poptcen2[1], "±", pcovcen2[1, 1])

        f,ax = plt.subplots(1,2,figsize=(12,6),tight_layout='True',gridspec_kw = {'wspace':0, 'hspace':0})

        ax[0].plot(bin_cen, vx_ew[:,0], label='x', marker='.',color='red',ls="dashed",ms=7,alpha=0.5)
        ax[0].fill_between(bin_cen, vx_ew[:,0] - vx_ew[:,1], vx_ew[:,0] + vx_ew[:,1], alpha=0.5, color='red')
        ax[0].plot(bin_cen, vy_ew[:,0], label='y', marker='.',color='blue',ls="dashed",ms=7,alpha=0.5)
        ax[0].fill_between(bin_cen, vy_ew[:,0] - vy_ew[:,1], vy_ew[:,0] + vy_ew[:,1], alpha=0.5, color='blue')
        ax[0].plot(bin_cen, vz_ew[:,0], label='z', marker='.',color='green',ls="dashed",ms=7,alpha=0.5)
        ax[0].fill_between(bin_cen, vz_ew[:,0] - vz_ew[:,1], vz_ew[:,0] + vz_ew[:,1], alpha=0.5, color='green')
        ax[0].plot(bin_cen, vcen_ew[:,0], label='cen', marker='.',color='pink',ls="dashed",ms=7,alpha=0.5)
        ax[0].fill_between(bin_cen, vcen_ew[:,0] - vcen_ew[:,1], vcen_ew[:,0] + vcen_ew[:,1], alpha=0.5, color='pink')
        #ax[0].axvline(x=100, color='grey', ls='dashed')
        #ax[0].axvline(x=4000, color='grey', ls='dashed')

        ax[0].set_title("2nd order VSF, EW sightline velocity")
        ax[0].set_ylim(-100, 2.85e5)
        ax[0].set_xlim(100,4000)
        ax[0].set_ylabel("$\delta v^2(r) \, [\mathrm{km^2\,s^{-2}}]$")
        ax[0].set_xlabel("Separation [kpc]")
        ax[0].set_xscale("log")
        #ax[0].legend(loc='upper left')

        ax[0].axvline(x=600, color='black', ls='dotted', alpha=0.7)  # ,ymin=0.2,ymax=0.2)
        # ax[0].text(300,450,"Validity range",color="grey",size=14)
        ax[0].text(170, 2.7e5, "Fitting range 1", color="black", size=12)
        ax[0].text(1100, 2.7e5, "Fitting range 2", color="black", size=12)

        poptx1, pcovx1 = curve_fit(power_law, bin_cen[26:57], vx_mw[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vx in[100,600]: a", poptx1[0], "±", pcovx1[0, 0], ", slope:", poptx1[1], "±", pcovx1[1, 1])
        poptx2, pcovx2 = curve_fit(power_law, bin_cen[57:90], vx_mw[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vx in [600,4000]: a", poptx2[0], "±", pcovx2[0, 0], ", slope:", poptx2[1], "±", pcovx2[1, 1])

        popty1, pcovy1 = curve_fit(power_law, bin_cen[26:57], vy_mw[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vy in[100,600]: a", popty1[0], "±", pcovy1[0, 0], ", slope:", popty1[1], "±", pcovy1[1, 1])
        popty2, pcovy2 = curve_fit(power_law, bin_cen[57:90], vy_mw[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vy in [600,4000]: a", popty2[0], "±", pcovy2[0, 0], ", slope:", popty2[1], "±", pcovy2[1, 1])

        poptz1, pcovz1 = curve_fit(power_law, bin_cen[26:57], vz_mw[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vz in[100,600]: a", poptz1[0], "±", pcovz1[0, 0], ", slope:", poptz1[1], "±", pcovz1[1, 1])
        poptz2, pcovz2 = curve_fit(power_law, bin_cen[57:90], vz_mw[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vz in [600,4000]: a", poptz2[0], "±", pcovz2[0, 0], ", slope:", poptz2[1], "±", pcovz2[1, 1])

        poptcen1, pcovcen1 = curve_fit(power_law, bin_cen[26:57], vcen_mw[26:57, 0])  # , p0=[100, -3.5],bounds=([0, -10], [1e5, -2]))
        print("best fit vcen in[100,600]: a", poptcen1[0], "±", pcovcen1[0, 0], ", slope:", poptcen1[1], "±", pcovcen1[1, 1])
        poptcen2, pcovcen2 = curve_fit(power_law, bin_cen[57:90], vcen_mw[57:90, 0])  # , p0=[1, 0.33])#,bounds=([0, 0], [3, 10]))
        print("best fit vcen in [600,4000]: a", poptcen2[0], "±", pcovcen2[0, 0], ", slope:", poptcen2[1], "±", pcovcen2[1, 1])

        ax[1].plot(bin_cen, vx_mw[:,0], label='$v_x$', marker='.',color='red',ls="dashed",ms=7,alpha=0.5)
        ax[1].fill_between(bin_cen, vx_mw[:,0] - vx_mw[:,1], vx_mw[:,0] + vx_mw[:,1], alpha=0.5, color='red')
        ax[1].plot(bin_cen, vy_mw[:,0], label='$v_y$', marker='.',color='blue',ls="dashed",ms=7,alpha=0.5)
        ax[1].fill_between(bin_cen, vy_mw[:,0] - vy_mw[:,1], vy_mw[:,0] + vy_mw[:,1], alpha=0.5, color='blue')
        ax[1].plot(bin_cen, vz_mw[:,0], label='$v_z$', marker='.',color='green',ls="dashed",ms=7,alpha=0.5)
        ax[1].fill_between(bin_cen, vz_mw[:,0] - vz_mw[:,1], vz_mw[:,0] + vz_mw[:,1], alpha=0.5, color='green')
        ax[1].plot(bin_cen, vcen_mw[:,0], label='$v_{cen}$', marker='.',color='pink',ls="dashed",ms=7,alpha=0.5)
        ax[1].fill_between(bin_cen, vcen_mw[:,0] - vcen_mw[:,1], vcen_mw[:,0] + vcen_mw[:,1], alpha=0.5, color='pink')
        #ax[1].axvline(x=100, color='grey', ls='dashed')
        #ax[1].axvline(x=4000, color='grey', ls='dashed')

        ax[1].set_title("2nd order VSF, MW sightline velocity")
        #ax[1].set_ylim(-10, 5.1e2)
        ax[1].set_ylim(-100, 2.85e5)
        ax[1].set_yticks([])
        ax[1].set_xlabel("Separation [kpc]")
        ax[1].set_xscale("log")
        ax[1].legend(loc="upper left")
        ax[1].set_xlim(100, 4000)
        ax[1].axvline(x=600, color='black', ls='dotted', alpha=0.7)

        #f.subplots_adjust(wspace=0, hspace=0)
        plt.show()
        sys.exit()

    def VSF1_EW_vs_MW_per_comp_plot():
        bins = np.logspace(0, np.log10(max_dist), 101)
        bin_cen = 0.5 * (bins[1:] + bins[:-1])
        pxlvl = 15
        bin_cen *= (737441 / 2 ** pxlvl)

        vx_ew = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vx_ew_lvl15.npy")
        vy_ew = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vy_ew_lvl15.npy")
        vz_ew = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vz_ew_lvl15.npy")
        vcen_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF1_vcen_ew_lvl15.npy")

        vx_mw = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vx_mw_lvl15.npy")
        vy_mw = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vy_mw_lvl15.npy")
        vz_mw = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vz_mw_lvl15.npy")
        vcen_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF1_vcen_mw_lvl15.npy")

        f, ax = plt.subplots(1, 4, figsize=(20, 6), tight_layout='True', gridspec_kw={'wspace': 0, 'hspace': 0})

        ax[0].plot(bin_cen, vx_ew[:, 0], label='EW', marker='.', color='red', ls="dashed", ms=7, alpha=0.5)
        ax[0].fill_between(bin_cen, vx_ew[:, 0] - vx_ew[:, 1], vx_ew[:, 0] + vx_ew[:, 1], alpha=0.5, color='red')
        ax[1].plot(bin_cen, vy_ew[:, 0], label='EW', marker='.', color='blue', ls="dashed", ms=7, alpha=0.5)
        ax[1].fill_between(bin_cen, vy_ew[:, 0] - vy_ew[:, 1], vy_ew[:, 0] + vy_ew[:, 1], alpha=0.5, color='blue')
        ax[2].plot(bin_cen, vz_ew[:, 0], label='EW', marker='.', color='green', ls="dashed", ms=7, alpha=0.5)
        ax[2].fill_between(bin_cen, vz_ew[:, 0] - vz_ew[:, 1], vz_ew[:, 0] + vz_ew[:, 1], alpha=0.5, color='green')
        ax[3].plot(bin_cen, vcen_ew[:, 0], label='EW', marker='.', color='pink', ls="dashed", ms=7, alpha=0.5)
        ax[3].fill_between(bin_cen, vcen_ew[:, 0] - vcen_ew[:, 1], vcen_ew[:, 0] + vcen_ew[:, 1], alpha=0.5, color='pink')

        ax[0].plot(bin_cen, vx_mw[:, 0], label='MW', marker='.', color='grey', ls="dashed", ms=7, alpha=0.5)
        ax[0].fill_between(bin_cen, vx_mw[:, 0] - vx_mw[:, 1], vx_mw[:, 0] + vx_mw[:, 1], alpha=0.5, color='grey')
        ax[1].plot(bin_cen, vy_mw[:, 0], label='MW', marker='.', color='grey', ls="dashed", ms=7, alpha=0.5)
        ax[1].fill_between(bin_cen, vy_mw[:, 0] - vy_mw[:, 1], vy_mw[:, 0] + vy_mw[:, 1], alpha=0.5, color='grey')
        ax[2].plot(bin_cen, vz_mw[:, 0], label='MW', marker='.', color='grey', ls="dashed", ms=7, alpha=0.5)
        ax[2].fill_between(bin_cen, vz_mw[:, 0] - vz_mw[:, 1], vz_mw[:, 0] + vz_mw[:, 1], alpha=0.5, color='grey')
        ax[3].plot(bin_cen, vcen_mw[:, 0], label='MW', marker='.', color='grey', ls="dashed", ms=7, alpha=0.5)
        ax[3].fill_between(bin_cen, vcen_mw[:, 0] - vcen_mw[:, 1], vcen_mw[:, 0] + vcen_mw[:, 1], alpha=0.5, color='grey')

        ax[0].set_title("$v_x$")
        ax[0].set_ylim(30, 5.1e2)
        ax[0].set_xlim(100, 4000)
        ax[0].set_ylabel("$\delta v^1(r)$ $[\mathrm{km\,s^{-1}}]$")
        ax[0].set_xlabel("Separation [kpc]")
        ax[0].set_xscale("log")
        ax[0].legend(loc='upper left')
        ax[0].axvline(x=600, color='black', ls='dotted', alpha=0.7)

        ax[1].set_title("$v_y$")
        ax[1].set_ylim(30, 5.1e2)
        ax[1].set_xlim(100, 4000)
        ax[1].set_yticks([])
        ax[1].set_xlabel("Separation [kpc]")
        ax[1].set_xscale("log")
        ax[1].legend(loc="upper left")
        ax[1].axvline(x=600, color='black', ls='dotted', alpha=0.7)

        ax[2].set_title("$v_z$")
        ax[2].set_ylim(30, 5.1e2)
        ax[2].set_xlim(100, 4000)
        ax[2].set_yticks([])
        ax[2].set_xlabel("Separation [kpc]")
        ax[2].set_xscale("log")
        ax[2].legend(loc="upper left")
        ax[2].axvline(x=600, color='black', ls='dotted', alpha=0.7)

        ax[3].set_title("$v_{cen}$")
        ax[3].set_ylim(30, 5.1e2)
        ax[3].set_xlim(100, 4000)
        ax[3].set_yticks([])
        ax[3].set_xlabel("Separation [kpc]")
        ax[3].set_xscale("log")
        ax[3].legend(loc="upper left")
        ax[3].axvline(x=600, color='black', ls='dotted', alpha=0.7)

        # f.subplots_adjust(wspace=0, hspace=0)

        plt.suptitle("1st order VSF")
        plt.show()
        sys.exit()

    def VSF2_EW_vs_MW_per_comp_plot():
        bins = np.logspace(0, np.log10(max_dist), 101)
        bin_cen = 0.5 * (bins[1:] + bins[:-1])
        pxlvl = 15
        bin_cen *= (737441 / 2 ** pxlvl)

        vx_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vx_ew_lvl15.npy")
        vy_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vy_ew_lvl15.npy")
        vz_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vz_ew_lvl15.npy")
        vcen_ew = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vcen_ew_lvl15.npy")

        vx_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vx_mw_lvl15.npy")
        vy_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vy_mw_lvl15.npy")
        vz_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vz_mw_lvl15.npy")
        vcen_mw = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF2_vcen_mw_lvl15.npy")

        f, ax = plt.subplots(1, 4, figsize=(20, 6), tight_layout='True', gridspec_kw={'wspace': 0, 'hspace': 0})

        ax[0].plot(bin_cen, vx_ew[:, 0], label='EW', marker='.', color='red', ls="dashed", ms=7, alpha=0.5)
        ax[0].fill_between(bin_cen, vx_ew[:, 0] - vx_ew[:, 1], vx_ew[:, 0] + vx_ew[:, 1], alpha=0.5, color='red')
        ax[1].plot(bin_cen, vy_ew[:, 0], label='EW', marker='.', color='blue', ls="dashed", ms=7, alpha=0.5)
        ax[1].fill_between(bin_cen, vy_ew[:, 0] - vy_ew[:, 1], vy_ew[:, 0] + vy_ew[:, 1], alpha=0.5, color='blue')
        ax[2].plot(bin_cen, vz_ew[:, 0], label='EW', marker='.', color='green', ls="dashed", ms=7, alpha=0.5)
        ax[2].fill_between(bin_cen, vz_ew[:, 0] - vz_ew[:, 1], vz_ew[:, 0] + vz_ew[:, 1], alpha=0.5, color='green')
        ax[3].plot(bin_cen, vcen_ew[:, 0], label='EW', marker='.', color='pink', ls="dashed", ms=7, alpha=0.5)
        ax[3].fill_between(bin_cen, vcen_ew[:, 0] - vcen_ew[:, 1], vcen_ew[:, 0] + vcen_ew[:, 1], alpha=0.5, color='pink')

        ax[0].plot(bin_cen, vx_mw[:, 0], label='MW', marker='.', color='grey', ls="dashed", ms=7, alpha=0.5)
        ax[0].fill_between(bin_cen, vx_mw[:, 0] - vx_mw[:, 1], vx_mw[:, 0] + vx_mw[:, 1], alpha=0.5, color='grey')
        ax[1].plot(bin_cen, vy_mw[:, 0], label='MW', marker='.', color='grey', ls="dashed", ms=7, alpha=0.5)
        ax[1].fill_between(bin_cen, vy_mw[:, 0] - vy_mw[:, 1], vy_mw[:, 0] + vy_mw[:, 1], alpha=0.5, color='grey')
        ax[2].plot(bin_cen, vz_mw[:, 0], label='MW', marker='.', color='grey', ls="dashed", ms=7, alpha=0.5)
        ax[2].fill_between(bin_cen, vz_mw[:, 0] - vz_mw[:, 1], vz_mw[:, 0] + vz_mw[:, 1], alpha=0.5, color='grey')
        ax[3].plot(bin_cen, vcen_mw[:, 0], label='MW', marker='.', color='grey', ls="dashed", ms=7, alpha=0.5)
        ax[3].fill_between(bin_cen, vcen_mw[:, 0] - vcen_mw[:, 1], vcen_mw[:, 0] + vcen_mw[:, 1], alpha=0.5, color='grey')

        ax[0].set_title("$v_x$")
        ax[0].set_ylim(-100, 2.85e5)
        ax[0].set_xlim(100,4000)
        ax[0].set_ylabel("$\delta v^2(r)$ $[\mathrm{km^2\,s^{-2}}]$")
        ax[0].set_xlabel("Separation [kpc]")
        ax[0].set_xscale("log")
        ax[0].legend(loc='upper left')
        ax[0].axvline(x=600, color='black', ls='dotted', alpha=0.7)

        ax[1].set_title("$v_y$")
        ax[1].set_ylim(-100, 2.85e5)
        ax[1].set_xlim(100,4000)
        ax[1].set_yticks([])
        ax[1].set_xlabel("Separation [kpc]")
        ax[1].set_xscale("log")
        ax[1].legend(loc="upper left")
        ax[1].axvline(x=600, color='black', ls='dotted', alpha=0.7)

        ax[2].set_title("$v_z$")
        ax[2].set_ylim(-100, 2.85e5)
        ax[2].set_xlim(100,4000)
        ax[2].set_yticks([])
        ax[2].set_xlabel("Separation [kpc]")
        ax[2].set_xscale("log")
        ax[2].legend(loc="upper left")
        ax[2].axvline(x=600, color='black', ls='dotted', alpha=0.7)

        ax[3].set_title("$v_{cen}$")
        ax[3].set_ylim(-100, 2.85e5)
        ax[3].set_xlim(100,4000)
        ax[3].set_yticks([])
        ax[3].set_xlabel("Separation [kpc]")
        ax[3].set_xscale("log")
        ax[3].legend(loc="upper left")
        ax[3].axvline(x=600, color='black', ls='dotted', alpha=0.7)

        # f.subplots_adjust(wspace=0, hspace=0)

        plt.suptitle("2nd order VSF")
        plt.show()
        sys.exit()

    def VSF1_lvl15_vs_16_comp_plot():

        sub_matrix_size = 222
        max_dist = np.sqrt(2 * sub_matrix_size ** 2)
        bins = np.logspace(0, np.log10(max_dist), 101)
        bin_cen = 0.5 * (bins[1:] + bins[:-1])
        pxlvl = 15
        bin_cen *= (737441 / 2 ** pxlvl)

        vx_mw_15 = np.load("./vel_Virgo_core_project/VSF_data/dec24_run/VSF1_vx_mw_lvl15.npy")
        vx_mw_16 = np.load("./vel_Virgo_core_project/VSF_data/jan25_run/VSF1_vx_mw_lvl16.npy")

        f,ax = plt.subplots(2,1,figsize=(8, 8), constrained_layout='True',gridspec_kw={'height_ratios': [3, 1],"hspace":0})

        plt.sca(ax[0])

        plt.plot(bin_cen, vx_mw_15[:, 0], label='$222^2$', marker='.', color='red', ls="dashed", ms=7, alpha=0.6)
        plt.fill_between(bin_cen, vx_mw_15[:, 0] - vx_mw_15[:, 1], vx_mw_15[:, 0] + vx_mw_15[:, 1], alpha=0.6, color='red')

        sub_matrix_size = 444
        max_dist = np.sqrt(2 * sub_matrix_size ** 2)
        bins = np.logspace(0, np.log10(max_dist), 101)
        bin_cen = 0.5 * (bins[1:] + bins[:-1])
        pxlvl = 16
        bin_cen *= (737441 / 2 ** pxlvl)

        plt.plot(bin_cen, vx_mw_16[:, 0], label='$444^2$', marker='.', color='grey', ls="dashed", ms=7, alpha=0.6)
        plt.fill_between(bin_cen, vx_mw_16[:, 0] - vx_mw_16[:, 1], vx_mw_16[:, 0] + vx_mw_16[:, 1], alpha=0.6, color='grey')


        plt.title("Comparison of VSF computed from 222² and 444² pixel maps")
        plt.ylim(30, 5.1e2)
        plt.xlim(100, 4000)
        plt.ylabel("$\delta v^1(r)$ $[\mathrm{km\,s^{-1}}]$")
        #plt.xlabel("Separation [kpc]")
        plt.xscale("log")
        plt.legend(loc='upper left')
        plt.xticks([])
        ax[0].xaxis.set_visible(False)

        plt.sca(ax[1])

        plt.plot(bin_cen, (vx_mw_16[:, 0]-vx_mw_15[:, 0])/vx_mw_15[:, 0], label='$222^2$', marker='.', color='red', ls="dashed", ms=7, alpha=1)
        #plt.ylabel(r"$\frac{222^2-444^2}{222^2}$")
        plt.ylabel('Relative difference')
        plt.xlabel("Separation [kpc]")
        plt.xscale('log')
        #plt.yscale('log')
        plt.xlim(100, 4000)
        print("lvl 15",vx_mw_15[:, 0])
        print("lvl 16", vx_mw_16[:, 0])
        print("relative difference",(vx_mw_16[:, 0]-vx_mw_15[:, 0])/vx_mw_15[:, 0])
        # f.subplots_adjust(wspace=0, hspace=0)

        #plt.suptitle("1st order VSF")
        plt.show()
        sys.exit()


    #VSF2_EW_vs_MW_plot()

    #VSF2_EW_vs_MW_per_comp_plot()

    #VSF1_lvl15_vs_16_comp_plot()

    #speed_comparison_plot()

    nb_val_per_bin_plot()

    # Calcul des matrices d et v

    def test_digitize():
        rows = 3
        cols = 3
        x = np.array([np.arange(0, cols) for i in range(cols)])
        y = np.array([[j for i in range(cols)] for j in range(cols)])
        x = x.reshape(-1)
        y = y.reshape(-1)
        bins=[0,1.1,2]

        print("x",x)
        print("y",y)

        n_pairs = rows ** 2 * (rows ** 2 - 1) * 0.5
        print("n_pairs",n_pairs)
        dist_large = np.zeros(int(n_pairs))
        diff_large = np.zeros(int(n_pairs))
        mem_size_dist = sys.getsizeof(dist_large)
        mem_size_diff = sys.getsizeof(diff_large)
        print("mem_size_dist", mem_size_dist, 'mem_size_diff', mem_size_diff)
        # sys.exit()
        # print("results",results)
        # results[:].append(0)
        # print("results",results)
        n = 0
        # sum_v_dict = {}
        # nb_dict = {}
        # index = 0
        start_i_loop = time.time()
        for i in range(len(x) - 1):
            # for i in range(100):

            # start=time.time()
            # dist=np.sqrt((x[i] - x[i+1::]) ** 2 + (y[i] - y[i+1::]) ** 2)
            # diff=np.abs(matrix_list[i] - matrix_list[i+1::])

            # print("time",time.time()-start)

            start = time.time()

            dist = np.zeros(len(x) - i - 1)
            diff = np.zeros(len(x) - i - 1)

            # print("i",i)
            # dist=0
            # diff=0
            # index=np.zeros(1)

            j_loop_jit(x, y, matrix_list, i, dist, diff, order)

            dist_large[n:n + len(dist)] = dist
            diff_large[n:n + len(diff)] = diff
            n += len(dist)

        index = np.digitize(dist_large, bins) - 1


        print("dist",dist_large)
        print("index",index)

        sys.exit()

    #test_digitize()

    nb_val_per_bin_plot()
    start_time = time.time()
    mean,std = VSF_opti(x, y, matrix_list,mean,std,order,bin_cen)
    #print("sum_v:", sum_v,"nb:", nb,"sum tot",np.sum(sum_v),"nb tot",np.sum(nb))
    #print("results",results)
    print("mean",mean,"std",std)
    end_time = time.time()
    execution_time = end_time - start_time
    print(f"\nTemps d'exécution pour les matrices d et v : {execution_time:.2f} secondes")

    pxlvl = 15
    bin_cen *= (737441 / 2 ** pxlvl)

    data_save=np.zeros((len(bin_cen),2))
    data_save[:,0]=mean
    data_save[:,1]=std

    np.save(savefile,data_save)
    print("data saved")

    plt.scatter(bin_cen, mean, label='mean',marker='.')
    #plt.errorbar(bin_cen, mean, yerr=std, fmt='o', label='std')
    plt.fill_between(bin_cen, mean-std, mean+std, alpha=0.5, label='std',color='blue')
    plt.xlabel("Separation [kpc]")
    plt.ylabel("Velocity difference $[\mathrm{km\,s^{-1}}]$")
    plt.xscale("log")
    #plt.yscale("log")
    plt.ylim(-2, 4e2)
    plt.title("1st order VSF, MW velocity along cen sightline, sub matrix= 200*200, lvl 15")
    plt.show()


    sys.exit()



    print('old function')

    start_time = time.time()
    unique_d, sum_v, nb = fonction(x, y, matrix)
    #print("sum_v:", sum_v,"nb:", nb,"sum tot",np.sum(sum_v),"nb tot",np.sum(nb))
    print("nb tot",np.sum(nb))
    end_time = time.time()
    execution_time = end_time - start_time
    print(f"\nTemps d'exécution pour les matrices d et v : {execution_time:.2f} secondes")

    # Affichage des résultats

def v_los_PDF_from_maps():

    vz_list_5Mpc = np.load("./vel_Virgo_core_project/v_list_pdf/vz_list_from_5Mpc2_map.npy")
    vz_list_1Mpc = np.load("./vel_Virgo_core_project/v_list_pdf/vz_list_from_1Mpc2_map.npy")
    vz_list_100kpc = np.load("./vel_Virgo_core_project/v_list_pdf/vz_list_from_100kpc2_map.npy")
    vz_Trange_list_100kpc = np.load("./vel_Virgo_core_project/v_list_pdf/vz_Trange_list_from_100kpc2_map.npy")

    vx_list_5Mpc = np.load("./vel_Virgo_core_project/v_list_pdf/vx_list_from_5Mpc2_map.npy")
    vx_list_1Mpc = np.load("./vel_Virgo_core_project/v_list_pdf/vx_list_from_1Mpc2_map.npy")
    vx_list_100kpc = np.load("./vel_Virgo_core_project/v_list_pdf/vx_list_from_100kpc2_map.npy")
    vx_Trange_list_100kpc = np.load("./vel_Virgo_core_project/v_list_pdf/vx_Trange_list_from_100kpc2_map.npy")


    vy_list_5Mpc = np.load("./vel_Virgo_core_project/v_list_pdf/vy_list_from_5Mpc2_map.npy")
    vy_list_1Mpc = np.load("./vel_Virgo_core_project/v_list_pdf/vy_list_from_1Mpc2_map.npy")
    vy_list_100kpc = np.load("./vel_Virgo_core_project/v_list_pdf/vy_list_from_100kpc2_map.npy")
    vy_Trange_list_100kpc = np.load("./vel_Virgo_core_project/v_list_pdf/vy_Trange_list_from_100kpc2_map.npy")

    #plt.hist(map.flatten(), bins=50, alpha=0.6, color='blue', label='100kpc**2, mw velocity')

    # plt.hist(vy_list_100kpc, bins=50, alpha=0.6, color='blue', label='vy, 100kpc**2')
    #plt.hist(vz_list_100kpc, bins=50, alpha=0.6, color='green', label='vz, 100kpc**2, ew velocity')
    # plt.hist(vx_list_100kpc, bins=50, alpha=0.6, color='red', label='vx, 100kpc**2')

    # plt.hist(vy_Trange_list_100kpc, bins=50, alpha=0.6, color='blue', label='100kpc**2, XRISM T range')
    #plt.hist(vz_Trange_list_100kpc, bins=50, alpha=0.6, color='orange', label='100kpc**2,ew velovity, XRISM T range')
    # plt.hist(vx_Trange_list_100kpc, bins=50, alpha=0.6, color='red', label='100kpc**2, XRISM T range')
    f, axs = plt.subplots(3, 4, figsize=(20, 8), constrained_layout=True)




    axs[0,0].hist(vx_list_5Mpc, bins=50, alpha=0.6, color='red', label='vx, $5Mpc^2$, ew velocity',density=True)
    #axs[0,0].yscale('log')
    axs[0,0].set_xlim(-1900, 1900)
    #axs[0,0].set_ylim(0, 15000)
    #axs[0,0].legend(fontsize=10)
    axs[0,0].set_title("x projection")
    #axs[0,0].set_xlabel("Vx [km/s]")
    axs[0,0].set_ylabel("PDF")
    axs[0,0].set_xticks([])

    axs[0,1].hist(vy_list_5Mpc, bins=50, alpha=0.6, color='blue', label='y',density=True)
    #xs[0,1].yscale('log')
    axs[0,1].set_xlim(-1900, 1900)
    #axs[0,1].set_ylim(0, 15000)
    #axs[0,1].legend(fontsize=10)
    axs[0,1].set_title("y projection")
    axs[0,1].set_yticks([])
    #axs[0,1].set_xlabel("Vy [km/s]")
    axs[0,1].set_xticks([])

    axs[0,2].hist(vz_list_5Mpc, bins=50, alpha=0.6, color='green', label='z',density=True)
    #axs[0,2].yscale('log')
    axs[0,2].set_xlim(-1900, 1900)
    #axs[0,2].set_ylim(0, 15000)
    #axs[0,2].legend(fontsize=10)
    axs[0,2].set_title("z projection")
    #axs[0,2].set_xlabel("Vz [km/s]")
    axs[0,2].set_yticks([])
    axs[0,2].set_xticks([])



    axs[0,3].hist(vx_list_5Mpc, bins=50, alpha=0.6, color='red', label='x',density=True)
    axs[0,3].hist(vy_list_5Mpc, bins=50, alpha=0.6, color='blue', label='y',density=True)
    axs[0,3].hist(vz_list_5Mpc, bins=50, alpha=0.6, color='green', label='z',density=True)
    axs[0,3].set_xlim(-1900, 1900)
    #axs[0,3].set_ylim(0, 15000)
    axs[0,3].set_yticks([])
    axs[0,3].set_xticks([])
    axs[0,3].legend(fontsize=10)




    axs[1,0].hist(vx_list_1Mpc, bins=50, alpha=0.6, color='red', label='vx, $5Mpc^2$, ew velocity',density=True)
    #axs[1,0].yscale('log')
    axs[1,0].set_xlim(-1900, 1900)
    #axs[1,0].set_ylim(0, 700)
    #axs[1,0].legend(fontsize=10)
    #axs[1,0].set_title("x projection")
    #axs[1,0].set_xlabel("Vx [km/s]")
    axs[1,0].set_ylabel("PDF")
    axs[1,0].set_xticks([])

    axs[1,1].hist(vy_list_1Mpc, bins=50, alpha=0.6, color='blue', label='y',density=True)
    #xs[1,1].yscale('log')
    axs[1,1].set_xlim(-1900, 1900)
    #axs[1,1].set_ylim(0, 700)
    #axs[1,1].legend(fontsize=10)
    #axs[1,1].set_title("y projection")
    axs[1,1].set_yticks([])
    #axs[1,1].set_xlabel("Vy [km/s]")
    axs[1, 1].set_xticks([])

    axs[1,2].hist(vz_list_1Mpc, bins=50, alpha=0.6, color='green', label='z',density=True)
    #axs[1,2].yscale('log')
    axs[1,2].set_xlim(-1900, 1900)
    #axs[1,2].set_ylim(0, 700)
    #axs[1,2].legend(fontsize=10)
    #axs[1,2].set_title("z projection")
    #axs[1,2].set_xlabel("Vz [km/s]")
    axs[1,2].set_yticks([])
    axs[1,2].set_xticks([])



    axs[1,3].hist(vx_list_1Mpc, bins=50, alpha=0.6, color='red', label='x',density=True)
    axs[1,3].hist(vy_list_1Mpc, bins=50, alpha=0.6, color='blue', label='y',density=True)
    axs[1,3].hist(vz_list_1Mpc, bins=50, alpha=0.6, color='green', label='z',density=True)
    axs[1,3].set_xlim(-1900, 1900)
    #axs[1,3].set_ylim(0, 700)
    axs[1,3].set_yticks([])
    axs[1,3].legend(fontsize=10)

    axs[2, 0].hist(vx_list_5Mpc, bins=50, alpha=0.6, color='red', label='$5Mpc^2$',density=True)
    axs[2, 0].hist(vx_list_1Mpc, bins=50, alpha=0.6, color='darkred', label='$1Mpc^2$',density=True)
    # axs[2,0].yscale('log')
    axs[2, 0].set_xlim(-1900, 1900)
    #axs[2, 0].set_ylim(0, 700)
    # axs[2,0].legend(fontsize=10)
    # axs[2,0].set_title("x projection")
    axs[2, 0].set_xlabel("Vx [km/s]")
    axs[2, 0].set_ylabel("PDF")
    axs[2, 0].legend(fontsize=10)
    #axs[2, 0].set_yscale('log')

    axs[2, 1].hist(vy_list_5Mpc, bins=50, alpha=0.6, color='blue', label='$5Mpc^2$',density=True)
    axs[2, 1].hist(vy_list_1Mpc, bins=50, alpha=0.6, color='darkblue', label='$1Mpc^2$',density=True)
    # xs[2,1].yscale('log')
    axs[2, 1].set_xlim(-1900, 1900)
    #axs[2, 1].set_ylim(0, 700)
    # axs[2,1].legend(fontsize=10)
    # axs[2,1].set_title("y projection")
    axs[2, 1].set_yticks([])
    axs[2, 1].set_xlabel("Vy [km/s]")
    axs[2, 1].legend(fontsize=10)
    #axs[2, 1].set_yscale('log')

    axs[2, 2].hist(vz_list_5Mpc, bins=50, alpha=0.6, color='green', label='$5Mpc^2$',density=True)
    axs[2, 2].hist(vz_list_1Mpc, bins=50, alpha=0.6, color='darkgreen', label='$1Mpc^2$',density=True)
    # axs[2,2].yscale('log')
    axs[2, 2].set_xlim(-1900, 1900)
    #axs[2, 2].set_ylim(0, 700)
    # axs[2,2].legend(fontsize=10)
    # axs[2,2].set_title("z projection")
    axs[2, 2].set_xlabel("Vz [km/s]")
    axs[2, 2].set_yticks([])
    axs[2, 2].legend(fontsize=10)
    #axs[2,2].set_yscale('log')


    #axs[3].yscale('log')

    # plt.hist(v_Trange_list_100kpc, bins=50, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
    #plt.grid(b=None)
    plt.legend(fontsize=10)
    #plt.ylabel("PDF")
    plt.xlabel("V [km/s]")

    #plt.yscale('log')
    # plt.title("Vz distribution on ew sightline velocity along z axis")
    plt.suptitle("EW velocity distribution along x,y and z sightlines, 5 and 1Mpc**2 maps")
    # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

    plt.show()

    sys.exit()

def PDF_3D(file):
    print('hydro')
    print(file)
    h = FortranFile(file, 'r')

    ncell = h.read_ints()
    print("ncell", ncell)

    n_e = []
    n_e = h.read_reals()

    print("t")
    t = []
    t = h.read_reals()

    print("p")
    p = []
    p = h.read_reals()

    print("x")
    x = []
    x = h.read_reals()

    print('y')
    y = []
    y = h.read_reals()

    print("z")
    z = []
    z = h.read_reals()

    print("vx")
    vx = []
    vx = h.read_reals()

    print("vy")
    vy = []
    vy = h.read_reals()

    print("vz")
    vz = []
    vz = h.read_reals()

    m = []
    m = h.read_reals()

    vx7= vx[t>1e7]
    vy7= vy[t>1e7]
    vz7= vz[t>1e7]
    x7 = x[t>1e7]
    y7 = y[t>1e7]
    z7 = z[t>1e7]
    m7 = m[t>1e7]

    def vel_comp_3D_hist(x, y, z, vx, vy, vz,m):

        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        # print("x_cen", x_cen, "y_cen", y_cen, "z_cen", z_cen)

        r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)

        vx_virgo = -509.1301
        vy_virgo = 228.9488
        vz_virgo = -131.9249

        vz -= vz_virgo
        vy -= vy_virgo
        vx -= vx_virgo

        def stats_3D_vnorm(vx,vy,vz,r,m):
            #vxm_vir = np.mean(vx[r < 2147])
            #vym_vir = np.mean(vy[r < 2147])
            #vzm_vir = np.mean(vz[r < 2147])
            #vm_vir = np.mean([vxm_vir,vym_vir,vzm_vir])
            #v=np.sqrt(vx**2+vy**2+vz**2)
            #print("vm vir",vxm_vir,vym_vir,vzm_vir,vm_vir)
            #print('test v vir',np.mean(v[r<2147]))
            #sys.exit()

            #vxm_500=np.mean(vx[r<1087])
            #vym_500=np.mean(vy[r<1087])
            #vzm_500=np.mean(vz[r<1087])
            #vm_500=np.sqrt(vxm_500**2+vym_500**2+vzm_500**2)
            #print("vm 500", vxm_500, vym_500, vzm_500, vm_500)
            #print('test v 500', np.mean(v[r < 1087]))

            #vxm_2500 = np.mean(vx[r < 515])
            #vym_2500 = np.mean(vy[r < 515])
            #vzm_2500 = np.mean(vz[r < 515])
            #vm_2500 = np.sqrt(vxm_2500 ** 2 + vym_2500 ** 2 + vzm_2500 ** 2)
            #print("vm 2500", vxm_2500, vym_2500, vzm_2500, vm_2500)
            #print('test v 2500', np.mean(v[r < 515]))

            #vxmed_vir = np.median(vx[r < 2147])
            #vymed_vir = np.median(vy[r < 2147])
            #vzmed_vir = np.median(vz[r < 2147])
            #vmed_vir = np.sqrt(vxmed_vir ** 2 + vymed_vir ** 2 + vzmed_vir ** 2)

            #vxmed_500 = np.median(vx[r < 1087])
            #vymed_500 = np.median(vy[r < 1087])
            #vzmed_500 = np.median(vz[r < 1087])
            #vmed_500 = np.sqrt(vxmed_500 ** 2 + vymed_500 ** 2 + vzmed_500 ** 2)

            #vxmed_2500 = np.median(vx[r < 515])
            #vymed_2500 = np.median(vy[r < 515])
            #vzmed_2500 = np.median(vz[r < 515])
            #vmed_2500 = np.sqrt(vxmed_2500 ** 2 + vymed_2500 ** 2 + vzmed_2500 ** 2)

            #v=np.sqrt(vx**2+vy**2+vz**2)
            #v_rvir=v[r<2147]
            #v_r500=v[r<1087]
            #v_r2500=v[r<515]
            print("len r",len(r),'len vx',len(vx))

            rad=[2147,1087,515]
            stat_matrix=np.zeros(15)
            stat_matrix_std = np.zeros(15)
            vxa=vx
            vya=vy
            vza=vz
            ma=m
            j=0

            print('len vx no cut:',len(vx))

            for i in rad:
                print("rad",i)

                #print("vx",vx)

                vx = vxa[r < i]
                vy = vya[r < i]
                vz = vza[r < i]
                m = ma[r < i]

                print('len vx ',i,' cut:', len(vx))

                w=1

                if w==0:

                    vmed = np.mean([np.median(vx),np.median(vy),np.median(vz)])
                    vm = np.mean([np.mean(vx), np.mean(vy), np.mean(vz)])
                    vs = np.mean([np.std(vx), np.std(vy), np.std(vz)])
                    vsk = np.mean([skew(vx),skew(vy),skew(vz)])
                    vk = np.mean([kurtosis(vx),kurtosis(vy),kurtosis(vz)])

                    stat_matrix[j:j+5] = [vmed, vm, vs, vsk, vk]

                    vmed = np.std([np.median(vx), np.median(vy), np.median(vz)])
                    vm = np.std([np.mean(vx), np.mean(vy), np.mean(vz)])
                    vs = np.std([np.std(vx), np.std(vy), np.std(vz)])
                    vsk = np.std([skew(vx), skew(vy), skew(vz)])
                    vk = np.std([kurtosis(vx), kurtosis(vy), kurtosis(vz)])

                    stat_matrix_std[j:j + 5] = [vmed, vm, vs, vsk, vk]

                else:
                    mx = np.average(vx, weights=m)
                    my = np.average(vy, weights=m)
                    mz = np.average(vz, weights=m)
                    stdx=np.sqrt(np.average((vx-mx)**2,weights=m))
                    stdy=np.sqrt(np.average((vy-my)**2,weights=m))
                    stdz=np.sqrt(np.average((vz-mz)**2,weights=m))

                    print("median vx",np.median(vx),"vy",np.median(vy),"vz",np.median(vz))
                    print("mean vx ",mx,"vy",my,"vz",mz)
                    print("std vx ", stdx, "vy", stdy, "vz", stdz)
                    print("skew vx ",np.average(((vx-mx)/stdx)**3,weights=m),"vy",np.average(((vy-my)/stdy)**3,weights=m),"vz",np.average(((vz-mz)/stdz)**3,weights=m))
                    print("kurtosis vx",np.average(((vx-mx)/stdx)**4,weights=m)-3.0,"vy",np.average(((vy-my)/stdy)**4,weights=m)-3.0,"vz",np.average(((vz-mz)/stdz)**4,weights=m)-3.0)
                    #print("stdx 1",stdx)

                    #square=(vx-mx)**2
                    #test=np.sqrt(np.average(square,weights=m))

                    #print("stdx 2",test)
                    #sys.exit()


                    vmed = np.mean([np.median(vx), np.median(vy), np.median(vz)])
                    vm = np.mean([mx,my,mz])
                    vs = np.mean([stdx,stdy,stdz])
                    vsk = np.mean([np.average(((vx-mx)/stdx)**3,weights=m),np.average(((vy-my)/stdy)**3,weights=m),np.average(((vz-mz)/stdz)**3,weights=m)])
                    vk = np.mean([np.average(((vx-mx)/stdx)**4,weights=m)-3.0, np.average(((vy-my)/stdy)**4,weights=m)-3, np.average(((vz-mz)/stdz)**4,weights=m)-3])

                    stat_matrix[j:j + 5] = [vmed, vm, vs, vsk, vk]

                    vmed = np.std([np.median(vx), np.median(vy), np.median(vz)])
                    vm = np.std([mx,my,mz])
                    vs = np.std([stdx,stdy,stdz])
                    vsk = np.std([np.average(((vx-mx)/stdx)**3,weights=m),np.average(((vy-my)/stdy)**3,weights=m),np.average(((vz-mz)/stdz)**3,weights=m)])
                    vk = np.std([np.average(((vx-mx)/stdx)**4,weights=m)-3.0, np.average(((vy-my)/stdy)**4,weights=m)-3, np.average(((vz-mz)/stdz)**4,weights=m)-3])

                    stat_matrix_std[j:j + 5] = [vmed, vm, vs, vsk, vk]

                j+=5


            #print("stat matrix ",stat_matrix)
            #stat_matrix[0:5]=[vmed_vir,vm_vir,np.std(v_rvir),skew(v_rvir),kurtosis(v_rvir)]
            #stat_matrix[5:10] = [vmed_500, vm_500, np.std(v_r500), skew(v_r500), kurtosis(v_r500)]
            #stat_matrix[10:15] = [vmed_2500, vm_2500, np.std(v_r2500), skew(v_r2500), kurtosis(v_r2500)]
            #np.save("stats_3D_pdf_vnorm_mw.npy",stat_matrix)
            #np.save("stats_3D_pdf_vstd_mw.npy", stat_matrix_std)
            print("matrix saved")
            sys.exit()
        # plt.hist(vz[r<2500],bins=100)
        # plt.show()
        # sys.exit()

        stats_3D_vnorm(vx,vy,vz,r,m)
        def gauss(x, A, mu, sigma):
            return A * norm.pdf(x, mu, sigma)

        def gaussian_fit(data, count, bins):

            # Bin centers for fitting
            bin_centers = (bins[:-1] + bins[1:]) / 2

            # Define Gaussian function

            model = GaussianModel()

            params = model.make_params(amplitude=1, center=np.mean(data), sigma=np.std(data))
            result = model.fit(count, params, x=bin_centers)

            #print(result.fit_report())

            # print("best values",result.best_values)
            # print("best fit",result.best_fit)
            # print("red chi2",result.redchi)

            amplitude_best = result.params['amplitude'].value
            amplitude_error = result.params['amplitude'].stderr

            center_best = result.params['center'].value
            center_error = result.params['center'].stderr

            sigma_best = result.params['sigma'].value
            sigma_error = result.params['sigma'].stderr

            height_best = result.params['height'].value
            height_error = result.params['height'].stderr

            chi2 = result.chisqr
            red_chi2 = result.redchi

            popt = [amplitude_best, center_best, sigma_best, height_best]
            errors = [amplitude_error, center_error, sigma_error, height_error]

            # sys.exit()

            # Initial guesses: amplitude, mean, std
            # p0 = [0.015, np.mean(data), np.std(data)]

            # Perform the fit
            # popt, pcov = curve_fit(gauss, bin_centers, count, p0=p0)

            # Extract fitted parameters and their errors from the covariance matrix
            # A_fit, mu_fit, sigma_fit = popt
            # errors = np.sqrt(np.diag(pcov))

            # print(f'Fit results: A = {A_fit:.3g} ± {errors[0]:.3g}, '
            #      f'mean = {mu_fit:.3g} ± {errors[1]:.3g}, '
            #      f'std = {sigma_fit:.3g} ± {errors[2]:.3g}')

            # expected = gauss(bin_centers, *popt)
            # chi2 = np.sum((count - expected) ** 2 / expected)
            # dof = len(count) - len(popt)

            # print(f'Chi-square: {chi2:.3g}')
            # print(f'Reduced Chi-square: {chi2 / dof:.3g}')

            # red_chi2= chi2/dof

            # normalisation = A_fit/(np.sqrt(2*np.pi)*sigma_fit)
            # normalisation_error = (1/(np.sqrt(2*np.pi)*sigma_fit))*np.sqrt(errors[0]**2+((-A_fit*errors[2])/sigma_fit)**2)

            # print("normalisation",normalisation,"±",normalisation_error)

            return popt, errors, chi2, red_chi2, bin_centers
            # sys.exit()

        large = 1

        def velocity_components_hist(x, y, z, vx, vy, vz, large):

            f, axs = plt.subplots(3, 4, figsize=(20, 8), constrained_layout=True)

            if large == 1:
                r1 = 2147
                r2 = 1087
                plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
                pdfrvir = "PDF ($R<R_{vir}$)"
                pdfr500 = "PDF ($R<R_{500}$)"
                height = 0.0017

            if large == 0:
                r1 = 500
                r2 = 100
                plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
                pdfrvir = "PDF ($R<500 kpc$)"
                pdfr500 = "PDF ($R<100 kpc$)"
                height = 0.0035

            vx_r1 = vx[r < r1]
            vy_r1 = vy[r < r1]
            vz_r1 = vz[r < r1]

            print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio", len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

            vx_r1 = vx_r1[t[r < r1] < 1e7]

            # sys.exit()

            # meanvx,stdvx = norm.fit(vx_r1)
            # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

            print(
                f"vx_r1 stat: mean={np.mean(vx_r1):.4g}, "f"median={np.median(vx_r1):.4g}, "f"std={np.std(vx_r1):.4g}, "f"skewness={skew(vx_r1):.4g}, "f"kurtosis={kurtosis(vx_r1):.4g}")

            # sys.exit()

            print(
                f"vy_r1 stat: mean={np.mean(vy_r1):.4g}, "f"median={np.median(vy_r1):.4g}, "f"std={np.std(vy_r1):.4g}, "f"skewness={skew(vy_r1):.4g}, "f"kurtosis={kurtosis(vy_r1):.4g}")
            print(
                f"vz_r1 stat: mean={np.mean(vz_r1):.4g}, "f"median={np.median(vz_r1):.4g}, "f"std={np.std(vz_r1):.4g}, "f"skewness={skew(vz_r1):.4g}, "f"kurtosis={kurtosis(vz_r1):.4g}")

            vx_r2 = vx[r < r2]
            vy_r2 = vy[r < r2]
            vz_r2 = vz[r < r2]

            print(
                f"vx_r2 stat: mean={np.mean(vx_r2):.4g}, "f"median={np.median(vx_r2):.4g}, "f"std={np.std(vx_r2):.4g}, "f"skewness={skew(vx_r2):.4g}, "f"kurtosis={kurtosis(vx_r2):.4g}")
            print(
                f"vy_r2 stat: mean={np.mean(vy_r2):.4g}, "f"median={np.median(vy_r2):.4g}, "f"std={np.std(vy_r2):.4g}, "f"skewness={skew(vy_r2):.4g}, "f"kurtosis={kurtosis(vy_r2):.4g}")
            print(
                f"vz_r2 stat: mean={np.mean(vz_r2):.4g}, "f"median={np.median(vz_r2):.4g}, "f"std={np.std(vz_r2):.4g}, "f"skewness={skew(vz_r2):.4g}, "f"kurtosis={kurtosis(vz_r2):.4g}")

            count, bins, _ = axs[0, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='red', density=True)

            # print("count",count)
            # sys.exit()

            popt, errors, chi2, red_chi2 = gaussian_fit(vx[r < r1], count, bins)
            axs[0, 0].plot(bins, gauss(bins, *popt[0:3]), color='black', label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[0,0].yscale('log')
            axs[0, 0].set_xlim(-1900, 1900)
            axs[0, 0].set_ylim(0, height)
            # axs[0, 0].set_ylim(0, 1.2e6)
            # axs[0,0].legend(fontsize=10)
            # axs[0, 0].set_title("$V_x$")
            # axs[0,0].set_xlabel("Vx [km/s]")
            # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
            axs[0, 0].set_ylabel(pdfrvir)
            axs[0, 0].set_xticks([])
            axs[0, 0].legend(fontsize=10)

            count, bins, _ = axs[0, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='blue', density=True)

            popt, errors, chi2, red_chi2 = gaussian_fit(vy[r < r1], count, bins)
            axs[0, 1].plot(bins, gauss(bins, *popt[0:3]), color='black', label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[0,1].yscale('log')
            axs[0, 1].set_xlim(-1900, 1900)
            axs[0, 1].set_ylim(0, height)
            # axs[0, 1].set_ylim(0, 1.2e6)
            # axs[0,1].legend(fontsize=10)
            # axs[0, 1].set_title("y component")
            axs[0, 1].set_yticks([])
            # axs[0,1].set_xlabel("Vy [km/s]")
            axs[0, 1].set_xticks([])
            axs[0, 1].legend(fontsize=10)

            count, bins, _ = axs[0, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='green', density=True)

            popt, errors, chi2, red_chi2 = gaussian_fit(vz[r < r1], count, bins)
            axs[0, 2].plot(bins, gauss(bins, *popt[0:3]), color='black', label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[0,2].yscale('log')
            axs[0, 2].set_xlim(-1900, 1900)
            axs[0, 2].set_ylim(0, height)
            # axs[0, 2].set_ylim(0, 1.2e6)
            # axs[0,2].legend(fontsize=10)
            # axs[0, 2].set_title("z projection")
            # axs[0,2].set_xlabel("Vz [km/s]")
            axs[0, 2].set_yticks([])
            axs[0, 2].set_xticks([])
            axs[0, 2].legend(fontsize=10)

            axs[0, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
            axs[0, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
            axs[0, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
            axs[0, 3].set_xlim(-1900, 1900)
            axs[0, 3].set_ylim(0, height)
            # axs[0, 3].set_ylim(0, 1.2e6)
            axs[0, 3].set_yticks([])
            axs[0, 3].set_xticks([])
            axs[0, 3].legend(fontsize=10)

            # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            count, bins, _ = axs[1, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='red', density=True)

            popt, errors, chi2, red_chi2 = gaussian_fit(vx[r < r2], count, bins)
            axs[1, 0].plot(bins, gauss(bins, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[1,0].yscale('log')
            axs[1, 0].set_xlim(-1900, 1900)
            axs[1, 0].set_ylim(0, height)
            # axs[1, 0].set_ylim(0, 1.3e4)
            # axs[1,0].legend(fontsize=10)
            # axs[1,0].set_title("x projection")
            # axs[1,0].set_xlabel("Vx [km/s]")
            # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
            axs[1, 0].set_ylabel(pdfr500)
            axs[1, 0].set_xticks([])
            axs[1, 0].legend(fontsize=10)

            count, bins, _ = axs[1, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', density=True)

            popt, errors, chi2, red_chi2 = gaussian_fit(vy[r < r2], count, bins)
            axs[1, 1].plot(bins, gauss(bins, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[1,1].yscale('log')
            axs[1, 1].set_xlim(-1900, 1900)
            axs[1, 1].set_ylim(0, height)
            # axs[1, 1].set_ylim(0, 1.3e4)
            # axs[1,1].legend(fontsize=10)
            # axs[1,1].set_title("y projection")
            axs[1, 1].set_yticks([])
            # axs[1,1].set_xlabel("Vy [km/s]")
            axs[1, 1].set_xticks([])
            axs[1, 1].legend(fontsize=10)

            count, bins, _ = axs[1, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='green', density=True)

            popt, errors, chi2, red_chi2 = gaussian_fit(vz[r < r2], count, bins)
            axs[1, 2].plot(bins, gauss(bins, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[1,2].yscale('log')
            axs[1, 2].set_xlim(-1900, 1900)
            axs[1, 2].set_ylim(0, height)
            # axs[1, 2].set_ylim(0, 1.3e4)
            # axs[1,2].legend(fontsize=10)
            # axs[1,2].set_title("z projection")
            # axs[1,2].set_xlabel("Vz [km/s]")
            axs[1, 2].set_yticks([])
            axs[1, 2].set_xticks([])
            axs[1, 2].legend(fontsize=10)

            axs[1, 3].hist(vx[r < r2], bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
            axs[1, 3].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
            axs[1, 3].hist(vz[r < r2], bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
            axs[1, 3].set_xlim(-1900, 1900)
            axs[1, 3].set_ylim(0, height)
            # axs[1, 3].set_ylim(0, 1.3e4)
            axs[1, 3].set_yticks([])
            axs[1, 3].legend(fontsize=10)
            # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            axs[2, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='red', label='$R<R_{vir}$', density=True)
            axs[2, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='darkred', label='$R<R_{500}$', density=True)
            # axs[2,0].yscale('log')
            axs[2, 0].set_xlim(-1900, 1900)
            axs[2, 0].set_ylim(0, height)
            # axs[2, 0].set_ylim(0, 700)
            # axs[2,0].legend(fontsize=10)
            # axs[2,0].set_title("x projection")
            axs[2, 0].set_xlabel("Vx [km/s]")
            axs[2, 0].set_ylabel("PDF")
            axs[2, 0].legend(fontsize=10)
            # axs[2, 0].set_yscale('log')

            axs[2, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='blue', label='$R<R_{vir}$', density=True)
            axs[2, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='darkblue', label='$R<R_{500}$', density=True)
            # xs[2,1].yscale('log')
            axs[2, 1].set_xlim(-1900, 1900)
            axs[2, 1].set_ylim(0, height)
            # axs[2, 1].set_ylim(0, 700)
            # axs[2,1].legend(fontsize=10)
            # axs[2,1].set_title("y projection")
            axs[2, 1].set_yticks([])
            axs[2, 1].set_xlabel("Vy [km/s]")
            axs[2, 1].legend(fontsize=10)
            # axs[2, 1].set_yscale('log')

            axs[2, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='green', label='$R<R_{vir}$', density=True)
            axs[2, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='darkgreen', label='$R<R_{500}$', density=True)
            # axs[2,2].yscale('log')
            axs[2, 2].set_xlim(-1900, 1900)
            axs[2, 2].set_ylim(0, height)
            # axs[2, 2].set_ylim(0, 700)
            # axs[2,2].legend(fontsize=10)
            # axs[2,2].set_title("z projection")
            axs[2, 2].set_xlabel("Vz [km/s]")
            axs[2, 2].set_yticks([])
            axs[2, 2].legend(fontsize=10)
            # axs[2, 2].set_yscale('log')

            # axs[3].yscale('log')

            # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
            # plt.grid(b=None)
            plt.legend()
            # plt.ylabel("PDF")
            axs[1, 3].set_xlabel("V [km/s]")

            axs[2, 3].axis("off")

            # plt.yscale('log')
            # plt.title("Vz distribution on ew sightline velocity along z axis")
            # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

            plt.show()

            sys.exit()

        def velocity_components_hist_5x4(x, y, z, vx, vy, vz, large):
            f, axs = plt.subplots(5, 4, figsize=(20, 8), constrained_layout=True)

            if large == 1:
                r1 = 2147
                r2 = 1087
                plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
                pdfrvir = "PDF \n ($R<R_{vir}$)"
                pdfr500 = "PDF \n ($R<R_{500}$)"
                height = 0.0017
                # height = 0.0035

            if large == 0:
                r1 = 500
                r2 = 100
                plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
                pdfrvir = "PDF \n ($R<500\,\mathrm{kpc}$)"
                pdfr500 = "PDF \n ($R<100$ kpc)"
                height = 0.0035

            vx_r1 = vx[r < r1]
            vy_r1 = vy[r < r1]
            vz_r1 = vz[r < r1]

            # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

            # vx_r1 = vx_r1[t[r < r1] < 1e7]

            # meanvx,stdvx = norm.fit(vx_r1)
            # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

            print(
                f"vx_r1 stat: mean={np.mean(vx_r1):.4g}, "f"median={np.median(vx_r1):.4g}, "f"std={np.std(vx_r1):.4g}, "f"skewness={skew(vx_r1):.4g}, "f"kurtosis={kurtosis(vx_r1):.4g}")

            # sys.exit()

            print(
                f"vy_r1 stat: mean={np.mean(vy_r1):.4g}, "f"median={np.median(vy_r1):.4g}, "f"std={np.std(vy_r1):.4g}, "f"skewness={skew(vy_r1):.4g}, "f"kurtosis={kurtosis(vy_r1):.4g}")
            print(
                f"vz_r1 stat: mean={np.mean(vz_r1):.4g}, "f"median={np.median(vz_r1):.4g}, "f"std={np.std(vz_r1):.4g}, "f"skewness={skew(vz_r1):.4g}, "f"kurtosis={kurtosis(vz_r1):.4g}")

            vx_r2 = vx[r < r2]
            vy_r2 = vy[r < r2]
            vz_r2 = vz[r < r2]

            print(
                f"vx_r2 stat: mean={np.mean(vx_r2):.4g}, "f"median={np.median(vx_r2):.4g}, "f"std={np.std(vx_r2):.4g}, "f"skewness={skew(vx_r2):.4g}, "f"kurtosis={kurtosis(vx_r2):.4g}")
            print(
                f"vy_r2 stat: mean={np.mean(vy_r2):.4g}, "f"median={np.median(vy_r2):.4g}, "f"std={np.std(vy_r2):.4g}, "f"skewness={skew(vy_r2):.4g}, "f"kurtosis={kurtosis(vy_r2):.4g}")
            print(
                f"vz_r2 stat: mean={np.mean(vz_r2):.4g}, "f"median={np.median(vz_r2):.4g}, "f"std={np.std(vz_r2):.4g}, "f"skewness={skew(vz_r2):.4g}, "f"kurtosis={kurtosis(vz_r2):.4g}")

            count, bins, _ = axs[0, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='darkred', density=True)

            # print("count",count)
            # sys.exit()

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r1], count, bins)
            axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[0,0].yscale('log')
            axs[0, 0].set_xlim(-1600, 1600)
            axs[0, 0].set_ylim(1e-5, height)
            # axs[0, 0].set_ylim(0, 1.2e6)
            # axs[0,0].legend(fontsize=10)
            # axs[0, 0].set_title("$V_x$")
            # axs[0,0].set_xlabel("Vx [km/s]")
            # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
            axs[0, 0].set_ylabel(pdfrvir)
            axs[0, 0].set_xticks([])
            axs[0, 0].set_yscale('log')
            # axs[0, 0].legend(fontsize=10)
            # axs[0,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='solid')

            count, bins, _ = axs[0, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='darkblue', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r1], count, bins)
            axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[0,1].yscale('log')
            axs[0, 1].set_xlim(-1600, 1600)
            axs[0, 1].set_ylim(1e-5, height)
            # axs[0, 1].set_ylim(0, 1.2e6)
            # axs[0,1].legend(fontsize=10)
            # axs[0, 1].set_title("y component")
            axs[0, 1].set_yticks([])
            # axs[0,1].set_xlabel("Vy [km/s]")
            axs[0, 1].set_xticks([])
            axs[0, 1].set_yscale('log')
            # axs[0, 1].legend(fontsize=10)
            axs[0, 1].yaxis.set_visible(False)
            # axs[0, 1].axvline(x=np.mean(vy[r < r1]), color='black', linestyle='solid')

            count, bins, _ = axs[0, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='darkgreen', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r1], count, bins)
            axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[0,2].yscale('log')
            axs[0, 2].set_xlim(-1600, 1600)
            axs[0, 2].set_ylim(1e-5, height)
            # axs[0, 2].set_ylim(0, 1.2e6)
            # axs[0,2].legend(fontsize=10)
            # axs[0, 2].set_title("z projection")
            # axs[0,2].set_xlabel("Vz [km/s]")
            axs[0, 2].set_yticks([])
            axs[0, 2].set_xticks([])
            axs[0, 2].set_yscale('log')
            # axs[0, 2].legend(fontsize=10)
            axs[0, 2].yaxis.set_visible(False)
            # axs[0, 2].axvline(x=np.mean(vz[r < r1]), color='black', linestyle='solid')

            axs[0, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='darkred', label='$V_x$', density=True)
            axs[0, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='darkblue', label='$V_y$', density=True)
            axs[0, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='darkgreen', label='$V_z$', density=True)
            axs[0, 3].set_xlim(-1600, 1600)
            axs[0, 3].set_ylim(1e-5, height)
            # axs[0, 3].set_ylim(0, 1.2e6)
            axs[0, 3].set_yticks([])
            axs[0, 3].set_xticks([])
            axs[0, 3].set_yscale('log')
            # axs[0, 3].legend(fontsize=10)
            axs[0, 3].yaxis.set_visible(False)
            # axs[0, 3].axvline(x=np.mean(vx[r < r1]), color='red', linestyle='solid')
            # axs[0, 3].axvline(x=np.mean(vy[r < r1]), color='blue', linestyle='solid')
            # axs[0, 3].axvline(x=np.mean(vz[r < r1]), color='green', linestyle='solid')

            # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            count, bins, _ = axs[1, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='red', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r2], count, bins)
            axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[1,0].yscale('log')
            axs[1, 0].set_xlim(-1600, 1600)
            axs[1, 0].set_ylim(1e-5, height)
            # axs[1, 0].set_ylim(0, 1.3e4)
            # axs[1,0].legend(fontsize=10)
            # axs[1,0].set_title("x projection")
            # axs[1,0].set_xlabel("Vx [km/s]")
            # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
            axs[1, 0].set_ylabel(pdfr500)
            axs[1, 0].set_xticks([])
            axs[1, 0].set_yscale('log')
            # axs[1, 0].legend(fontsize=10)
            # axs[1,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashed')

            count, bins, _ = axs[1, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r2], count, bins)
            axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[1,1].yscale('log')
            axs[1, 1].set_xlim(-1600, 1600)
            axs[1, 1].set_ylim(1e-5, height)
            # axs[1, 1].set_ylim(0, 1.3e4)
            # axs[1,1].legend(fontsize=10)
            # axs[1,1].set_title("y projection")
            axs[1, 1].set_yticks([])
            # axs[1,1].set_xlabel("Vy [km/s]")
            axs[1, 1].set_xticks([])
            axs[1, 1].set_yscale('log')
            # axs[1, 1].legend(fontsize=10)
            axs[1, 1].yaxis.set_visible(False)
            # axs[1, 1].axvline(x=np.mean(vy[r < r2]), color='black', linestyle='dashed')

            count, bins, _ = axs[1, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='green', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r2], count, bins)
            axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[1,2].yscale('log')
            axs[1, 2].set_xlim(-1600, 1600)
            axs[1, 2].set_ylim(1e-5, height)
            # axs[1, 2].set_ylim(0, 1.3e4)
            # axs[1,2].legend(fontsize=10)
            # axs[1,2].set_title("z projection")
            # axs[1,2].set_xlabel("Vz [km/s]")
            axs[1, 2].set_yticks([])
            axs[1, 2].set_xticks([])
            axs[1, 2].set_yscale('log')
            # axs[1, 2].legend(fontsize=10)
            axs[1, 2].yaxis.set_visible(False)
            # axs[1, 2].axvline(x=np.mean(vz[r < r2]), color='black', linestyle='dashed')

            axs[1, 3].hist(vx[r < r2], bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
            axs[1, 3].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
            axs[1, 3].hist(vz[r < r2], bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
            axs[1, 3].set_xlim(-1600, 1600)
            axs[1, 3].set_ylim(1e-5, height)
            # axs[1, 3].set_ylim(0, 1.3e4)
            axs[1, 3].set_yticks([])
            axs[1, 3].set_xticks([])
            axs[1, 3].set_yscale('log')
            # axs[1, 3].legend(fontsize=10)
            axs[1, 3].yaxis.set_visible(False)
            # axs[1, 3].axvline(x=np.mean(vx[r < r2]), color='red', linestyle='dashed')
            # axs[1, 3].axvline(x=np.mean(vy[r < r2]), color='blue', linestyle='dashed')
            # axs[1, 3].axvline(x=np.mean(vz[r < r2]), color='green', linestyle='dashed')
            # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            ########################################
            ########################################

            large = 0

            if large == 0:
                r1 = 500
                r2 = 100
                plt.suptitle("Velocity components PDFs within spheres of 500kpc and 100kpc radii")
                pdfrvir = "PDF \n ($R<500\,\mathrm{kpc}$)"
                pdfr500 = "PDF \n ($R<100\,\mathrm{kpc}$)"
                height1 = 0.002
                height = 0.0035

            vx_r1 = vx[r < r1]
            vy_r1 = vy[r < r1]
            vz_r1 = vz[r < r1]

            vx_r2 = vx[r < r2]
            vy_r2 = vy[r < r2]
            vz_r2 = vz[r < r2]

            count, bins, _ = axs[2, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', density=True)

            # print("count",count)
            # sys.exit()

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r1], count, bins)
            axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[2,0].yscale('log')
            axs[2, 0].set_xlim(-1600, 1600)
            axs[2, 0].set_ylim(1e-5, height1)
            # axs[2, 0].set_ylim(0, 1.2e6)
            # axs[2,0].legend(fontsize=10)
            # axs[2, 0].set_title("$V_x$")
            # axs[2,0].set_xlabel("Vx [km/s]")
            # axs[2, 0].set_ylabel("PDF ($R<R_{vir}$)")
            axs[2, 0].set_ylabel(pdfrvir)
            axs[2, 0].set_xticks([])
            axs[2, 0].set_yscale('log')
            # axs[2, 0].legend(fontsize=10)
            # axs[2,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='dotted')

            count, bins, _ = axs[2, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r1], count, bins)
            axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[2,1].yscale('log')
            axs[2, 1].set_xlim(-1600, 1600)
            axs[2, 1].set_ylim(1e-5, height1)
            # axs[2, 1].set_ylim(0, 1.2e6)
            # axs[2,1].legend(fontsize=10)
            # axs[2, 1].set_title("y component")
            axs[2, 1].set_yticks([])
            # axs[2,1].set_xlabel("Vy [km/s]")
            axs[2, 1].set_xticks([])
            axs[2, 1].set_yscale('log')
            # axs[2, 1].legend(fontsize=10)
            axs[2, 1].yaxis.set_visible(False)
            # axs[2, 1].axvline(x=np.mean(vy[r < r1]), color='black', linestyle='dotted')

            count, bins, _ = axs[2, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r1], count, bins)
            axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[2,2].yscale('log')
            axs[2, 2].set_xlim(-1600, 1600)
            axs[2, 2].set_ylim(1e-5, height1)
            # axs[2, 2].set_ylim(0, 1.2e6)
            # axs[2,2].legend(fontsize=10)
            # axs[2, 2].set_title("z projection")
            # axs[2,2].set_xlabel("Vz [km/s]")
            axs[2, 2].set_yticks([])
            axs[2, 2].set_xticks([])
            axs[2, 2].set_yscale('log')
            # axs[2, 2].legend(fontsize=10)
            axs[2, 2].yaxis.set_visible(False)
            # axs[2, 2].axvline(x=np.mean(vz[r < r1]), color='black', linestyle='dotted')

            axs[2, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', label='$V_x$', density=True)
            axs[2, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', label='$V_y$', density=True)
            axs[2, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', label='$V_z$', density=True)
            axs[2, 3].set_xlim(-1600, 1600)
            axs[2, 3].set_ylim(1e-5, height1)
            # axs[2, 3].set_ylim(0, 1.2e6)
            axs[2, 3].set_yticks([])
            axs[2, 3].set_xticks([])
            axs[2, 3].set_yscale('log')
            # axs[2, 3].legend(fontsize=10)
            axs[2, 3].yaxis.set_visible(False)
            # axs[2, 3].axvline(x=np.mean(vx[r < r1]), color='red', linestyle='dotted')
            # axs[2, 3].axvline(x=np.mean(vy[r < r1]), color='blue', linestyle='dotted')
            # axs[2, 3].axvline(x=np.mean(vz[r < r1]), color='green', linestyle='dotted')

            # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[2, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            count, bins, _ = axs[3, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r2], count, bins)
            axs[3, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[3,0].yscale('log')
            axs[3, 0].set_xlim(-1600, 1600)
            axs[3, 0].set_ylim(1e-5, height)
            # axs[3, 0].set_ylim(0, 1.3e4)
            # axs[3,0].legend(fontsize=10)
            # axs[3,0].set_title("x projection")
            # axs[3,0].set_xlabel("Vx [km/s]")
            # axs[3, 0].set_ylabel("PDF ($R<R_{500}$)")
            axs[3, 0].set_ylabel(pdfr500)
            axs[3, 0].set_xticks([])
            axs[3, 0].set_yscale('log')
            # axs[3, 0].legend(fontsize=10)
            # axs[3,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashdot')

            count, bins, _ = axs[3, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r2], count, bins)
            axs[3, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[3,1].yscale('log')
            axs[3, 1].set_xlim(-1600, 1600)
            axs[3, 1].set_ylim(1e-5, height)
            # axs[3, 1].set_ylim(0, 1.3e4)
            # axs[3,1].legend(fontsize=10)
            # axs[3,1].set_title("y projection")
            axs[3, 1].set_yticks([])
            # axs[3,1].set_xlabel("Vy [km/s]")
            axs[3, 1].set_xticks([])
            axs[3, 1].set_yscale('log')
            # axs[3, 1].legend(fontsize=10)
            axs[3, 1].yaxis.set_visible(False)
            # axs[3, 1].axvline(x=np.mean(vy[r < r2]), color='black', linestyle='dashdot')

            count, bins, _ = axs[3, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r2], count, bins)
            axs[3, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[3,2].yscale('log')
            axs[3, 2].set_xlim(-1600, 1600)
            axs[3, 2].set_ylim(1e-5, height)
            # axs[3, 2].set_ylim(0, 1.3e4)
            # axs[3,2].legend(fontsize=10)
            # axs[3,2].set_title("z projection")
            # axs[3,2].set_xlabel("Vz [km/s]")
            axs[3, 2].set_yticks([])
            axs[3, 2].set_xticks([])
            axs[3, 2].set_yscale('log')
            # axs[3, 2].legend(fontsize=10)
            axs[3, 2].yaxis.set_visible(False)
            # axs[3, 2].axvline(x=np.mean(vz[r < r2]), color='black', linestyle='dashdot')

            axs[3, 3].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', label='$V_x$', density=True)
            axs[3, 3].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', label='$V_y$', density=True)
            axs[3, 3].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', label='$V_z$', density=True)
            axs[3, 3].set_xlim(-1600, 1600)
            axs[3, 3].set_ylim(1e-5, height)
            # axs[3, 3].set_ylim(0, 1.3e4)
            axs[3, 3].set_yticks([])
            axs[3, 3].set_xticks([])
            # axs[3, 3].legend(fontsize=10)
            axs[3, 3].set_yscale('log')
            axs[3, 3].yaxis.set_visible(False)
            # axs[3, 3].axvline(x=np.mean(vx[r < r2]), color='red', linestyle='dashdot')
            # axs[3, 3].axvline(x=np.mean(vy[r < r2]), color='blue', linestyle='dashdot')
            # axs[3, 3].axvline(x=np.mean(vz[r < r2]), color='green', linestyle='dashdot')
            # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[3, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            ########################################
            ########################################

            rvir = 2147
            r500 = 1087

            axs[4, 0].hist(vx[r < rvir], bins=20, alpha=0.6, color='darkred', label='$R<R_{vir}$', density=True)  # ,histtype='step',linewidth=2)
            axs[4, 0].hist(vx[r < r500], bins=20, alpha=0.6, color='red', label='$R<R_{500}$', density=True)  # ,histtype='step',linewidth=2)
            axs[4, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', label='$R<500kpc$', density=True)  # ,histtype='step',linewidth=2)
            axs[4, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', label='$R<100kpc$', density=True)  # ,histtype='step',linewidth=2)
            # axs[4,0].yscale('log')
            axs[4, 0].set_xlim(-1600, 1600)
            axs[4, 0].set_ylim(1e-5, height)
            # axs[4, 0].set_ylim(0, 700)
            # axs[4,0].legend(fontsize=10)
            # axs[4,0].set_title("x projection")
            axs[4, 0].set_xlabel("$v_{x}~[\mathrm{km~s^{-1}}]$")
            axs[4, 0].set_ylabel("PDF")
            axs[4, 0].set_yscale('log')
            # axs[4,0].axvline(x=np.mean(vx[r<rvir]), color='black', linestyle='solid')
            # axs[4,0].axvline(x=np.mean(vx[r<r500]), color='black', linestyle='dashed')
            # axs[4,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='dotted')
            # axs[4,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashdot')
            # axs[4, 0].legend(fontsize=10)
            # axs[4, 0].set_yscale('log')

            axs[4, 1].hist(vy[r < rvir], bins=20, alpha=0.6, color='darkblue', label='$R<R_{vir}$', density=True)  # ,histtype='step',linewidth=2)
            axs[4, 1].hist(vy[r < r500], bins=20, alpha=0.6, color='blue', label='$R<R_{500}$', density=True)  # ,histtype='step',linewidth=2)
            axs[4, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', label='$R<500kpc$', density=True)  # ,histtype='step',linewidth=2)
            axs[4, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', label='$R<100kpc$', density=True)  # ,histtype='step',linewidth=2)
            # xs[4,1].yscale('log')
            axs[4, 1].set_xlim(-1600, 1600)
            axs[4, 1].set_ylim(1e-5, height)
            # axs[4, 1].set_ylim(0, 700)
            # axs[4,1].legend(fontsize=10)
            # axs[4,1].set_title("y projection")
            axs[4, 1].set_yticks([])
            axs[4, 1].set_xlabel("$v_{y}~[\mathrm{km~s^{-1}}]$")
            axs[4, 1].set_yscale('log')
            # axs[4,1].axvline(x=np.mean(vy[r<rvir]), color='black', linestyle='solid')
            # axs[4,1].axvline(x=np.mean(vy[r<r500]), color='black', linestyle='dashed')
            # axs[4,1].axvline(x=np.mean(vy[r<r1]), color='black', linestyle='dotted')
            # axs[4,1].axvline(x=np.mean(vy[r<r2]), color='black', linestyle='dashdot')
            # axs[4, 1].legend(fontsize=10)
            # axs[4, 1].set_yscale('log')
            axs[4, 1].yaxis.set_visible(False)

            axs[4, 2].hist(vz[r < rvir], bins=20, alpha=0.6, color='darkgreen', label='$R<R_{vir}$', density=True)  # ,histtype='step',linewidth=2)
            axs[4, 2].hist(vz[r < r500], bins=20, alpha=0.6, color='green', label='$R<R_{500}$', density=True)  # ,histtype='step',linewidth=2)
            axs[4, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', label='$R<500kpc$', density=True)  # ,histtype='step',linewidth=2)
            axs[4, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', label='$R<100kpc$', density=True)  # ,histtype='step',linewidth=2)
            # axs[4,2].yscale('log')
            axs[4, 2].set_xlim(-1600, 1600)
            axs[4, 2].set_ylim(1e-5, height)
            # axs[4, 2].set_ylim(0, 700)
            # axs[4,2].legend(fontsize=10)
            # axs[4,2].set_title("z projection")
            axs[4, 2].set_xlabel("$v_{z}~[\mathrm{km~s^{-1}}]$")
            axs[4, 2].set_yticks([])
            # axs[4, 2].legend(fontsize=10)
            axs[4, 2].set_yscale('log')
            # axs[4,2].axvline(x=np.mean(vz[r<rvir]), color='black', linestyle='solid')
            # axs[4,2].axvline(x=np.mean(vz[r<r500]), color='black', linestyle='dashed')
            # axs[4,2].axvline(x=np.mean(vz[r<r1]), color='black', linestyle='dotted')
            # axs[4,2].axvline(x=np.mean(vz[r<r2]), color='black', linestyle='dashdot')
            axs[4, 2].yaxis.set_visible(False)
            # axs[4, 2].set_yscale('log')

            # axs[3].yscale('log')

            # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
            # plt.grid(b=None)
            plt.legend()
            # plt.ylabel("PDF")
            axs[3, 3].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")

            axs[4, 3].axis("off")

            # plt.yscale('log')
            # plt.title("Vz distribution on ew sightline velocity along z axis")
            # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

            plt.suptitle("Velocity components distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii spheres")

            plt.show()

            sys.exit()

        def velocity_components_hist_4x4(x, y, z, vx, vy, vz, large):

            stat_matrix = np.zeros((9,9))


            f, axs = plt.subplots(4, 4, figsize=(20, 8), constrained_layout=True)

            if large == 1:
                r1 = 2147
                r2 = 1087
                plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
                pdfrvir = "PDF \n ($R<R_{vir}$)"
                pdfr500 = "PDF \n ($R<R_{500}$)"
                height = 0.0017
                # height = 0.0035

            if large == 0:
                r1 = 515
                r2 = 100
                plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
                pdfrvir = "PDF \n ($R<500\,\mathrm{kpc}$)"
                pdfr500 = "PDF \n ($R<100$ kpc)"
                height = 0.0035

            vx_r1 = vx[r < r1]
            vy_r1 = vy[r < r1]
            vz_r1 = vz[r < r1]

            # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

            # vx_r1 = vx_r1[t[r < r1] < 1e7]

            # meanvx,stdvx = norm.fit(vx_r1)
            # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

            #print(f"vx_r1 stat: mean={np.mean(vx_r1):.4g}, "f"median={np.median(vx_r1):.4g}, "f"std={np.std(vx_r1):.4g}, "f"skewness={skew(vx_r1):.4g}, "f"kurtosis={kurtosis(vx_r1):.4g}")

            # sys.exit()

            #print(f"vy_r1 stat: mean={np.mean(vy_r1):.4g}, "f"median={np.median(vy_r1):.4g}, "f"std={np.std(vy_r1):.4g}, "f"skewness={skew(vy_r1):.4g}, "f"kurtosis={kurtosis(vy_r1):.4g}")
            #print(f"vz_r1 stat: mean={np.mean(vz_r1):.4g}, "f"median={np.median(vz_r1):.4g}, "f"std={np.std(vz_r1):.4g}, "f"skewness={skew(vz_r1):.4g}, "f"kurtosis={kurtosis(vz_r1):.4g}")

            vx_r2 = vx[r < r2]
            vy_r2 = vy[r < r2]
            vz_r2 = vz[r < r2]

            #print(f"vx_r2 stat: mean={np.mean(vx_r2):.4g}, "f"median={np.median(vx_r2):.4g}, "f"std={np.std(vx_r2):.4g}, "f"skewness={skew(vx_r2):.4g}, "f"kurtosis={kurtosis(vx_r2):.4g}")
            #print(f"vy_r2 stat: mean={np.mean(vy_r2):.4g}, "f"median={np.median(vy_r2):.4g}, "f"std={np.std(vy_r2):.4g}, "f"skewness={skew(vy_r2):.4g}, "f"kurtosis={kurtosis(vy_r2):.4g}")
            #print(f"vz_r2 stat: mean={np.mean(vz_r2):.4g}, "f"median={np.median(vz_r2):.4g}, "f"std={np.std(vz_r2):.4g}, "f"skewness={skew(vz_r2):.4g}, "f"kurtosis={kurtosis(vz_r2):.4g}")

            count, bins, _ = axs[0, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='darkred', density=True)

            # print("count",count)
            # sys.exit()

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r1], count, bins)
            print(f"vx_r1 stat: {np.median(vx_r1):.1f} "f"& {np.mean(vx_r1):.1F} "f"& {np.std(vx_r1):.1f} "f"& {skew(vx_r1):.2f} "f"& {kurtosis(vx_r1):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}" )
            #sys.exit()

            stat_matrix[0,:]=[np.median(vx_r1),np.mean(vx_r1),np.std(vx_r1),skew(vx_r1),kurtosis(vx_r1),popt[1],errors[1],popt[2],errors[2]]

            axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[0,0].yscale('log')
            axs[0, 0].set_xlim(-1600, 1600)
            axs[0, 0].set_ylim(1e-5, height)
            # axs[0, 0].set_ylim(0, 1.2e6)
            # axs[0,0].legend(fontsize=10)
            # axs[0, 0].set_title("$V_x$")
            # axs[0,0].set_xlabel("Vx [km/s]")
            # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
            axs[0, 0].set_ylabel(pdfrvir)
            axs[0, 0].set_xticks([])
            axs[0, 0].set_yscale('log')
            # axs[0, 0].legend(fontsize=10)
            # axs[0,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='solid')

            count, bins, _ = axs[0, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='darkblue', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r1], count, bins)
            print(f"vy_r1 stat: {np.median(vy_r1):.1f} "f"& {np.mean(vy_r1):.1F} "f"& {np.std(vy_r1):.1f} "f"& {skew(vy_r1):.2f} "f"& {kurtosis(vy_r1):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}" )

            stat_matrix[1,:]=[np.median(vy_r1),np.mean(vy_r1),np.std(vy_r1),skew(vy_r1),kurtosis(vy_r1),popt[1],errors[1],popt[2],errors[2]]

            axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[0,1].yscale('log')
            axs[0, 1].set_xlim(-1600, 1600)
            axs[0, 1].set_ylim(1e-5, height)
            # axs[0, 1].set_ylim(0, 1.2e6)
            # axs[0,1].legend(fontsize=10)
            # axs[0, 1].set_title("y component")
            axs[0, 1].set_yticks([])
            # axs[0,1].set_xlabel("Vy [km/s]")
            axs[0, 1].set_xticks([])
            axs[0, 1].set_yscale('log')
            # axs[0, 1].legend(fontsize=10)
            axs[0, 1].yaxis.set_visible(False)
            # axs[0, 1].axvline(x=np.mean(vy[r < r1]), color='black', linestyle='solid')

            count, bins, _ = axs[0, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='darkgreen', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r1], count, bins)
            print(f"vz_r1 stat: {np.median(vz_r1):.1f} "f"& {np.mean(vz_r1):.1F} "f"& {np.std(vz_r1):.1f} "f"& {skew(vz_r1):.2f} "f"& {kurtosis(vz_r1):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}" )

            stat_matrix[2,:]=[np.median(vz_r1),np.mean(vz_r1),np.std(vz_r1),skew(vz_r1),kurtosis(vz_r1),popt[1],errors[1],popt[2],errors[2]]

            axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[0,2].yscale('log')
            axs[0, 2].set_xlim(-1600, 1600)
            axs[0, 2].set_ylim(1e-5, height)
            # axs[0, 2].set_ylim(0, 1.2e6)
            # axs[0,2].legend(fontsize=10)
            # axs[0, 2].set_title("z projection")
            # axs[0,2].set_xlabel("Vz [km/s]")
            axs[0, 2].set_yticks([])
            axs[0, 2].set_xticks([])
            axs[0, 2].set_yscale('log')
            # axs[0, 2].legend(fontsize=10)
            axs[0, 2].yaxis.set_visible(False)
            # axs[0, 2].axvline(x=np.mean(vz[r < r1]), color='black', linestyle='solid')

            axs[0, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='darkred', label='$V_x$', density=True)
            axs[0, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='darkblue', label='$V_y$', density=True)
            axs[0, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='darkgreen', label='$V_z$', density=True)
            axs[0, 3].set_xlim(-1600, 1600)
            axs[0, 3].set_ylim(1e-5, height)
            # axs[0, 3].set_ylim(0, 1.2e6)
            axs[0, 3].set_yticks([])
            axs[0, 3].set_xticks([])
            axs[0, 3].set_yscale('log')
            # axs[0, 3].legend(fontsize=10)
            axs[0, 3].yaxis.set_visible(False)
            # axs[0, 3].axvline(x=np.mean(vx[r < r1]), color='red', linestyle='solid')
            # axs[0, 3].axvline(x=np.mean(vy[r < r1]), color='blue', linestyle='solid')
            # axs[0, 3].axvline(x=np.mean(vz[r < r1]), color='green', linestyle='solid')

            # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            count, bins, _ = axs[1, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='red', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r2], count, bins)
            print(f"vx_r2 stat: {np.median(vx_r2):.1f} "f"& {np.mean(vx_r2):.1F} "f"& {np.std(vx_r2):.1f} "f"& {skew(vx_r2):.2f} "f"& {kurtosis(vx_r2):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")

            stat_matrix[3,:]=[np.median(vx_r2),np.mean(vx_r2),np.std(vx_r2),skew(vx_r2),kurtosis(vx_r2),popt[1],errors[1],popt[2],errors[2]]

            axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[1,0].yscale('log')
            axs[1, 0].set_xlim(-1600, 1600)
            axs[1, 0].set_ylim(1e-5, height)
            # axs[1, 0].set_ylim(0, 1.3e4)
            # axs[1,0].legend(fontsize=10)
            # axs[1,0].set_title("x projection")
            # axs[1,0].set_xlabel("Vx [km/s]")
            # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
            axs[1, 0].set_ylabel(pdfr500)
            axs[1, 0].set_xticks([])
            axs[1, 0].set_yscale('log')
            # axs[1, 0].legend(fontsize=10)
            # axs[1,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashed')

            count, bins, _ = axs[1, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r2], count, bins)
            print(f"vy_r2 stat: {np.median(vy_r2):.1f} "f"& {np.mean(vy_r2):.1F} "f"& {np.std(vy_r2):.1f} "f"& {skew(vy_r2):.2f} "f"& {kurtosis(vy_r2):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")

            stat_matrix[4,:]=[np.median(vy_r2),np.mean(vy_r2),np.std(vy_r2),skew(vy_r2),kurtosis(vy_r2),popt[1],errors[1],popt[2],errors[2]]

            axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[1,1].yscale('log')
            axs[1, 1].set_xlim(-1600, 1600)
            axs[1, 1].set_ylim(1e-5, height)
            # axs[1, 1].set_ylim(0, 1.3e4)
            # axs[1,1].legend(fontsize=10)
            # axs[1,1].set_title("y projection")
            axs[1, 1].set_yticks([])
            # axs[1,1].set_xlabel("Vy [km/s]")
            axs[1, 1].set_xticks([])
            axs[1, 1].set_yscale('log')
            # axs[1, 1].legend(fontsize=10)
            axs[1, 1].yaxis.set_visible(False)
            # axs[1, 1].axvline(x=np.mean(vy[r < r2]), color='black', linestyle='dashed')

            count, bins, _ = axs[1, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='green', density=True)

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r2], count, bins)
            print(f"vz_r2 stat: {np.median(vz_r2):.1f} "f"& {np.mean(vz_r2):.1F} "f"& {np.std(vz_r2):.1f} "f"& {skew(vz_r2):.2f} "f"& {kurtosis(vz_r2):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")

            stat_matrix[5,:]=[np.median(vz_r2),np.mean(vz_r2),np.std(vz_r2),skew(vz_r2),kurtosis(vz_r2),popt[1],errors[1],popt[2],errors[2]]

            axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[1,2].yscale('log')
            axs[1, 2].set_xlim(-1600, 1600)
            axs[1, 2].set_ylim(1e-5, height)
            # axs[1, 2].set_ylim(0, 1.3e4)
            # axs[1,2].legend(fontsize=10)
            # axs[1,2].set_title("z projection")
            # axs[1,2].set_xlabel("Vz [km/s]")
            axs[1, 2].set_yticks([])
            axs[1, 2].set_xticks([])
            axs[1, 2].set_yscale('log')
            # axs[1, 2].legend(fontsize=10)
            axs[1, 2].yaxis.set_visible(False)
            # axs[1, 2].axvline(x=np.mean(vz[r < r2]), color='black', linestyle='dashed')

            axs[1, 3].hist(vx[r < r2], bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
            axs[1, 3].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
            axs[1, 3].hist(vz[r < r2], bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
            axs[1, 3].set_xlim(-1600, 1600)
            axs[1, 3].set_ylim(1e-5, height)
            # axs[1, 3].set_ylim(0, 1.3e4)
            axs[1, 3].set_yticks([])
            axs[1, 3].set_xticks([])
            axs[1, 3].set_yscale('log')
            # axs[1, 3].legend(fontsize=10)
            axs[1, 3].yaxis.set_visible(False)
            # axs[1, 3].axvline(x=np.mean(vx[r < r2]), color='red', linestyle='dashed')
            # axs[1, 3].axvline(x=np.mean(vy[r < r2]), color='blue', linestyle='dashed')
            # axs[1, 3].axvline(x=np.mean(vz[r < r2]), color='green', linestyle='dashed')
            # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            ########################################
            ########################################

            large = 0

            if large == 0:
                r1 = 515
                r2 = 100
                plt.suptitle("Velocity components PDFs within spheres of 500kpc and 100kpc radii")
                pdfrvir = "PDF \n ($R<R_{2500}$)"
                pdfr500 = "PDF \n ($R<100\,\mathrm{kpc}$)"
                height1 = 0.002
                height = 0.0035

            vx_r1 = vx[r < r1]
            vy_r1 = vy[r < r1]
            vz_r1 = vz[r < r1]

            vx_r2 = vx[r < r2]
            vy_r2 = vy[r < r2]
            vz_r2 = vz[r < r2]

            count, bins, _ = axs[2, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', density=True)

            # print("count",count)
            # sys.exit()

            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r1], count, bins)
            print(f"vx_r1 stat: {np.median(vx_r1):.1f} "f"& {np.mean(vx_r1):.1F} "f"& {np.std(vx_r1):.1f} "f"& {skew(vx_r1):.2f} "f"& {kurtosis(vx_r1):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}" )

            stat_matrix[6, :] = [np.median(vx_r1), np.mean(vx_r1), np.std(vx_r1), skew(vx_r1), kurtosis(vx_r1), popt[1], errors[1], popt[2], errors[2]]

            axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[2,0].yscale('log')
            axs[2, 0].set_xlim(-1600, 1600)
            axs[2, 0].set_ylim(1e-5, height1)
            # axs[2, 0].set_ylim(0, 1.2e6)
            # axs[2,0].legend(fontsize=10)
            # axs[2, 0].set_title("$V_x$")
            # axs[2,0].set_xlabel("Vx [km/s]")
            # axs[2, 0].set_ylabel("PDF ($R<R_{vir}$)")
            axs[2, 0].set_ylabel(pdfrvir)
            axs[2, 0].set_xticks([])
            axs[2, 0].set_yscale('log')
            # axs[2, 0].legend(fontsize=10)
            # axs[2,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='dotted')

            count, bins, _ = axs[2, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', density=True)
            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r1], count, bins)
            print(f"vy_r1 stat: {np.median(vy_r1):.1f} "f"& {np.mean(vy_r1):.1F} "f"& {np.std(vy_r1):.1f} "f"& {skew(vy_r1):.2f} "f"& {kurtosis(vy_r1):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")

            stat_matrix[7, :] = [np.median(vy_r1), np.mean(vy_r1), np.std(vy_r1), skew(vy_r1), kurtosis(vy_r1), popt[1], errors[1], popt[2], errors[2]]

            axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # xs[2,1].yscale('log')
            axs[2, 1].set_xlim(-1600, 1600)
            axs[2, 1].set_ylim(1e-5, height1)
            # axs[2, 1].set_ylim(0, 1.2e6)
            # axs[2,1].legend(fontsize=10)
            # axs[2, 1].set_title("y component")
            axs[2, 1].set_yticks([])
            # axs[2,1].set_xlabel("Vy [km/s]")
            axs[2, 1].set_xticks([])
            axs[2, 1].set_yscale('log')
            # axs[2, 1].legend(fontsize=10)
            axs[2, 1].yaxis.set_visible(False)
            # axs[2, 1].axvline(x=np.mean(vy[r < r1]), color='black', linestyle='dotted')

            count, bins, _ = axs[2, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', density=True)
            popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r1], count, bins)
            print(f"vz_r1 stat: {np.median(vz_r1):.1f} "f"& {np.mean(vz_r1):.1F} "f"& {np.std(vz_r1):.1f} "f"& {skew(vz_r1):.2f} "f"& {kurtosis(vz_r1):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")

            stat_matrix[8, :] = [np.median(vz_r1), np.mean(vz_r1), np.std(vz_r1), skew(vz_r1), kurtosis(vz_r1), popt[1], errors[1], popt[2], errors[2]]

            axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                           label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                               popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

            # axs[2,2].yscale('log')
            axs[2, 2].set_xlim(-1600, 1600)
            axs[2, 2].set_ylim(1e-5, height1)
            # axs[2, 2].set_ylim(0, 1.2e6)
            # axs[2,2].legend(fontsize=10)
            # axs[2, 2].set_title("z projection")
            # axs[2,2].set_xlabel("Vz [km/s]")
            axs[2, 2].set_yticks([])
            axs[2, 2].set_xticks([])
            axs[2, 2].set_yscale('log')
            # axs[2, 2].legend(fontsize=10)
            axs[2, 2].yaxis.set_visible(False)
            # axs[2, 2].axvline(x=np.mean(vz[r < r1]), color='black', linestyle='dotted')

            axs[2, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', label='$V_x$', density=True)
            axs[2, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', label='$V_y$', density=True)
            axs[2, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', label='$V_z$', density=True)
            axs[2, 3].set_xlim(-1600, 1600)
            axs[2, 3].set_ylim(1e-5, height1)
            # axs[2, 3].set_ylim(0, 1.2e6)
            axs[2, 3].set_yticks([])
            axs[2, 3].set_xticks([])
            axs[2, 3].set_yscale('log')
            # axs[2, 3].legend(fontsize=10)
            axs[2, 3].yaxis.set_visible(False)
            # axs[2, 3].axvline(x=np.mean(vx[r < r1]), color='red', linestyle='dotted')
            # axs[2, 3].axvline(x=np.mean(vy[r < r1]), color='blue', linestyle='dotted')
            # axs[2, 3].axvline(x=np.mean(vz[r < r1]), color='green', linestyle='dotted')

            # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[2, 3].transAxes, verticalalignment='center',
            #         rotation=270, fontsize=14)

            rvir = 2147
            r500 = 1087

            axs[3, 0].hist(vx[r < rvir], bins=20, alpha=0.6, color='darkred', label='$R<R_{vir}$', density=True)  # ,histtype='step',linewidth=2)
            axs[3, 0].hist(vx[r < r500], bins=20, alpha=0.6, color='red', label='$R<R_{500}$', density=True)  # ,histtype='step',linewidth=2)
            axs[3, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', label='$R<500kpc$', density=True)  # ,histtype='step',linewidth=2)
            #axs[3, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', label='$R<100kpc$', density=True)  # ,histtype='step',linewidth=2)
            # axs[3,0].yscale('log')
            axs[3, 0].set_xlim(-1600, 1600)
            axs[3, 0].set_ylim(1e-5, height1)
            # axs[3, 0].set_ylim(0, 700)
            # axs[3,0].legend(fontsize=10)
            # axs[3,0].set_title("x projection")
            axs[3, 0].set_xlabel("$v_{x}~[\mathrm{km~s^{-1}}]$")
            axs[3, 0].set_ylabel("PDF")
            axs[3, 0].set_yscale('log')
            # axs[3,0].axvline(x=np.mean(vx[r<rvir]), color='black', linestyle='solid')
            # axs[3,0].axvline(x=np.mean(vx[r<r500]), color='black', linestyle='dashed')
            # axs[3,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='dotted')
            # axs[3,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashdot')
            # axs[3, 0].legend(fontsize=10)
            # axs[3, 0].set_yscale('log')

            axs[3, 1].hist(vy[r < rvir], bins=20, alpha=0.6, color='darkblue', label='$R<R_{vir}$', density=True)  # ,histtype='step',linewidth=2)
            axs[3, 1].hist(vy[r < r500], bins=20, alpha=0.6, color='blue', label='$R<R_{500}$', density=True)  # ,histtype='step',linewidth=2)
            axs[3, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', label='$R<500kpc$', density=True)  # ,histtype='step',linewidth=2)
            #axs[3, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', label='$R<100kpc$', density=True)  # ,histtype='step',linewidth=2)
            # xs[3,1].yscale('log')
            axs[3, 1].set_xlim(-1600, 1600)
            axs[3, 1].set_ylim(1e-5, height1)
            # axs[3, 1].set_ylim(0, 700)
            # axs[3,1].legend(fontsize=10)
            # axs[3,1].set_title("y projection")
            axs[3, 1].set_yticks([])
            axs[3, 1].set_xlabel("$v_{y}~[\mathrm{km~s^{-1}}]$")
            axs[3, 1].set_yscale('log')
            # axs[3,1].axvline(x=np.mean(vy[r<rvir]), color='black', linestyle='solid')
            # axs[3,1].axvline(x=np.mean(vy[r<r500]), color='black', linestyle='dashed')
            # axs[3,1].axvline(x=np.mean(vy[r<r1]), color='black', linestyle='dotted')
            # axs[3,1].axvline(x=np.mean(vy[r<r2]), color='black', linestyle='dashdot')
            # axs[3, 1].legend(fontsize=10)
            # axs[3, 1].set_yscale('log')
            axs[3, 1].yaxis.set_visible(False)

            axs[3, 2].hist(vz[r < rvir], bins=20, alpha=0.6, color='darkgreen', label='$R<R_{vir}$', density=True)  # ,histtype='step',linewidth=2)
            axs[3, 2].hist(vz[r < r500], bins=20, alpha=0.6, color='green', label='$R<R_{500}$', density=True)  # ,histtype='step',linewidth=2)
            axs[3, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', label='$R<500kpc$', density=True)  # ,histtype='step',linewidth=2)
            #axs[3, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', label='$R<100kpc$', density=True)  # ,histtype='step',linewidth=2)
            # axs[3,2].yscale('log')
            axs[3, 2].set_xlim(-1600, 1600)
            axs[3, 2].set_ylim(1e-5, height1)
            # axs[3, 2].set_ylim(0, 700)
            # axs[3,2].legend(fontsize=10)
            # axs[3,2].set_title("z projection")
            axs[3, 2].set_xlabel("$v_{z}~[\mathrm{km~s^{-1}}]$")
            axs[3, 2].set_yticks([])
            # axs[3, 2].legend(fontsize=10)
            axs[3, 2].set_yscale('log')
            # axs[3,2].axvline(x=np.mean(vz[r<rvir]), color='black', linestyle='solid')
            # axs[3,2].axvline(x=np.mean(vz[r<r500]), color='black', linestyle='dashed')
            # axs[3,2].axvline(x=np.mean(vz[r<r1]), color='black', linestyle='dotted')
            # axs[3,2].axvline(x=np.mean(vz[r<r2]), color='black', linestyle='dashdot')
            axs[3, 2].yaxis.set_visible(False)
            # axs[3, 2].set_yscale('log')

            # axs[3].yscale('log')

            # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
            # plt.grid(b=None)
            plt.legend()
            # plt.ylabel("PDF")
            axs[3, 3].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")

            axs[3, 3].axis("off")

            # plt.yscale('log')
            # plt.title("Vz distribution on ew sightline velocity along z axis")
            # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

            plt.suptitle("Velocity components distribution within $R_{vir}$, $R_{500}$ and $R_{2500}$")

            print(stat_matrix)
            np.save("stats_3D_pdf.npy",stat_matrix)
            print("file saved")

            plt.show()

            sys.exit()

        velocity_components_hist_4x4(x, y, z, vx, vy, vz, large)

    vel_comp_3D_hist(x7, y7, z7, vx7, vy7, vz7,m7)


def PDF_2D():
    def gauss(x, A, mu, sigma):
        return A * norm.pdf(x, mu, sigma)
    def gaussian_fit(data, count, bins):

        # Bin centers for fitting
        bin_centers = (bins[:-1] + bins[1:]) / 2

        # Define Gaussian function

        model = GaussianModel()

        params = model.make_params(amplitude=1, center=np.mean(data), sigma=np.std(data))
        result = model.fit(count, params, x=bin_centers)

        #print(result.fit_report())

        # print("best values",result.best_values)
        # print("best fit",result.best_fit)
        # print("red chi2",result.redchi)

        amplitude_best = result.params['amplitude'].value
        amplitude_error = result.params['amplitude'].stderr

        center_best = result.params['center'].value
        center_error = result.params['center'].stderr

        sigma_best = result.params['sigma'].value
        sigma_error = result.params['sigma'].stderr

        height_best = result.params['height'].value
        height_error = result.params['height'].stderr

        chi2 = result.chisqr
        red_chi2 = result.redchi

        popt = [amplitude_best, center_best, sigma_best, height_best]
        errors = [amplitude_error, center_error, sigma_error, height_error]

        #print("mean",center_best,"±",center_error,"std",sigma_best,"±",sigma_error)

        # sys.exit()

        # Initial guesses: amplitude, mean, std
        # p0 = [0.015, np.mean(data), np.std(data)]

        # Perform the fit
        # popt, pcov = curve_fit(gauss, bin_centers, count, p0=p0)

        # Extract fitted parameters and their errors from the covariance matrix
        # A_fit, mu_fit, sigma_fit = popt
        # errors = np.sqrt(np.diag(pcov))

        # print(f'Fit results: A = {A_fit:.3g} ± {errors[0]:.3g}, '
        #      f'mean = {mu_fit:.3g} ± {errors[1]:.3g}, '
        #      f'std = {sigma_fit:.3g} ± {errors[2]:.3g}')

        # expected = gauss(bin_centers, *popt)
        # chi2 = np.sum((count - expected) ** 2 / expected)
        # dof = len(count) - len(popt)

        # print(f'Chi-square: {chi2:.3g}')
        # print(f'Reduced Chi-square: {chi2 / dof:.3g}')

        # red_chi2= chi2/dof

        # normalisation = A_fit/(np.sqrt(2*np.pi)*sigma_fit)
        # normalisation_error = (1/(np.sqrt(2*np.pi)*sigma_fit))*np.sqrt(errors[0]**2+((-A_fit*errors[2])/sigma_fit)**2)

        # print("normalisation",normalisation,"±",normalisation_error)

        return popt, errors, chi2, red_chi2, bin_centers

    def load_map(file,proj):
        h = FortranFile(file, 'r')
        nx, ny, nz = h.read_ints()
        cen_x, cen_y, cen_z = h.read_reals()
        print("nx,ny,nz", nx, ny, nz)
        # print("cen_x,cen_y,cen_z",cen_x,cen_y,cen_z)
        # sys.exit()
        # ncell = 0
        # print(ncell.dtype)
        # sys.exit()
        # ncell = np
        # sys.exit()
        if proj == "x":
            ncell = nz * ny
        elif proj == "y":
            ncell = nx * nz
        elif proj == "z":
            # ncell = np.uint64(nx * ny)
            ncell = nx * ny
        print("ncell", ncell)

        map = np.zeros(ncell)

        map = ftp.f90_to_py.read_map_file(ncell, file, 0)
        # map=h.read_reals()

        print("len nan",len(map[np.isnan(map)==True]),'ratio, ',len(map[np.isnan(map)==True])/len(map))
        #sys.exit()

        if proj == "x":
            map = np.reshape(map, (nz, ny))
            #map2 = np.reshape(map2, (nz, ny))
            #map3 = np.reshape(map3, (nz, ny))
            nl = nx
        elif proj == "y":
            map = np.reshape(map, (nx, nz))
            #map2 = np.reshape(map2, (nx, nz))
            #map3 = np.reshape(map3, (nx, nz))
            nl = ny
        elif proj == "z":
            map = np.reshape(map, (ny, nx))
            #map2 = np.reshape(map2, (ny, nx))
            #map3 = np.reshape(map3, (ny, nx))
            nl = nz

        print('file loaded')
        # sys.exit()

        # for i in range(len(map[0, :])):
        #    for j in range(len(map[:, 0])):
        #        if (map[i, j] == 0):
        #            map[i, j] = np.nan

        # map2 = np.loadtxt("map_2000px_z_ne_los_cleanall+T1e5_highr.txt")
        # for i in range(len(map2[0, :])):
        #    for j in range(len(map2[:, 0])):
        # if (map2[i, j] == 0):
        #    map2[i, j] = 1e-50

        # map-=map2
        print(map)
        print("min=", np.min(map))
        print("max=", np.max(map))

        return map

    def ew_maps_plot():
        map_vx = load_map('./maps/high_res/velocity/map_high_16f16_x_map_vx_ew_5Mpc2.bin','x')
        map_vy = load_map('./maps/high_res/velocity/map_high_16f16_y_map_vy_ew_5Mpc2.bin','y')
        map_vz = load_map('./maps/high_res/velocity/map_high_16f16_z_map_vz_ew_5Mpc2.bin','z')

        #map_vx = load_map('./maps/high_res/velocity/map_high_16f16_x_map_vx_mw_5Mpc2.bin','x')
        #map_vy = load_map('./maps/high_res/velocity/map_high_16f16_y_map_vy_mw_5Mpc2.bin','y')
        #map_vz = load_map('./maps/high_res/velocity/map_high_16f16_z_map_vz_mw_5Mpc2.bin','z')

        #print("test")
        #sys.exit()

        min_x = 0
        max_x = len(map_vx[:, 0])
        print("max", max_x)
        min_y = 0
        max_y = len(map_vx[0, :])

        cen_x = int(max_x / 2)
        cen_y = int(max_y / 2)

        print(cen_x, cen_y)

        #d = np.array([[np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 11.2524 for i in range(max_x)] for j in range(max_y)]) #still useful for toy model tests

        #np.save("map_distances_lvl16_proj_vel",d)

        d = np.load("map_distances_lvl16_proj_vel.npy")

        #print(np.shape(d))
        #print(np.min(d),np.max(d))
        #print(n)

        #plt.hist(d,bins=100)
        #plt.show()

        map_vx_rvir = map_vx[d<2147]
        map_vx_r500 = map_vx[d<1087]
        map_vx_500 = map_vx[d<500]
        map_vx_100 = map_vx[d<100]

        map_vy_rvir = map_vy[d<2147]
        map_vy_r500 = map_vy[d<1087]
        map_vy_500 = map_vy[d<500]
        map_vy_100 = map_vy[d<100]

        map_vz_rvir = map_vz[d<21147]
        map_vz_r500 = map_vz[d<1087]
        map_vz_500 = map_vz[d<500]
        map_vz_100 = map_vz[d<100]

        f, axs = plt.subplots(5, 4, figsize=(20, 8), constrained_layout=True)

        large = 1

        if large == 1:
            r1 = 2147
            r2 = 1087
            plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
            pdfrvir = "PDF \n ($R<R_{vir}$)"
            pdfr500 = "PDF \n ($R<R_{500}$)"
            height = 0.0035
            # height = 0.0035

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height = 0.0035

        #vx_r1 = vx[r < r1]
        #vy_r1 = vy[r < r1]
        #vz_r1 = vz[r < r1]

        # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

        # vx_r1 = vx_r1[t[r < r1] < 1e7]

        # meanvx,stdvx = norm.fit(vx_r1)
        # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

        print(
            f"map_vx_rvir stat: mean={np.mean(map_vx_rvir):.4g}, "f"median={np.median(map_vx_rvir):.4g}, "f"std={np.std(map_vx_rvir):.4g}, "f"skewness={skew(map_vx_rvir):.4g}, "f"kurtosis={kurtosis(map_vx_rvir):.4g}")

        # sys.exit()

        print(
            f"map_vy_rvir stat: mean={np.mean(map_vy_rvir):.4g}, "f"median={np.median(map_vy_rvir):.4g}, "f"std={np.std(map_vy_rvir):.4g}, "f"skewness={skew(map_vy_rvir):.4g}, "f"kurtosis={kurtosis(map_vy_rvir):.4g}")
        print(
            f"map_vz_rvir stat: mean={np.mean(map_vz_rvir):.4g}, "f"median={np.median(map_vz_rvir):.4g}, "f"std={np.std(map_vz_rvir):.4g}, "f"skewness={skew(map_vz_rvir):.4g}, "f"kurtosis={kurtosis(map_vz_rvir):.4g}")

        #map_vx_r500 = vx[r < r2]
        #map_vy_r500 = vy[r < r2]
        #map_vz_r500 = vz[r < r2]

        print(
            f"map_vx_r500 stat: mean={np.mean(map_vx_r500):.4g}, "f"median={np.median(map_vx_r500):.4g}, "f"std={np.std(map_vx_r500):.4g}, "f"skewness={skew(map_vx_r500):.4g}, "f"kurtosis={kurtosis(map_vx_r500):.4g}")
        print(
            f"map_vy_r500 stat: mean={np.mean(map_vy_r500):.4g}, "f"median={np.median(map_vy_r500):.4g}, "f"std={np.std(map_vy_r500):.4g}, "f"skewness={skew(map_vy_r500):.4g}, "f"kurtosis={kurtosis(map_vy_r500):.4g}")
        print(
            f"map_vz_r500 stat: mean={np.mean(map_vz_r500):.4g}, "f"median={np.median(map_vz_r500):.4g}, "f"std={np.std(map_vz_r500):.4g}, "f"skewness={skew(map_vz_r500):.4g}, "f"kurtosis={kurtosis(map_vz_r500):.4g}")

        print(
            f"map_vx_500 stat: mean={np.mean(map_vx_500):.4g}, "f"median={np.median(map_vx_500):.4g}, "f"std={np.std(map_vx_500):.4g}, "f"skewness={skew(map_vx_500):.4g}, "f"kurtosis={kurtosis(map_vx_500):.4g}")

        # sys.exit()

        print(
            f"map_vy_500 stat: mean={np.mean(map_vy_500):.4g}, "f"median={np.median(map_vy_500):.4g}, "f"std={np.std(map_vy_500):.4g}, "f"skewness={skew(map_vy_500):.4g}, "f"kurtosis={kurtosis(map_vy_500):.4g}")
        print(
            f"map_vz_500 stat: mean={np.mean(map_vz_500):.4g}, "f"median={np.median(map_vz_500):.4g}, "f"std={np.std(map_vz_500):.4g}, "f"skewness={skew(map_vz_500):.4g}, "f"kurtosis={kurtosis(map_vz_500):.4g}")

        #map_vx_100 = vx[r < r2]
        #map_vy_100 = vy[r < r2]
        #map_vz_100 = vz[r < r2]

        print(
            f"map_vx_100 stat: mean={np.mean(map_vx_100):.4g}, "f"median={np.median(map_vx_100):.4g}, "f"std={np.std(map_vx_100):.4g}, "f"skewness={skew(map_vx_100):.4g}, "f"kurtosis={kurtosis(map_vx_100):.4g}")
        print(
            f"map_vy_100 stat: mean={np.mean(map_vy_100):.4g}, "f"median={np.median(map_vy_100):.4g}, "f"std={np.std(map_vy_100):.4g}, "f"skewness={skew(map_vy_100):.4g}, "f"kurtosis={kurtosis(map_vy_100):.4g}")
        print(
            f"map_vz_100 stat: mean={np.mean(map_vz_100):.4g}, "f"median={np.median(map_vz_100):.4g}, "f"std={np.std(map_vz_100):.4g}, "f"skewness={skew(map_vz_100):.4g}, "f"kurtosis={kurtosis(map_vz_100):.4g}")


        count, bins, _ = axs[0, 0].hist(map_vx_rvir, bins=20, alpha=0.6, color='darkred', density=True)


        # print("count",count)


        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_rvir, count, bins)
        axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[0,0].yscale('log')
        axs[0, 0].set_xlim(-1900, 1900)
        axs[0, 0].set_ylim(0, height)
        # axs[0, 0].set_ylim(0, 1.2e6)
        # axs[0,0].legend(fontsize=10)
        # axs[0, 0].set_title("$V_x$")
        # axs[0,0].set_xlabel("Vx [km/s]")
        # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[0, 0].set_ylabel(pdfrvir)
        axs[0, 0].set_xticks([])
        # axs[0, 0].legend(fontsize=10)

        count, bins, _ = axs[0, 1].hist(map_vy_rvir, bins=20, alpha=0.6, color='darkblue', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_rvir, count, bins)
        axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[0,1].yscale('log')
        axs[0, 1].set_xlim(-1900, 1900)
        axs[0, 1].set_ylim(0, height)
        # axs[0, 1].set_ylim(0, 1.2e6)
        # axs[0,1].legend(fontsize=10)
        # axs[0, 1].set_title("y component")
        axs[0, 1].set_yticks([])
        # axs[0,1].set_xlabel("Vy [km/s]")
        axs[0, 1].set_xticks([])
        # axs[0, 1].legend(fontsize=10)

        count, bins, _ = axs[0, 2].hist(map_vz_rvir, bins=20, alpha=0.6, color='darkgreen', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_rvir, count, bins)
        axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[0,2].yscale('log')
        axs[0, 2].set_xlim(-1900, 1900)
        axs[0, 2].set_ylim(0, height)
        # axs[0, 2].set_ylim(0, 1.2e6)
        # axs[0,2].legend(fontsize=10)
        # axs[0, 2].set_title("z projection")
        # axs[0,2].set_xlabel("Vz [km/s]")
        axs[0, 2].set_yticks([])
        axs[0, 2].set_xticks([])
        # axs[0, 2].legend(fontsize=10)

        axs[0, 3].hist(map_vx_rvir, bins=20, alpha=0.6, color='darkred', label='$V_x$', density=True)
        axs[0, 3].hist(map_vy_rvir, bins=20, alpha=0.6, color='darkblue', label='$V_y$', density=True)
        axs[0, 3].hist(map_vz_rvir, bins=20, alpha=0.6, color='darkgreen', label='$V_z$', density=True)
        axs[0, 3].set_xlim(-1900, 1900)
        axs[0, 3].set_ylim(0, height)
        # axs[0, 3].set_ylim(0, 1.2e6)
        axs[0, 3].set_yticks([])
        axs[0, 3].set_xticks([])
        axs[0, 3].legend(fontsize=10)

        # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        count, bins, _ = axs[1, 0].hist(map_vx_r500, bins=20, alpha=0.6, color='red', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_r500, count, bins)
        axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[1,0].yscale('log')
        axs[1, 0].set_xlim(-1900, 1900)
        axs[1, 0].set_ylim(0, height)
        # axs[1, 0].set_ylim(0, 1.3e4)
        # axs[1,0].legend(fontsize=10)
        # axs[1,0].set_title("x projection")
        # axs[1,0].set_xlabel("Vx [km/s]")
        # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
        axs[1, 0].set_ylabel(pdfr500)
        axs[1, 0].set_xticks([])
        # axs[1, 0].legend(fontsize=10)

        count, bins, _ = axs[1, 1].hist(map_vy_r500, bins=20, alpha=0.6, color='blue', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_r500, count, bins)
        axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[1,1].yscale('log')
        axs[1, 1].set_xlim(-1900, 1900)
        axs[1, 1].set_ylim(0, height)
        # axs[1, 1].set_ylim(0, 1.3e4)
        # axs[1,1].legend(fontsize=10)
        # axs[1,1].set_title("y projection")
        axs[1, 1].set_yticks([])
        # axs[1,1].set_xlabel("Vy [km/s]")
        axs[1, 1].set_xticks([])
        # axs[1, 1].legend(fontsize=10)

        count, bins, _ = axs[1, 2].hist(map_vz_r500, bins=20, alpha=0.6, color='green', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_r500, count, bins)
        axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[1,2].yscale('log')
        axs[1, 2].set_xlim(-1900, 1900)
        axs[1, 2].set_ylim(0, height)
        # axs[1, 2].set_ylim(0, 1.3e4)
        # axs[1,2].legend(fontsize=10)
        # axs[1,2].set_title("z projection")
        # axs[1,2].set_xlabel("Vz [km/s]")
        axs[1, 2].set_yticks([])
        axs[1, 2].set_xticks([])
        # axs[1, 2].legend(fontsize=10)

        axs[1, 3].hist(map_vx_r500, bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
        axs[1, 3].hist(map_vy_r500, bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
        axs[1, 3].hist(map_vz_r500, bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
        axs[1, 3].set_xlim(-1900, 1900)
        axs[1, 3].set_ylim(0, height)
        # axs[1, 3].set_ylim(0, 1.3e4)
        axs[1, 3].set_yticks([])
        axs[1, 3].set_xticks([])
        axs[1, 3].legend(fontsize=10)
        # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        ########################################
        ########################################

        large = 0

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components PDFs within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height1 = 0.004
            height = 0.01

        #vx_r1 = vx[r < r1]
        #vy_r1 = vy[r < r1]
        #vz_r1 = vz[r < r1]

        #vx_r2 = vx[r < r2]
        #vy_r2 = vy[r < r2]
        #vz_r2 = vz[r < r2]

        count, bins, _ = axs[2, 0].hist(map_vx_500, bins=20, alpha=0.6, color='orange', density=True)

        # print("count",count)
        # sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_500, count, bins)
        axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[2,0].yscale('log')
        axs[2, 0].set_xlim(-1900, 1900)
        axs[2, 0].set_ylim(0, height1)
        # axs[2, 0].set_ylim(0, 1.2e6)
        # axs[2,0].legend(fontsize=10)
        # axs[2, 0].set_title("$V_x$")
        # axs[2,0].set_xlabel("Vx [km/s]")
        # axs[2, 0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[2, 0].set_ylabel(pdfrvir)
        axs[2, 0].set_xticks([])
        # axs[2, 0].legend(fontsize=10)

        count, bins, _ = axs[2, 1].hist(map_vy_500, bins=20, alpha=0.6, color='purple', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_500, count, bins)
        axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[2,1].yscale('log')
        axs[2, 1].set_xlim(-1900, 1900)
        axs[2, 1].set_ylim(0, height1)
        # axs[2, 1].set_ylim(0, 1.2e6)
        # axs[2,1].legend(fontsize=10)
        # axs[2, 1].set_title("y component")
        axs[2, 1].set_yticks([])
        # axs[2,1].set_xlabel("Vy [km/s]")
        axs[2, 1].set_xticks([])
        # axs[2, 1].legend(fontsize=10)

        count, bins, _ = axs[2, 2].hist(map_vz_500, bins=20, alpha=0.6, color='turquoise', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_500, count, bins)
        axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[2,2].yscale('log')
        axs[2, 2].set_xlim(-1900, 1900)
        axs[2, 2].set_ylim(0, height1)
        # axs[2, 2].set_ylim(0, 1.2e6)
        # axs[2,2].legend(fontsize=10)
        # axs[2, 2].set_title("z projection")
        # axs[2,2].set_xlabel("Vz [km/s]")
        axs[2, 2].set_yticks([])
        axs[2, 2].set_xticks([])
        # axs[2, 2].legend(fontsize=10)

        axs[2, 3].hist(map_vx_500, bins=20, alpha=0.6, color='orange', label='$V_x$', density=True)
        axs[2, 3].hist(map_vy_500, bins=20, alpha=0.6, color='purple', label='$V_y$', density=True)
        axs[2, 3].hist(map_vz_500, bins=20, alpha=0.6, color='turquoise', label='$V_z$', density=True)
        axs[2, 3].set_xlim(-1900, 1900)
        axs[2, 3].set_ylim(0, height1)
        # axs[2, 3].set_ylim(0, 1.2e6)
        axs[2, 3].set_yticks([])
        axs[2, 3].set_xticks([])
        axs[2, 3].legend(fontsize=10)

        # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[2, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        count, bins, _ = axs[3, 0].hist(map_vx_100, bins=10, alpha=0.6, color='gold', density=True)

        #print("max count", np.max(count))
        #sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_100, count, bins)
        axs[3, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[3,0].yscale('log')
        axs[3, 0].set_xlim(-1900, 1900)
        axs[3, 0].set_ylim(0, height1)
        # axs[3, 0].set_ylim(0, 1.3e4)
        # axs[3,0].legend(fontsize=10)
        # axs[3,0].set_title("x projection")
        # axs[3,0].set_xlabel("Vx [km/s]")
        # axs[3, 0].set_ylabel("PDF ($R<R_{500}$)")
        axs[3, 0].set_ylabel(pdfr500)
        axs[3, 0].set_xticks([])
        # axs[3, 0].legend(fontsize=10)

        count, bins, _ = axs[3, 1].hist(map_vy_100, bins=10, alpha=0.6, color='pink', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_100, count, bins)
        axs[3, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[3,1].yscale('log')
        axs[3, 1].set_xlim(-1900, 1900)
        axs[3, 1].set_ylim(0, height1)
        # axs[3, 1].set_ylim(0, 1.3e4)
        # axs[3,1].legend(fontsize=10)
        # axs[3,1].set_title("y projection")
        axs[3, 1].set_yticks([])
        # axs[3,1].set_xlabel("Vy [km/s]")
        axs[3, 1].set_xticks([])
        # axs[3, 1].legend(fontsize=10)

        count, bins, _ = axs[3, 2].hist(map_vz_100, bins=10, alpha=0.6, color='cyan', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_100, count, bins)
        axs[3, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[3,2].yscale('log')
        axs[3, 2].set_xlim(-1900, 1900)
        axs[3, 2].set_ylim(0, height1)
        # axs[3, 2].set_ylim(0, 1.3e4)
        # axs[3,2].legend(fontsize=10)
        # axs[3,2].set_title("z projection")
        # axs[3,2].set_xlabel("Vz [km/s]")
        axs[3, 2].set_yticks([])
        axs[3, 2].set_xticks([])
        # axs[3, 2].legend(fontsize=10)

        axs[3, 3].hist(map_vx_100, bins=10, alpha=0.6, color='gold', label='$V_x$', density=True)
        axs[3, 3].hist(map_vy_100, bins=10, alpha=0.6, color='pink', label='$V_y$', density=True)
        axs[3, 3].hist(map_vz_100, bins=10, alpha=0.6, color='cyan', label='$V_z$', density=True)
        axs[3, 3].set_xlim(-1900, 1900)
        axs[3, 3].set_ylim(0, height)
        # axs[3, 3].set_ylim(0, 1.3e4)
        axs[3, 3].set_yticks([])
        axs[3, 3].legend(fontsize=10)
        # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[3, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        ########################################
        ########################################

        rvir = 2147
        r500 = 1087

        axs[4, 0].hist(map_vx_rvir, bins=20, alpha=0.6, color='darkred', label='$R<R_{vir}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 0].hist(map_vx_r500, bins=20, alpha=0.6, color='red', label='$R<R_{500}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 0].hist(map_vx_500, bins=20, alpha=0.6, color='orange', label='$R<500kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 0].hist(map_vx_100, bins=10, alpha=0.6, color='gold', label='$R<100kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        # axs[4,0].yscale('log')
        axs[4, 0].set_xlim(-1900, 1900)
        axs[4, 0].set_ylim(0, height)
        # axs[4, 0].set_ylim(0, 700)
        # axs[4,0].legend(fontsize=10)
        # axs[4,0].set_title("x projection")
        axs[4, 0].set_xlabel("Vx [km/s]")
        axs[4, 0].set_ylabel("PDF")
        axs[4, 0].legend(fontsize=10)
        # axs[4, 0].set_yscale('log')

        axs[4, 1].hist(map_vy_rvir, bins=20, alpha=0.6, color='darkblue', label='$R<R_{vir}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 1].hist(map_vy_r500, bins=20, alpha=0.6, color='blue', label='$R<R_{500}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 1].hist(map_vy_500, bins=20, alpha=0.6, color='purple', label='$R<500kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 1].hist(map_vy_100, bins=10, alpha=0.6, color='pink', label='$R<100kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        # xs[4,1].yscale('log')
        axs[4, 1].set_xlim(-1900, 1900)
        axs[4, 1].set_ylim(0, height)
        # axs[4, 1].set_ylim(0, 700)
        # axs[4,1].legend(fontsize=10)
        # axs[4,1].set_title("y projection")
        axs[4, 1].set_yticks([])
        axs[4, 1].set_xlabel("Vy [km/s]")
        axs[4, 1].legend(fontsize=10)
        # axs[4, 1].set_yscale('log')

        axs[4, 2].hist(map_vz_rvir, bins=20, alpha=0.6, color='darkgreen', label='$R<R_{vir}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 2].hist(map_vz_r500, bins=20, alpha=0.6, color='green', label='$R<R_{500}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 2].hist(map_vz_500, bins=20, alpha=0.6, color='turquoise', label='$R<500kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 2].hist(map_vz_100, bins=10, alpha=0.6, color='cyan', label='$R<100kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        # axs[4,2].yscale('log')
        axs[4, 2].set_xlim(-1900, 1900)
        axs[4, 2].set_ylim(0, height)
        # axs[4, 2].set_ylim(0, 700)
        # axs[4,2].legend(fontsize=10)
        # axs[4,2].set_title("z projection")
        axs[4, 2].set_xlabel("Vz [km/s]")
        axs[4, 2].set_yticks([])
        axs[4, 2].legend(fontsize=10)
        # axs[4, 2].set_yscale('log')

        # axs[3].yscale('log')

        # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
        # plt.grid(b=None)
        plt.legend()
        # plt.ylabel("PDF")
        axs[3, 3].set_xlabel("V [km/s]")

        axs[4, 3].axis("off")

        # plt.yscale('log')
        # plt.title("Vz distribution on ew sightline velocity along z axis")
        # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

        plt.suptitle("EW Projected velocity distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii circles")

    def mw_maps_plot():
        #map_vx = load_map('./maps/high_res/velocity/map_high_16f16_x_map_vx_ew_5Mpc2.bin', 'x')
        #map_vy = load_map('./maps/high_res/velocity/map_high_16f16_y_map_vy_ew_5Mpc2.bin', 'y')
        #map_vz = load_map('./maps/high_res/velocity/map_high_16f16_z_map_vz_ew_5Mpc2.bin', 'z')

        map_vx = load_map('./maps/high_res/velocity/map_high_16f16_x_map_vx_mw_5Mpc2.bin','x')
        map_vy = load_map('./maps/high_res/velocity/map_high_16f16_y_map_vy_mw_5Mpc2.bin','y')
        map_vz = load_map('./maps/high_res/velocity/map_high_16f16_z_map_vz_mw_5Mpc2.bin','z')

        # print("test")
        # sys.exit()

        min_x = 0
        max_x = len(map_vx[:, 0])
        print("max", max_x)
        min_y = 0
        max_y = len(map_vx[0, :])

        cen_x = int(max_x / 2)
        cen_y = int(max_y / 2)

        print(cen_x, cen_y)

        # d = np.array([[np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 11.2524 for i in range(max_x)] for j in range(max_y)]) #still useful for toy model tests

        # np.save("map_distances_lvl16_proj_vel",d)

        d = np.load("map_distances_lvl16_proj_vel.npy")

        # print(np.shape(d))
        # print(np.min(d),np.max(d))
        # print(n)

        # plt.hist(d,bins=100)
        # plt.show()

        map_vx_rvir = map_vx[d < 2147]
        map_vx_r500 = map_vx[d < 1087]
        map_vx_500 = map_vx[d < 500]
        map_vx_100 = map_vx[d < 100]

        map_vy_rvir = map_vy[d < 2147]
        map_vy_r500 = map_vy[d < 1087]
        map_vy_500 = map_vy[d < 500]
        map_vy_100 = map_vy[d < 100]

        map_vz_rvir = map_vz[d < 21147]
        map_vz_r500 = map_vz[d < 1087]
        map_vz_500 = map_vz[d < 500]
        map_vz_100 = map_vz[d < 100]

        f, axs = plt.subplots(5, 4, figsize=(20, 8), constrained_layout=True)

        large = 1

        if large == 1:
            r1 = 2147
            r2 = 1087
            plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
            pdfrvir = "PDF \n ($R<R_{vir}$)"
            pdfr500 = "PDF \n ($R<R_{500}$)"
            height = 0.0035
            # height = 0.0035

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height = 0.0035

        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

        # vx_r1 = vx_r1[t[r < r1] < 1e7]

        # meanvx,stdvx = norm.fit(vx_r1)
        # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

        print(
            f"map_vx_rvir stat:{np.median(map_vx_rvir):.4g}, "f" & {np.mean(map_vx_rvir):.4g}, "f" & {np.std(map_vx_rvir):.4g}, "f" & {skew(map_vx_rvir):.4g}, "f" & {kurtosis(map_vx_rvir):.4g}")

        print(
            f"map_vy_rvir stat:{np.median(map_vy_rvir):.4g}, "f" & {np.mean(map_vy_rvir):.4g}, "f" & {np.std(map_vy_rvir):.4g}, "f" & {skew(map_vy_rvir):.4g}, "f" & {kurtosis(map_vy_rvir):.4g}")

        print(
            f"map_vz_rvir stat:{np.median(map_vz_rvir):.4g}, "f" & {np.mean(map_vz_rvir):.4g}, "f" & {np.std(map_vz_rvir):.4g}, "f" & {skew(map_vz_rvir):.4g}, "f" & {kurtosis(map_vz_rvir):.4g}")


        #sys.exit()

        # map_vx_r500 = vx[r < r2]
        # map_vy_r500 = vy[r < r2]
        # map_vz_r500 = vz[r < r2]


        print(
            f"map_vx_r500 stat:{np.median(map_vx_r500):.4g}, "f" & {np.mean(map_vx_r500):.4g}, "f" & {np.std(map_vx_r500):.4g}, "f" & {skew(map_vx_r500):.4g}, "f" & {kurtosis(map_vx_r500):.4g}")

        print(
            f"map_vy_r500 stat:{np.median(map_vy_r500):.4g}, "f" & {np.mean(map_vy_r500):.4g}, "f" & {np.std(map_vy_r500):.4g}, "f" & {skew(map_vy_r500):.4g}, "f" & {kurtosis(map_vy_r500):.4g}")

        print(
            f"map_vz_r500 stat:{np.median(map_vz_r500):.4g}, "f" & {np.mean(map_vz_r500):.4g}, "f" & {np.std(map_vz_r500):.4g}, "f" & {skew(map_vz_r500):.4g}, "f" & {kurtosis(map_vz_r500):.4g}")


        print(
            f"map_vx_500 stat:{np.median(map_vx_500):.4g}, "f" & {np.mean(map_vx_500):.4g}, "f" & {np.std(map_vx_500):.4g}, "f" & {skew(map_vx_500):.4g}, "f" & {kurtosis(map_vx_500):.4g}")

        print(
            f"map_vy_500 stat:{np.median(map_vy_500):.4g}, "f" & {np.mean(map_vy_500):.4g}, "f" & {np.std(map_vy_500):.4g}, "f" & {skew(map_vy_500):.4g}, "f" & {kurtosis(map_vy_500):.4g}")

        print(
            f"map_vz_500 stat:{np.median(map_vz_500):.4g}, "f" & {np.mean(map_vz_500):.4g}, "f" & {np.std(map_vz_500):.4g}, "f" & {skew(map_vz_500):.4g}, "f" & {kurtosis(map_vz_500):.4g}")

        # map_vx_100 = vx[r < r2]
        # map_vy_100 = vy[r < r2]
        # map_vz_100 = vz[r < r2]

        print(
            f"map_vx_100 stat:{np.median(map_vx_100):.4g}, "f" & {np.mean(map_vx_100):.4g}, "f" & {np.std(map_vx_100):.4g}, "f" & {skew(map_vx_100):.4g}, "f" & {kurtosis(map_vx_100):.4g}")

        print(
            f"map_vy_100 stat:{np.median(map_vy_100):.4g}, "f" & {np.mean(map_vy_100):.4g}, "f" & {np.std(map_vy_100):.4g}, "f" & {skew(map_vy_100):.4g}, "f" & {kurtosis(map_vy_100):.4g}")

        print(
            f"map_vz_100 stat:{np.median(map_vz_100):.4g}, "f" & {np.mean(map_vz_100):.4g}, "f" & {np.std(map_vz_100):.4g}, "f" & {skew(map_vz_100):.4g}, "f" & {kurtosis(map_vz_100):.4g}")

        #sys.exit()

        count, bins, _ = axs[0, 0].hist(map_vx_rvir, bins=20, alpha=0.6, color='darkred', density=True)

        # print("count",count)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_rvir, count, bins)
        axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[0,0].yscale('log')
        axs[0, 0].set_xlim(-1900, 1900)
        axs[0, 0].set_ylim(0, height)
        # axs[0, 0].set_ylim(0, 1.2e6)
        # axs[0,0].legend(fontsize=10)
        # axs[0, 0].set_title("$V_x$")
        # axs[0,0].set_xlabel("Vx [km/s]")
        # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[0, 0].set_ylabel(pdfrvir)
        axs[0, 0].set_xticks([])
        # axs[0, 0].legend(fontsize=10)

        count, bins, _ = axs[0, 1].hist(map_vy_rvir, bins=20, alpha=0.6, color='darkblue', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_rvir, count, bins)
        axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[0,1].yscale('log')
        axs[0, 1].set_xlim(-1900, 1900)
        axs[0, 1].set_ylim(0, height)
        # axs[0, 1].set_ylim(0, 1.2e6)
        # axs[0,1].legend(fontsize=10)
        # axs[0, 1].set_title("y component")
        axs[0, 1].set_yticks([])
        # axs[0,1].set_xlabel("Vy [km/s]")
        axs[0, 1].set_xticks([])
        # axs[0, 1].legend(fontsize=10)

        count, bins, _ = axs[0, 2].hist(map_vz_rvir, bins=20, alpha=0.6, color='darkgreen', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_rvir, count, bins)
        axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[0,2].yscale('log')
        axs[0, 2].set_xlim(-1900, 1900)
        axs[0, 2].set_ylim(0, height)
        # axs[0, 2].set_ylim(0, 1.2e6)
        # axs[0,2].legend(fontsize=10)
        # axs[0, 2].set_title("z projection")
        # axs[0,2].set_xlabel("Vz [km/s]")
        axs[0, 2].set_yticks([])
        axs[0, 2].set_xticks([])
        # axs[0, 2].legend(fontsize=10)

        axs[0, 3].hist(map_vx_rvir, bins=20, alpha=0.6, color='darkred', label='$V_x$', density=True)
        axs[0, 3].hist(map_vy_rvir, bins=20, alpha=0.6, color='darkblue', label='$V_y$', density=True)
        axs[0, 3].hist(map_vz_rvir, bins=20, alpha=0.6, color='darkgreen', label='$V_z$', density=True)
        axs[0, 3].set_xlim(-1900, 1900)
        axs[0, 3].set_ylim(0, height)
        # axs[0, 3].set_ylim(0, 1.2e6)
        axs[0, 3].set_yticks([])
        axs[0, 3].set_xticks([])
        axs[0, 3].legend(fontsize=10)

        # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        count, bins, _ = axs[1, 0].hist(map_vx_r500, bins=20, alpha=0.6, color='red', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_r500, count, bins)
        axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[1,0].yscale('log')
        axs[1, 0].set_xlim(-1900, 1900)
        axs[1, 0].set_ylim(0, height)
        # axs[1, 0].set_ylim(0, 1.3e4)
        # axs[1,0].legend(fontsize=10)
        # axs[1,0].set_title("x projection")
        # axs[1,0].set_xlabel("Vx [km/s]")
        # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
        axs[1, 0].set_ylabel(pdfr500)
        axs[1, 0].set_xticks([])
        # axs[1, 0].legend(fontsize=10)

        count, bins, _ = axs[1, 1].hist(map_vy_r500, bins=20, alpha=0.6, color='blue', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_r500, count, bins)
        axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[1,1].yscale('log')
        axs[1, 1].set_xlim(-1900, 1900)
        axs[1, 1].set_ylim(0, height)
        # axs[1, 1].set_ylim(0, 1.3e4)
        # axs[1,1].legend(fontsize=10)
        # axs[1,1].set_title("y projection")
        axs[1, 1].set_yticks([])
        # axs[1,1].set_xlabel("Vy [km/s]")
        axs[1, 1].set_xticks([])
        # axs[1, 1].legend(fontsize=10)

        count, bins, _ = axs[1, 2].hist(map_vz_r500, bins=20, alpha=0.6, color='green', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_r500, count, bins)
        axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[1,2].yscale('log')
        axs[1, 2].set_xlim(-1900, 1900)
        axs[1, 2].set_ylim(0, height)
        # axs[1, 2].set_ylim(0, 1.3e4)
        # axs[1,2].legend(fontsize=10)
        # axs[1,2].set_title("z projection")
        # axs[1,2].set_xlabel("Vz [km/s]")
        axs[1, 2].set_yticks([])
        axs[1, 2].set_xticks([])
        # axs[1, 2].legend(fontsize=10)

        axs[1, 3].hist(map_vx_r500, bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
        axs[1, 3].hist(map_vy_r500, bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
        axs[1, 3].hist(map_vz_r500, bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
        axs[1, 3].set_xlim(-1900, 1900)
        axs[1, 3].set_ylim(0, height)
        # axs[1, 3].set_ylim(0, 1.3e4)
        axs[1, 3].set_yticks([])
        axs[1, 3].set_xticks([])
        axs[1, 3].legend(fontsize=10)
        # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        ########################################
        ########################################

        large = 0

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components PDFs within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height1 = 0.004
            height = 0.01

        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # vx_r2 = vx[r < r2]
        # vy_r2 = vy[r < r2]
        # vz_r2 = vz[r < r2]

        count, bins, _ = axs[2, 0].hist(map_vx_500, bins=20, alpha=0.6, color='orange', density=True)

        # print("count",count)
        # sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_500, count, bins)
        axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[2,0].yscale('log')
        axs[2, 0].set_xlim(-1900, 1900)
        axs[2, 0].set_ylim(0, height1)
        # axs[2, 0].set_ylim(0, 1.2e6)
        # axs[2,0].legend(fontsize=10)
        # axs[2, 0].set_title("$V_x$")
        # axs[2,0].set_xlabel("Vx [km/s]")
        # axs[2, 0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[2, 0].set_ylabel(pdfrvir)
        axs[2, 0].set_xticks([])
        # axs[2, 0].legend(fontsize=10)

        count, bins, _ = axs[2, 1].hist(map_vy_500, bins=20, alpha=0.6, color='purple', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_500, count, bins)
        axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[2,1].yscale('log')
        axs[2, 1].set_xlim(-1900, 1900)
        axs[2, 1].set_ylim(0, height1)
        # axs[2, 1].set_ylim(0, 1.2e6)
        # axs[2,1].legend(fontsize=10)
        # axs[2, 1].set_title("y component")
        axs[2, 1].set_yticks([])
        # axs[2,1].set_xlabel("Vy [km/s]")
        axs[2, 1].set_xticks([])
        # axs[2, 1].legend(fontsize=10)

        count, bins, _ = axs[2, 2].hist(map_vz_500, bins=20, alpha=0.6, color='turquoise', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_500, count, bins)
        axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[2,2].yscale('log')
        axs[2, 2].set_xlim(-1900, 1900)
        axs[2, 2].set_ylim(0, height1)
        # axs[2, 2].set_ylim(0, 1.2e6)
        # axs[2,2].legend(fontsize=10)
        # axs[2, 2].set_title("z projection")
        # axs[2,2].set_xlabel("Vz [km/s]")
        axs[2, 2].set_yticks([])
        axs[2, 2].set_xticks([])
        # axs[2, 2].legend(fontsize=10)

        axs[2, 3].hist(map_vx_500, bins=20, alpha=0.6, color='orange', label='$V_x$', density=True)
        axs[2, 3].hist(map_vy_500, bins=20, alpha=0.6, color='purple', label='$V_y$', density=True)
        axs[2, 3].hist(map_vz_500, bins=20, alpha=0.6, color='turquoise', label='$V_z$', density=True)
        axs[2, 3].set_xlim(-1900, 1900)
        axs[2, 3].set_ylim(0, height1)
        # axs[2, 3].set_ylim(0, 1.2e6)
        axs[2, 3].set_yticks([])
        axs[2, 3].set_xticks([])
        axs[2, 3].legend(fontsize=10)

        # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[2, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        count, bins, _ = axs[3, 0].hist(map_vx_100, bins=10, alpha=0.6, color='gold', density=True)

        # print("max count", np.max(count))
        # sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_100, count, bins)
        axs[3, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[3,0].yscale('log')
        axs[3, 0].set_xlim(-1900, 1900)
        axs[3, 0].set_ylim(0, height)
        # axs[3, 0].set_ylim(0, 1.3e4)
        # axs[3,0].legend(fontsize=10)
        # axs[3,0].set_title("x projection")
        # axs[3,0].set_xlabel("Vx [km/s]")
        # axs[3, 0].set_ylabel("PDF ($R<R_{500}$)")
        axs[3, 0].set_ylabel(pdfr500)
        axs[3, 0].set_xticks([])
        # axs[3, 0].legend(fontsize=10)

        count, bins, _ = axs[3, 1].hist(map_vy_100, bins=10, alpha=0.6, color='pink', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_100, count, bins)
        axs[3, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[3,1].yscale('log')
        axs[3, 1].set_xlim(-1900, 1900)
        axs[3, 1].set_ylim(0, height)
        # axs[3, 1].set_ylim(0, 1.3e4)
        # axs[3,1].legend(fontsize=10)
        # axs[3,1].set_title("y projection")
        axs[3, 1].set_yticks([])
        # axs[3,1].set_xlabel("Vy [km/s]")
        axs[3, 1].set_xticks([])
        # axs[3, 1].legend(fontsize=10)

        count, bins, _ = axs[3, 2].hist(map_vz_100, bins=10, alpha=0.6, color='cyan', density=True)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_100, count, bins)
        axs[3, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                       label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                           popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[3,2].yscale('log')
        axs[3, 2].set_xlim(-1900, 1900)
        axs[3, 2].set_ylim(0, height)
        # axs[3, 2].set_ylim(0, 1.3e4)
        # axs[3,2].legend(fontsize=10)
        # axs[3,2].set_title("z projection")
        # axs[3,2].set_xlabel("Vz [km/s]")
        axs[3, 2].set_yticks([])
        axs[3, 2].set_xticks([])
        # axs[3, 2].legend(fontsize=10)

        axs[3, 3].hist(map_vx_100, bins=10, alpha=0.6, color='gold', label='$V_x$', density=True)
        axs[3, 3].hist(map_vy_100, bins=10, alpha=0.6, color='pink', label='$V_y$', density=True)
        axs[3, 3].hist(map_vz_100, bins=10, alpha=0.6, color='cyan', label='$V_z$', density=True)
        axs[3, 3].set_xlim(-1900, 1900)
        axs[3, 3].set_ylim(0, height)
        # axs[3, 3].set_ylim(0, 1.3e4)
        axs[3, 3].set_yticks([])
        axs[3, 3].legend(fontsize=10)
        # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[3, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        ########################################
        ########################################

        rvir = 2147
        r500 = 1087

        axs[4, 0].hist(map_vx_rvir, bins=20, alpha=0.6, color='darkred', label='$R<R_{vir}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 0].hist(map_vx_r500, bins=20, alpha=0.6, color='red', label='$R<R_{500}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 0].hist(map_vx_500, bins=20, alpha=0.6, color='orange', label='$R<500kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 0].hist(map_vx_100, bins=10, alpha=0.6, color='gold', label='$R<100kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        # axs[4,0].yscale('log')
        axs[4, 0].set_xlim(-1900, 1900)
        axs[4, 0].set_ylim(0, height)
        # axs[4, 0].set_ylim(0, 700)
        # axs[4,0].legend(fontsize=10)
        # axs[4,0].set_title("x projection")
        axs[4, 0].set_xlabel("Vx [km/s]")
        axs[4, 0].set_ylabel("PDF")
        axs[4, 0].legend(fontsize=10)
        # axs[4, 0].set_yscale('log')

        axs[4, 1].hist(map_vy_rvir, bins=20, alpha=0.6, color='darkblue', label='$R<R_{vir}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 1].hist(map_vy_r500, bins=20, alpha=0.6, color='blue', label='$R<R_{500}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 1].hist(map_vy_500, bins=20, alpha=0.6, color='purple', label='$R<500kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 1].hist(map_vy_100, bins=10, alpha=0.6, color='pink', label='$R<100kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        # xs[4,1].yscale('log')
        axs[4, 1].set_xlim(-1900, 1900)
        axs[4, 1].set_ylim(0, height)
        # axs[4, 1].set_ylim(0, 700)
        # axs[4,1].legend(fontsize=10)
        # axs[4,1].set_title("y projection")
        axs[4, 1].set_yticks([])
        axs[4, 1].set_xlabel("Vy [km/s]")
        axs[4, 1].legend(fontsize=10)
        # axs[4, 1].set_yscale('log')

        axs[4, 2].hist(map_vz_rvir, bins=20, alpha=0.6, color='darkgreen', label='$R<R_{vir}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 2].hist(map_vz_r500, bins=20, alpha=0.6, color='green', label='$R<R_{500}$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 2].hist(map_vz_500, bins=20, alpha=0.6, color='turquoise', label='$R<500kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        axs[4, 2].hist(map_vz_100, bins=10, alpha=0.6, color='cyan', label='$R<100kpc$',
                       density=True)  # ,histtype='step',linewidth=2)
        # axs[4,2].yscale('log')
        axs[4, 2].set_xlim(-1900, 1900)
        axs[4, 2].set_ylim(0, height)
        # axs[4, 2].set_ylim(0, 700)
        # axs[4,2].legend(fontsize=10)
        # axs[4,2].set_title("z projection")
        axs[4, 2].set_xlabel("Vz [km/s]")
        axs[4, 2].set_yticks([])
        axs[4, 2].legend(fontsize=10)
        # axs[4, 2].set_yscale('log')

        # axs[3].yscale('log')

        # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
        # plt.grid(b=None)
        plt.legend()
        # plt.ylabel("PDF")
        axs[3, 3].set_xlabel("V [km/s]")

        axs[4, 3].axis("off")

        # plt.yscale('log')
        # plt.title("Vz distribution on ew sightline velocity along z axis")
        # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

        plt.suptitle("MW Projected velocity distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii circles")

    def mw_vs_ew_plot():
        map_vx_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_ew_Tsup7_5Mpc2.bin', 'x')
        map_vy_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_ew_Tsup7_5Mpc2.bin', 'y')
        map_vz_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_ew_Tsup7_5Mpc2.bin', 'z')


        map_vx_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_mw_Tsup7_5Mpc2.bin','x')
        map_vy_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_mw_Tsup7_5Mpc2.bin','y')
        map_vz_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_mw_Tsup7_5Mpc2.bin','z')

        map_vcen_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_ew_Tsup7_5Mpc2.bin', 'z')
        map_vcen_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_mw_Tsup7_5Mpc2.bin', 'z')

        # print("test")
        # sys.exit()

        min_x = 0
        max_x = len(map_vx_ew[:, 0])
        print("max", max_x)
        min_y = 0
        max_y = len(map_vx_ew[0, :])

        cen_x = int(max_x / 2)
        cen_y = int(max_y / 2)

        print(cen_x, cen_y)

        d = np.array([[np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 22.5049 for i in range(max_x)] for j in range(max_y)]) #still useful for toy model tests

        #np.save("map_distances_lvl15_proj_vel",d)

        #print("dist file saved")

        d = np.load("map_distances_lvl15_proj_vel.npy")

        # print(np.shape(d))
        # print(np.min(d),np.max(d))
        # print(n)

        # plt.hist(d,bins=100)
        # plt.show()

        map_vx_ew_rvir = map_vx_ew[d < 2147]
        map_vx_ew_r500 = map_vx_ew[d < 1087]
        map_vx_ew_500 = map_vx_ew[d < 500]
        map_vx_ew_100 = map_vx_ew[d < 100]

        map_vy_ew_rvir = map_vy_ew[d < 2147]
        map_vy_ew_r500 = map_vy_ew[d < 1087]
        map_vy_ew_500 = map_vy_ew[d < 500]
        map_vy_ew_100 = map_vy_ew[d < 100]

        map_vz_ew_rvir = map_vz_ew[d < 2147]
        map_vz_ew_r500 = map_vz_ew[d < 1087]
        map_vz_ew_500 = map_vz_ew[d < 500]
        map_vz_ew_100 = map_vz_ew[d < 100]

        #############################

        map_vx_mw_rvir = map_vx_mw[d < 2147]
        map_vx_mw_r500 = map_vx_mw[d < 1087]
        map_vx_mw_500 = map_vx_mw[d < 500]
        map_vx_mw_100 = map_vx_mw[d < 100]

        map_vy_mw_rvir = map_vy_mw[d < 2147]
        map_vy_mw_r500 = map_vy_mw[d < 1087]
        map_vy_mw_500 = map_vy_mw[d < 500]
        map_vy_mw_100 = map_vy_mw[d < 100]

        map_vz_mw_rvir = map_vz_mw[d < 2147]
        map_vz_mw_r500 = map_vz_mw[d < 1087]
        map_vz_mw_500 = map_vz_mw[d < 500]
        map_vz_mw_100 = map_vz_mw[d < 100]

        #################################

        map_vcen_ew_rvir = map_vcen_ew[d < 2147]
        map_vcen_ew_r500 = map_vcen_ew[d < 1087]
        map_vcen_ew_500 = map_vcen_ew[d < 500]
        map_vcen_ew_100 = map_vcen_ew[d < 100]

        map_vcen_mw_rvir = map_vcen_mw[d < 2147]
        map_vcen_mw_r500 = map_vcen_mw[d < 1087]
        map_vcen_mw_500 = map_vcen_mw[d < 500]
        map_vcen_mw_100 = map_vcen_mw[d < 100]

        print(f"map_vcen_ew_rvir stat: mean={np.mean(map_vcen_ew_rvir):.4g}, "f"median={np.median(map_vcen_ew_rvir):.4g}, "f"std={np.std(map_vcen_ew_rvir):.4g}, "f"skewness={skew(map_vcen_ew_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_rvir):.4g}")
        print(f"map_vcen_mw_rvir stat: mean={np.mean(map_vcen_mw_rvir):.4g}, "f"median={np.median(map_vcen_mw_rvir):.4g}, "f"std={np.std(map_vcen_mw_rvir):.4g}, "f"skewness={skew(map_vcen_mw_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_rvir):.4g}")
        print(f"map_vcen_ew_r500 stat: mean={np.mean(map_vcen_ew_r500):.4g}, "f"median={np.median(map_vcen_ew_r500):.4g}, "f"std={np.std(map_vcen_ew_r500):.4g}, "f"skewness={skew(map_vcen_ew_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_r500):.4g}")
        print(f"map_vcen_mw_r500 stat: mean={np.mean(map_vcen_mw_r500):.4g}, "f"median={np.median(map_vcen_mw_r500):.4g}, "f"std={np.std(map_vcen_mw_r500):.4g}, "f"skewness={skew(map_vcen_mw_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_r500):.4g}")
        print(f"map_vcen_ew_500 stat: mean={np.mean(map_vcen_ew_500):.4g}, "f"median={np.median(map_vcen_ew_500):.4g}, "f"std={np.std(map_vcen_ew_500):.4g}, "f"skewness={skew(map_vcen_ew_500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_500):.4g}")
        print(f"map_vcen_mw_500 stat: mean={np.mean(map_vcen_mw_500):.4g}, "f"median={np.median(map_vcen_mw_500):.4g}, "f"std={np.std(map_vcen_mw_500):.4g}, "f"skewness={skew(map_vcen_mw_500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_500):.4g}")
        print(f"map_vcen_ew_100 stat: mean={np.mean(map_vcen_ew_100):.4g}, "f"median={np.median(map_vcen_ew_100):.4g}, "f"std={np.std(map_vcen_ew_100):.4g}, "f"skewness={skew(map_vcen_ew_100):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_100):.4g}")
        print(f"map_vcen_mw_100 stat: mean={np.mean(map_vcen_mw_100):.4g}, "f"median={np.median(map_vcen_mw_100):.4g}, "f"std={np.std(map_vcen_mw_100):.4g}, "f"skewness={skew(map_vcen_mw_100):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_100):.4g}")

        #sys.exit()
        f, axs = plt.subplots(4, 4, figsize=(10, 8), constrained_layout=True,gridspec_kw = {'wspace':0, 'hspace':0})

        large = 1

        if large == 1:
            r1 = 2147
            r2 = 1087
            plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
            pdfrvir = "PDF \n ($R<R_{vir}$)"
            pdfr500 = "PDF \n ($R<R_{500}$)"
            height = 0.004
            # height = 0.0035

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height = 0.0035


        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

        # vx_r1 = vx_r1[t[r < r1] < 1e7]

        # meanvx,stdvx = norm.fit(vx_r1)
        # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

        #print(
        #    f"map_vx_rvir stat: mean={np.mean(map_vx_rvir):.4g}, "f"median={np.median(map_vx_rvir):.4g}, "f"std={np.std(map_vx_rvir):.4g}, "f"skewness={skew(map_vx_rvir):.4g}, "f"kurtosis={kurtosis(map_vx_rvir):.4g}")

        # sys.exit()

        #print(
        #    f"map_vy_rvir stat: mean={np.mean(map_vy_rvir):.4g}, "f"median={np.median(map_vy_rvir):.4g}, "f"std={np.std(map_vy_rvir):.4g}, "f"skewness={skew(map_vy_rvir):.4g}, "f"kurtosis={kurtosis(map_vy_rvir):.4g}")
        #print(
        #    f"map_vz_rvir stat: mean={np.mean(map_vz_rvir):.4g}, "f"median={np.median(map_vz_rvir):.4g}, "f"std={np.std(map_vz_rvir):.4g}, "f"skewness={skew(map_vz_rvir):.4g}, "f"kurtosis={kurtosis(map_vz_rvir):.4g}")

        # map_vx_r500 = vx[r < r2]
        # map_vy_r500 = vy[r < r2]
        # map_vz_r500 = vz[r < r2]

        #print(
        #    f"map_vx_r500 stat: mean={np.mean(map_vx_r500):.4g}, "f"median={np.median(map_vx_r500):.4g}, "f"std={np.std(map_vx_r500):.4g}, "f"skewness={skew(map_vx_r500):.4g}, "f"kurtosis={kurtosis(map_vx_r500):.4g}")
        #print(
        #    f"map_vy_r500 stat: mean={np.mean(map_vy_r500):.4g}, "f"median={np.median(map_vy_r500):.4g}, "f"std={np.std(map_vy_r500):.4g}, "f"skewness={skew(map_vy_r500):.4g}, "f"kurtosis={kurtosis(map_vy_r500):.4g}")
        #print(
        #    f"map_vz_r500 stat: mean={np.mean(map_vz_r500):.4g}, "f"median={np.median(map_vz_r500):.4g}, "f"std={np.std(map_vz_r500):.4g}, "f"skewness={skew(map_vz_r500):.4g}, "f"kurtosis={kurtosis(map_vz_r500):.4g}")

        #print(
        #    f"map_vx_500 stat: mean={np.mean(map_vx_500):.4g}, "f"median={np.median(map_vx_500):.4g}, "f"std={np.std(map_vx_500):.4g}, "f"skewness={skew(map_vx_500):.4g}, "f"kurtosis={kurtosis(map_vx_500):.4g}")

        # sys.exit()

        #print(
        #    f"map_vy_500 stat: mean={np.mean(map_vy_500):.4g}, "f"median={np.median(map_vy_500):.4g}, "f"std={np.std(map_vy_500):.4g}, "f"skewness={skew(map_vy_500):.4g}, "f"kurtosis={kurtosis(map_vy_500):.4g}")
        #print(
        #    f"map_vz_500 stat: mean={np.mean(map_vz_500):.4g}, "f"median={np.median(map_vz_500):.4g}, "f"std={np.std(map_vz_500):.4g}, "f"skewness={skew(map_vz_500):.4g}, "f"kurtosis={kurtosis(map_vz_500):.4g}")

        # map_vx_100 = vx[r < r2]
        # map_vy_100 = vy[r < r2]
        # map_vz_100 = vz[r < r2]

        #print(
        #    f"map_vx_100 stat: mean={np.mean(map_vx_100):.4g}, "f"median={np.median(map_vx_100):.4g}, "f"std={np.std(map_vx_100):.4g}, "f"skewness={skew(map_vx_100):.4g}, "f"kurtosis={kurtosis(map_vx_100):.4g}")
        #print(
        #    f"map_vy_100 stat: mean={np.mean(map_vy_100):.4g}, "f"median={np.median(map_vy_100):.4g}, "f"std={np.std(map_vy_100):.4g}, "f"skewness={skew(map_vy_100):.4g}, "f"kurtosis={kurtosis(map_vy_100):.4g}")
        #print(
        #    f"map_vz_100 stat: mean={np.mean(map_vz_100):.4g}, "f"median={np.median(map_vz_100):.4g}, "f"std={np.std(map_vz_100):.4g}, "f"skewness={skew(map_vz_100):.4g}, "f"kurtosis={kurtosis(map_vz_100):.4g}")

        count, bins, _ = axs[0, 0].hist(map_vx_ew_rvir, bins=20, alpha=0.6, color='darkred', density=True,label="EW")

        # print("count",count)

        print("vx rvir")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_ew_rvir, count, bins)
        axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[0, 0].hist(map_vx_mw_rvir, bins=20, alpha=0.5, color='grey', density=True,label="MW")

        # print("count",count)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_mw_rvir, count, bins)
        axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[0,0].yscale('log')
        axs[0, 0].set_xlim(-990,990)
        axs[0, 0].set_ylim(1e-5, height)
        # axs[0, 0].set_ylim(0, 1.2e6)
        # axs[0,0].legend(fontsize=10)
        # axs[0, 0].set_title("$V_x$")
        # axs[0,0].set_xlabel("Vx [km/s]")
        # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[0, 0].set_ylabel(pdfrvir)
        axs[0, 0].set_xticks([])
        axs[0, 0].legend(fontsize=10)
        axs[0, 0].set_yscale('log')
        axs[0,0].axvline(np.mean(map_vx_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        axs[0,0].axvline(np.mean(map_vx_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vy rvir")

        count, bins, _ = axs[0, 1].hist(map_vy_ew_rvir, bins=20, alpha=0.6, color='darkblue', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_ew_rvir, count, bins)
        axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[0, 1].hist(map_vy_mw_rvir, bins=20, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_mw_rvir, count, bins)
        axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[0,1].yscale('log')
        axs[0, 1].set_xlim(-990,990)
        axs[0, 1].set_ylim(1e-5, height)
        # axs[0, 1].set_ylim(0, 1.2e6)
        # axs[0,1].legend(fontsize=10)
        # axs[0, 1].set_title("y component")
        axs[0, 1].set_yticks([])
        axs[0, 1].yaxis.set_visible(False)
        # axs[0,1].set_xlabel("Vy [km/s]")
        axs[0, 1].set_xticks([])
        axs[0, 1].legend(fontsize=10)
        axs[0, 1].set_yscale('log')
        axs[0,1].axvline(np.mean(map_vy_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        axs[0,1].axvline(np.mean(map_vy_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vz rvir")

        count, bins, _ = axs[0, 2].hist(map_vz_ew_rvir, bins=20, alpha=0.6, color='darkgreen', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_ew_rvir, count, bins)
        axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[0, 2].hist(map_vz_mw_rvir, bins=20, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_mw_rvir, count, bins)
        axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))



        # axs[0,2].yscale('log')
        axs[0, 2].set_xlim(-990,990)
        axs[0, 2].set_ylim(1e-5, height)
        # axs[0, 2].set_ylim(0, 1.2e6)
        # axs[0,2].legend(fontsize=10)
        # axs[0, 2].set_title("z projection")
        # axs[0,2].set_xlabel("Vz [km/s]")
        axs[0, 2].set_yticks([])
        axs[0, 2].set_xticks([])
        axs[0, 2].yaxis.set_visible(False)
        axs[0, 2].legend(fontsize=10)
        axs[0, 2].set_yscale('log')
        axs[0,2].axvline(np.mean(map_vz_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        axs[0,2].axvline(np.mean(map_vz_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vcen rvir")

        count, bins, _ = axs[0, 3].hist(map_vcen_ew_rvir, bins=20, alpha=0.6, color='mediumvioletred', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_ew_rvir, count, bins)
        axs[0, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[0, 3].hist(map_vcen_mw_rvir, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_mw_rvir, count, bins)
        axs[0, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        # axs[0,3].yscale('log')
        axs[0, 3].set_xlim(-990,990)
        axs[0, 3].set_ylim(1e-5, height)
        # axs[0, 3].set_ylim(0, 1.2e6)
        # axs[0,3].legend(fontsize=10)
        # axs[0, 3].set_title("z projection")
        # axs[0,3].set_xlabel("vcen [km/s]")
        axs[0, 3].set_yticks([])
        axs[0, 3].set_xticks([])
        axs[0, 3].yaxis.set_visible(False)
        axs[0, 3].legend(fontsize=10)
        axs[0, 3].set_yscale('log')
        axs[0, 3].axvline(np.mean(map_vcen_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        axs[0, 3].axvline(np.mean(map_vcen_mw_rvir), color='grey', linestyle='dashed', linewidth=1)



        #axs[0, 3].hist(map_vx_ew_rvir, bins=20, alpha=0.6, color='darkred', label='$V_x$', density=True)
        #axs[0, 3].hist(map_vy_ew_rvir, bins=20, alpha=0.6, color='darkblue', label='$V_y$', density=True)
        #axs[0, 3].hist(map_vz_ew_rvir, bins=20, alpha=0.6, color='darkgreen', label='$V_z$', density=True)
        #axs[0, 3].set_xlim(-990,990)
        #axs[0, 3].set_ylim(1e-5, height)
        # axs[0, 3].set_ylim(0, 1.2e6)
        #axs[0, 3].set_yticks([])
        #axs[0, 3].set_xticks([])
        #axs[0, 3].legend(fontsize=10)

        # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        print("vx r500")

        count, bins, _ = axs[1, 0].hist(map_vx_ew_r500, bins=20, alpha=0.6, color='red', density=True,label='EW')

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_ew_r500, count, bins)
        axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[1, 0].hist(map_vx_mw_r500, bins=20, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_mw_r500, count, bins)
        axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[1,0].yscale('log')
        axs[1, 0].set_xlim(-990,990)
        axs[1, 0].set_ylim(1e-5, height)
        # axs[1, 0].set_ylim(0, 1.3e4)
        # axs[1,0].legend(fontsize=10)
        # axs[1,0].set_title("x projection")
        # axs[1,0].set_xlabel("Vx [km/s]")
        # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
        axs[1, 0].set_ylabel(pdfr500)
        axs[1, 0].set_xticks([])
        axs[1, 0].legend(fontsize=10)
        axs[1, 0].set_yscale('log')
        axs[1,0].axvline(np.mean(map_vx_ew_r500), color='black', linestyle='dashed', linewidth=1)
        axs[1,0].axvline(np.mean(map_vx_mw_r500), color='grey', linestyle='dashed', linewidth=1)

        print("vy r500")

        count, bins, _ = axs[1, 1].hist(map_vy_ew_r500, bins=20, alpha=0.6, color='blue', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_ew_r500, count, bins)
        axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[1, 1].hist(map_vy_mw_r500, bins=20, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_mw_r500, count, bins)
        axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))


        # xs[1,1].yscale('log')
        axs[1, 1].set_xlim(-990,990)
        axs[1, 1].set_ylim(1e-5, height)
        # axs[1, 1].set_ylim(0, 1.3e4)
        # axs[1,1].legend(fontsize=10)
        # axs[1,1].set_title("y projection")
        axs[1, 1].set_yticks([])
        # axs[1,1].set_xlabel("Vy [km/s]")
        axs[1, 1].set_xticks([])
        axs[1, 1].legend(fontsize=10)
        axs[1, 1].set_yscale('log')
        axs[1, 1].yaxis.set_visible(False)
        axs[1,1].axvline(np.mean(map_vy_ew_r500), color='black', linestyle='dashed', linewidth=1)
        axs[1,1].axvline(np.mean(map_vy_mw_r500), color='grey', linestyle='dashed', linewidth=1)

        print("vz r500")

        count, bins, _ = axs[1, 2].hist(map_vz_ew_r500, bins=20, alpha=0.6, color='green', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_ew_r500, count, bins)
        axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[1, 2].hist(map_vz_mw_r500, bins=20, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_mw_r500, count, bins)
        axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[1,2].yscale('log')
        axs[1, 2].set_xlim(-990,990)
        axs[1, 2].set_ylim(1e-5, height)
        # axs[1, 2].set_ylim(0, 1.3e4)
        # axs[1,2].legend(fontsize=10)
        # axs[1,2].set_title("z projection")
        # axs[1,2].set_xlabel("Vz [km/s]")
        axs[1, 2].set_yticks([])
        axs[1, 2].set_xticks([])
        axs[1, 2].legend(fontsize=10)
        axs[1, 2].set_yscale('log')
        axs[1, 2].yaxis.set_visible(False)
        axs[1,2].axvline(np.mean(map_vz_ew_r500), color='black', linestyle='dashed', linewidth=1)
        axs[1,2].axvline(np.mean(map_vz_mw_r500), color='grey', linestyle='dashed', linewidth=1)

        print("vcen r500")

        count, bins, _ = axs[1, 3].hist(map_vcen_ew_r500, bins=20, alpha=0.6, color='deeppink', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_ew_r500, count, bins)
        axs[1, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[1, 3].hist(map_vcen_mw_r500, bins=20, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_mw_r500, count, bins)
        axs[1, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        # axs[1,3].yscale('log')
        axs[1, 3].set_xlim(-990,990)
        axs[1, 3].set_ylim(1e-5, height)
        # axs[1, 3].set_ylim(0, 1.3e4)
        # axs[1,3].legend(fontsize=10)
        # axs[1,3].set_title("z projection")
        # axs[1,3].set_xlabel("vcen [km/s]")
        axs[1, 3].set_yticks([])
        axs[1, 3].set_xticks([])
        axs[1, 3].legend(fontsize=10)
        axs[1, 3].set_yscale('log')
        axs[1, 3].yaxis.set_visible(False)
        axs[1,3].axvline(np.mean(map_vcen_ew_r500), color='black', linestyle='dashed', linewidth=1)
        axs[1,3].axvline(np.mean(map_vcen_mw_r500), color='grey', linestyle='dashed', linewidth=1)

        #axs[1, 3].hist(map_vx_ew_r500, bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
        #axs[1, 3].hist(map_vy_ew_r500, bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
        #axs[1, 3].hist(map_vz_ew_r500, bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
        #axs[1, 3].set_xlim(-990,990)
        #axs[1, 3].set_ylim(1e-5, height)
        # axs[1, 3].set_ylim(0, 1.3e4)
        #axs[1, 3].set_yticks([])
        #axs[1, 3].set_xticks([])
        #axs[1, 3].legend(fontsize=10)
        # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        ########################################
        ########################################

        large = 0

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components PDFs within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500\, \mathrm{kpc}$)"
            pdfr500 = "PDF \n ($R<100\, \mathrm{kpc}$)"
            height1 = 0.004
            height = 0.01

        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # vx_r2 = vx[r < r2]
        # vy_r2 = vy[r < r2]
        # vz_r2 = vz[r < r2]

        print("vx 500")

        count, bins, _ = axs[2, 0].hist(map_vx_ew_500, bins=20, alpha=0.6, color='orange', density=True,label="EW")

        # print("count",count)
        # sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_ew_500, count, bins)
        axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[2, 0].hist(map_vx_mw_500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        # print("count",count)
        # sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_mw_500, count, bins)
        axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[2,0].yscale('log')
        axs[2, 0].set_xlim(-990,990)
        axs[2, 0].set_ylim(2e-4, height1)
        # axs[2, 0].set_ylim(0, 1.2e6)
        # axs[2,0].legend(fontsize=10)
        # axs[2, 0].set_title("$V_x$")
        # axs[2,0].set_xlabel("Vx [km/s]")
        # axs[2, 0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[2, 0].set_ylabel(pdfrvir)
        axs[2, 0].set_xticks([])
        axs[2, 0].legend(fontsize=10)
        axs[2, 0].set_yscale('log')
        axs[2,0].axvline(np.mean(map_vx_ew_500), color='black', linestyle='dashed', linewidth=1)
        axs[2,0].axvline(np.mean(map_vx_mw_500), color='grey', linestyle='dashed', linewidth=1)

        print("vy 500")


        count, bins, _ = axs[2, 1].hist(map_vy_ew_500, bins=20, alpha=0.6, color='cornflowerblue', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_ew_500, count, bins)
        axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[2, 1].hist(map_vy_mw_500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_mw_500, count, bins)
        axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[2,1].yscale('log')
        axs[2, 1].set_xlim(-990,990)
        axs[2, 1].set_ylim(2e-4, height1)
        # axs[2, 1].set_ylim(0, 1.2e6)
        # axs[2,1].legend(fontsize=10)
        # axs[2, 1].set_title("y component")
        axs[2, 1].set_yticks([])
        # axs[2,1].set_xlabel("Vy [km/s]")
        axs[2, 1].set_xticks([])
        axs[2, 1].legend(fontsize=10)
        axs[2, 1].set_yscale('log')
        axs[2, 1].yaxis.set_visible(False)
        axs[2,1].axvline(np.mean(map_vy_ew_500), color='black', linestyle='dashed', linewidth=1)
        axs[2,1].axvline(np.mean(map_vy_mw_500), color='grey', linestyle='dashed', linewidth=1)

        print("vz 500")

        count, bins, _ = axs[2, 2].hist(map_vz_ew_500, bins=20, alpha=0.6, color='turquoise', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_ew_500, count, bins)
        axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[2, 2].hist(map_vz_mw_500, bins=20, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_mw_500, count, bins)
        axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[2,2].yscale('log')
        axs[2, 2].set_xlim(-990,990)
        axs[2, 2].set_ylim(2e-4, height1)
        # axs[2, 2].set_ylim(0, 1.2e6)
        # axs[2,2].legend(fontsize=10)
        # axs[2, 2].set_title("z projection")
        # axs[2,2].set_xlabel("Vz [km/s]")
        axs[2, 2].set_yticks([])
        axs[2, 2].set_xticks([])
        axs[2, 2].legend(fontsize=10)
        axs[2, 2].set_yscale('log')
        axs[2, 2].yaxis.set_visible(False)
        axs[2,2].axvline(np.mean(map_vz_ew_500), color='black', linestyle='dashed', linewidth=1)
        axs[2,2].axvline(np.mean(map_vz_mw_500), color='grey', linestyle='dashed', linewidth=1)

        print("vcen 500")

        count, bins, _ = axs[2, 3].hist(map_vcen_ew_500, bins=20, alpha=0.6, color='hotpink', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_ew_500, count, bins)
        axs[2, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[2, 3].hist(map_vcen_mw_500, bins=20, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_mw_500, count, bins)
        axs[2, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        # axs[2,3].yscale('log')
        axs[2, 3].set_xlim(-990,990)
        axs[2, 3].set_ylim(2e-4, height1)
        # axs[2, 3].set_ylim(0, 1.2e6)
        # axs[2,3].legend(fontsize=10)
        # axs[2, 3].set_title("z projection")
        # axs[2,3].set_xlabel("vcen [km/s]")
        axs[2, 3].set_yticks([])
        axs[2, 3].set_xticks([])
        axs[2, 3].legend(fontsize=10)
        axs[2, 3].set_yscale('log')
        axs[2, 3].yaxis.set_visible(False)
        axs[2,3].axvline(np.mean(map_vcen_ew_500), color='black', linestyle='dashed', linewidth=1)
        axs[2,3].axvline(np.mean(map_vcen_mw_500), color='grey', linestyle='dashed', linewidth=1)

        #axs[2, 3].hist(map_vx_ew_500, bins=20, alpha=0.6, color='orange', label='$V_x$', density=True)
        #axs[2, 3].hist(map_vy_ew_500, bins=20, alpha=0.6, color='purple', label='$V_y$', density=True)
        #axs[2, 3].hist(map_vz_ew_500, bins=20, alpha=0.6, color='turquoise', label='$V_z$', density=True)
        #axs[2, 3].set_xlim(-990,990)
        #axs[2, 3].set_ylim(2e-4, height1)
        # axs[2, 3].set_ylim(0, 1.2e6)
        #axs[2, 3].set_yticks([])
        #axs[2, 3].set_xticks([])
        #axs[2, 3].legend(fontsize=10)

        # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[2, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        print("vx 100")

        count, bins, _ = axs[3, 0].hist(map_vx_ew_100, bins=10, alpha=0.6, color='gold', density=True,label="EW")

        # print("max count", np.max(count))
        # sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_ew_100, count, bins)
        axs[3, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[3, 0].hist(map_vx_mw_100, bins=10, alpha=0.5, color='grey', density=True,label="MW")

        # print("max count", np.max(count))
        # sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_mw_100, count, bins)
        axs[3, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[3,0].yscale('log')
        axs[3, 0].set_xlim(-990,990)
        axs[3, 0].set_ylim(5e-4, height)
        # axs[3, 0].set_ylim(0, 1.3e4)
        # axs[3,0].legend(fontsize=10)
        # axs[3,0].set_title("x projection")
        # axs[3,0].set_xlabel("Vx [km/s]")
        # axs[3, 0].set_ylabel("PDF ($R<R_{500}$)")
        axs[3, 0].set_ylabel(pdfr500)
        #axs[3, 0].set_xticks([])
        axs[3, 0].set_xlabel("$v_{x}~[\mathrm{km~s^{-1}}]$")
        axs[3, 0].legend(fontsize=10)
        axs[3, 0].set_yscale('log')
        axs[3,0].axvline(np.mean(map_vx_ew_100), color='black', linestyle='dashed', linewidth=1)
        axs[3,0].axvline(np.mean(map_vx_mw_100), color='grey', linestyle='dashed', linewidth=1)

        print("vy 100")

        count, bins, _ = axs[3, 1].hist(map_vy_ew_100, bins=10, alpha=0.6, color='aqua', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_ew_100, count, bins)
        axs[3, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[3, 1].hist(map_vy_mw_100, bins=10, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_mw_100, count, bins)
        axs[3, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[3,1].yscale('log')
        axs[3, 1].set_xlim(-990,990)
        axs[3, 1].set_ylim(5e-4, height)
        # axs[3, 1].set_ylim(0, 1.3e4)
        # axs[3,1].legend(fontsize=10)
        # axs[3,1].set_title("y projection")
        axs[3, 1].set_yticks([])
        # axs[3,1].set_xlabel("Vy [km/s]")
        #axs[3, 1].set_xticks([])
        axs[3, 1].set_xlabel("$v_{y}~[\mathrm{km~s^{-1}}]$")
        axs[3, 1].legend(fontsize=10)
        axs[3, 1].set_yscale('log')
        axs[3, 1].yaxis.set_visible(False)
        axs[3,1].axvline(np.mean(map_vy_ew_100), color='black', linestyle='dashed', linewidth=1)
        axs[3,1].axvline(np.mean(map_vy_mw_100), color='grey', linestyle='dashed', linewidth=1)

        print("vz 100")

        count, bins, _ = axs[3, 2].hist(map_vz_ew_100, bins=10, alpha=0.6, color='aquamarine', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_ew_100, count, bins)
        axs[3, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))


        count, bins, _ = axs[3, 2].hist(map_vz_mw_100, bins=10, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_mw_100, count, bins)
        axs[3, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[3,2].yscale('log')
        axs[3, 2].set_xlim(-990,990)
        axs[3, 2].set_ylim(5e-4, height)
        # axs[3, 2].set_ylim(0, 1.3e4)
        # axs[3,2].legend(fontsize=10)
        # axs[3,2].set_title("z projection")
        # axs[3,2].set_xlabel("Vz [km/s]")
        axs[3, 2].set_yticks([])
        #axs[3, 2].set_xticks([])
        axs[3, 2].set_xlabel("$v_{z}~[\mathrm{km~s^{-1}}]$")
        axs[3, 2].legend(fontsize=10)
        axs[3, 2].set_yscale('log')
        axs[3, 2].yaxis.set_visible(False)
        axs[3,2].axvline(np.mean(map_vz_ew_100), color='black', linestyle='dashed', linewidth=1)
        axs[3,2].axvline(np.mean(map_vz_mw_100), color='grey', linestyle='dashed', linewidth=1)

        print("vcen 100")

        count, bins, _ = axs[3, 3].hist(map_vcen_ew_100, bins=10, alpha=0.6, color='pink', density=True,label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_ew_100, count, bins)
        axs[3, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))


        count, bins, _ = axs[3, 3].hist(map_vcen_mw_100, bins=10, alpha=0.5, color='grey', density=True,label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_mw_100, count, bins)
        axs[3, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')#,
                       #label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                       #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        # axs[3,3].yscale('log')
        axs[3, 3].set_xlim(-990,990)
        axs[3, 3].set_ylim(5e-4, height)
        # axs[3, 3].set_ylim(0, 1.3e4)
        # axs[3,3].legend(fontsize=10)
        # axs[3,3].set_title("z projection")
        # axs[3,3].set_xlabel("vcen [km/s]")
        axs[3, 3].set_yticks([])
        #axs[3, 3].set_xticks([])
        axs[3, 3].set_xlabel("$v_{cen}~[\mathrm{km~s^{-1}}]$")
        axs[3, 3].legend(fontsize=10)
        axs[3, 3].set_yscale('log')
        axs[3, 3].yaxis.set_visible(False)
        axs[3,3].axvline(np.mean(map_vcen_ew_100), color='black', linestyle='dashed', linewidth=1)
        axs[3,3].axvline(np.mean(map_vcen_mw_100), color='grey', linestyle='dashed', linewidth=1)

        #axs[3, 3].hist(map_vx_ew_100, bins=10, alpha=0.6, color='gold', label='$V_x$', density=True)
        #axs[3, 3].hist(map_vy_ew_100, bins=10, alpha=0.6, color='pink', label='$V_y$', density=True)
        #axs[3, 3].hist(map_vz_ew_100, bins=10, alpha=0.6, color='cyan', label='$V_z$', density=True)
        #axs[3, 3].set_xlim(-1900, 1900)
        #axs[3, 3].set_ylim(0, height)
        # axs[3, 3].set_ylim(0, 1.3e4)
        #axs[3, 3].set_yticks([])
        #axs[3, 3].legend(fontsize=10)
        # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[3, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        ########################################
        ########################################

        rvir = 2147
        r500 = 1087

        #axs[4, 0].hist(map_vx_ew_rvir, bins=20, alpha=0.6, color='darkred', label='$R<R_{vir}$',
        #               density=True)  # ,histtype='step',linewidth=2)
        #axs[4, 0].hist(map_vx_ew_r500, bins=20, alpha=0.6, color='red', label='$R<R_{500}$',
        #               density=True)  # ,histtype='step',linewidth=2)
        #axs[4, 0].hist(map_vx_ew_500, bins=20, alpha=0.6, color='orange', label='$R<500kpc$',
        #               density=True)  # ,histtype='step',linewidth=2)
        #axs[4, 0].hist(map_vx_ew_100, bins=10, alpha=0.6, color='gold', label='$R<100kpc$',
        #               density=True)  # ,histtype='step',linewidth=2)
        # axs[4,0].yscale('log')
        #axs[4, 0].set_xlim(-1900, 1900)
        #axs[4, 0].set_ylim(0, height)
        # axs[4, 0].set_ylim(0, 700)
        # axs[4,0].legend(fontsize=10)
        # axs[4,0].set_title("x projection")
        #axs[4, 0].set_xlabel("Vx [km/s]")
        #axs[4, 0].set_ylabel("PDF")
        #axs[4, 0].legend(fontsize=10)
        # axs[4, 0].set_yscale('log')

        #axs[4, 1].hist(map_vy_ew_rvir, bins=20, alpha=0.6, color='darkblue', label='$R<R_{vir}$',
        #               density=True)  # ,histtype='step',linewidth=2)
        #axs[4, 1].hist(map_vy_ew_r500, bins=20, alpha=0.6, color='blue', label='$R<R_{500}$',
        #               density=True)  # ,histtype='step',linewidth=2)
        #axs[4, 1].hist(map_vy_ew_500, bins=20, alpha=0.6, color='purple', label='$R<500kpc$',
        #               density=True)  # ,histtype='step',linewidth=2)
        #axs[4, 1].hist(map_vy_ew_100, bins=10, alpha=0.6, color='pink', label='$R<100kpc$',
        #               density=True)  # ,histtype='step',linewidth=2)
        # xs[4,1].yscale('log')
        #axs[4, 1].set_xlim(-1900, 1900)
        #axs[4, 1].set_ylim(0, height)
        # axs[4, 1].set_ylim(0, 700)
        # axs[4,1].legend(fontsize=10)
        # axs[4,1].set_title("y projection")
        #axs[4, 1].set_yticks([])
        #axs[4, 1].set_xlabel("Vy [km/s]")
        #axs[4, 1].legend(fontsize=10)
        # axs[4, 1].set_yscale('log')

        #axs[4, 2].hist(map_vz_ew_rvir, bins=20, alpha=0.6, color='darkgreen', label='$R<R_{vir}$',
        #               density=True)  # ,histtype='step',linewidth=2)
        #axs[4, 2].hist(map_vz_ew_r500, bins=20, alpha=0.6, color='green', label='$R<R_{500}$',
        #               density=True)  # ,histtype='step',linewidth=2)
        #axs[4, 2].hist(map_vz_ew_500, bins=20, alpha=0.6, color='turquoise', label='$R<500kpc$',
        #               density=True)  # ,histtype='step',linewidth=2)
        #axs[4, 2].hist(map_vz_ew_100, bins=10, alpha=0.6, color='cyan', label='$R<100kpc$',
        #               density=True)  # ,histtype='step',linewidth=2)
        # axs[4,2].yscale('log')
        #axs[4, 2].set_xlim(-1900, 1900)
        #axs[4, 2].set_ylim(0, height)
        # axs[4, 2].set_ylim(0, 700)
        # axs[4,2].legend(fontsize=10)
        # axs[4,2].set_title("z projection")
        #axs[4, 2].set_xlabel("Vz [km/s]")
        #axs[4, 2].set_yticks([])
        #axs[4, 2].legend(fontsize=10)
        # axs[4, 2].set_yscale('log')

        # axs[3].yscale('log')

        # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
        # plt.grid(b=None)
        #plt.legend()
        # plt.ylabel("PDF")
        #axs[3, 3].set_xlabel("V [km/s]")

        #axs[4, 3].axis("off")

        # plt.yscale('log')
        # plt.title("Vz distribution on ew sightline velocity along z axis")
        # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

        plt.suptitle("MW vs EW Projected velocity distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii circles")

        plt.savefig("pdfs_2D.png", dpi=300)

        print("fig saved")

    def ew_overplot_comp():
        map_vx_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_ew_Tsup7_5Mpc2.bin', 'x')
        map_vy_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_ew_Tsup7_5Mpc2.bin', 'y')
        map_vz_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_ew_Tsup7_5Mpc2.bin', 'z')
        map_vcen_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_ew_Tsup7_5Mpc2.bin', 'z')

        map_vx_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_mw_Tsup7_5Mpc2.bin', 'x')
        map_vy_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_mw_Tsup7_5Mpc2.bin', 'y')
        map_vz_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_mw_Tsup7_5Mpc2.bin', 'z')
        map_vcen_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_mw_Tsup7_5Mpc2.bin', 'z')

        # print("test")
        # sys.exit()

        min_x = 0
        max_x = len(map_vx_ew[:, 0])
        print("max", max_x)
        min_y = 0
        max_y = len(map_vx_ew[0, :])

        cen_x = int(max_x / 2)
        cen_y = int(max_y / 2)

        print(cen_x, cen_y)

        # d = np.array([[np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 11.2524 for i in range(max_x)] for j in range(max_y)]) #still useful for toy model tests

        # np.save("map_distances_lvl16_proj_vel",d)

        d = np.load("map_distances_lvl15_proj_vel.npy")

        # print(np.shape(d))
        # print(np.min(d),np.max(d))
        # print(n)

        # plt.hist(d,bins=100)
        # plt.show()

        map_vx_ew_rvir = map_vx_ew[d < 2147]
        map_vx_ew_r500 = map_vx_ew[d < 1087]
        map_vx_ew_500 = map_vx_ew[d < 515]
        map_vx_ew_100 = map_vx_ew[d < 100]

        map_vy_ew_rvir = map_vy_ew[d < 2147]
        map_vy_ew_r500 = map_vy_ew[d < 1087]
        map_vy_ew_500 = map_vy_ew[d < 515]
        map_vy_ew_100 = map_vy_ew[d < 100]

        map_vz_ew_rvir = map_vz_ew[d < 2147]
        map_vz_ew_r500 = map_vz_ew[d < 1087]
        map_vz_ew_500 = map_vz_ew[d < 515]
        map_vz_ew_100 = map_vz_ew[d < 100]

        #############################

        map_vx_mw_rvir = map_vx_mw[d < 2147]
        map_vx_mw_r500 = map_vx_mw[d < 1087]
        map_vx_mw_500 = map_vx_mw[d < 515]
        map_vx_mw_100 = map_vx_mw[d < 100]

        map_vy_mw_rvir = map_vy_mw[d < 2147]
        map_vy_mw_r500 = map_vy_mw[d < 1087]
        map_vy_mw_500 = map_vy_mw[d < 515]
        map_vy_mw_100 = map_vy_mw[d < 100]

        map_vz_mw_rvir = map_vz_mw[d < 2147]
        map_vz_mw_r500 = map_vz_mw[d < 1087]
        map_vz_mw_500 = map_vz_mw[d < 515]
        map_vz_mw_100 = map_vz_mw[d < 100]

        #################################

        map_vcen_ew_rvir = map_vcen_ew[d < 2147]
        map_vcen_ew_r500 = map_vcen_ew[d < 1087]
        map_vcen_ew_500 = map_vcen_ew[d < 515]
        map_vcen_ew_100 = map_vcen_ew[d < 100]

        map_vcen_mw_rvir = map_vcen_mw[d < 2147]
        map_vcen_mw_r500 = map_vcen_mw[d < 1087]
        map_vcen_mw_500 = map_vcen_mw[d < 515]
        map_vcen_mw_100 = map_vcen_mw[d < 100]

        print(f"map_vcen_ew_rvir stat: mean={np.mean(map_vcen_ew_rvir):.4g}, "f"median={np.median(map_vcen_ew_rvir):.4g}, "f"std={np.std(map_vcen_ew_rvir):.4g}, "f"skewness={skew(map_vcen_ew_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_rvir):.4g}")
        print(f"map_vcen_mw_rvir stat: mean={np.mean(map_vcen_mw_rvir):.4g}, "f"median={np.median(map_vcen_mw_rvir):.4g}, "f"std={np.std(map_vcen_mw_rvir):.4g}, "f"skewness={skew(map_vcen_mw_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_rvir):.4g}")
        print(f"map_vcen_ew_r500 stat: mean={np.mean(map_vcen_ew_r500):.4g}, "f"median={np.median(map_vcen_ew_r500):.4g}, "f"std={np.std(map_vcen_ew_r500):.4g}, "f"skewness={skew(map_vcen_ew_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_r500):.4g}")
        print(f"map_vcen_mw_r500 stat: mean={np.mean(map_vcen_mw_r500):.4g}, "f"median={np.median(map_vcen_mw_r500):.4g}, "f"std={np.std(map_vcen_mw_r500):.4g}, "f"skewness={skew(map_vcen_mw_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_r500):.4g}")
        print(f"map_vcen_ew_500 stat: mean={np.mean(map_vcen_ew_500):.4g}, "f"median={np.median(map_vcen_ew_500):.4g}, "f"std={np.std(map_vcen_ew_500):.4g}, "f"skewness={skew(map_vcen_ew_500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_500):.4g}")
        print(f"map_vcen_mw_500 stat: mean={np.mean(map_vcen_mw_500):.4g}, "f"median={np.median(map_vcen_mw_500):.4g}, "f"std={np.std(map_vcen_mw_500):.4g}, "f"skewness={skew(map_vcen_mw_500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_500):.4g}")
        print(f"map_vcen_ew_100 stat: mean={np.mean(map_vcen_ew_100):.4g}, "f"median={np.median(map_vcen_ew_100):.4g}, "f"std={np.std(map_vcen_ew_100):.4g}, "f"skewness={skew(map_vcen_ew_100):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_100):.4g}")
        print(f"map_vcen_mw_100 stat: mean={np.mean(map_vcen_mw_100):.4g}, "f"median={np.median(map_vcen_mw_100):.4g}, "f"std={np.std(map_vcen_mw_100):.4g}, "f"skewness={skew(map_vcen_mw_100):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_100):.4g}")

        # sys.exit()
        f, axs = plt.subplots(1, 4, figsize=(10, 8), constrained_layout=True, gridspec_kw={'wspace': 0, 'hspace': 0})

        large = 1

        if large == 1:
            r1 = 2147
            r2 = 1087
            plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
            pdfrvir = "PDF \n ($R<R_{vir}$)"
            pdfr500 = "PDF \n ($R<R_{500}$)"
            height = 0.004
            # height = 0.0035

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height = 0.0035

        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

        # vx_r1 = vx_r1[t[r < r1] < 1e7]

        # meanvx,stdvx = norm.fit(vx_r1)
        # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

        # print(
        #    f"map_vx_rvir stat: mean={np.mean(map_vx_rvir):.4g}, "f"median={np.median(map_vx_rvir):.4g}, "f"std={np.std(map_vx_rvir):.4g}, "f"skewness={skew(map_vx_rvir):.4g}, "f"kurtosis={kurtosis(map_vx_rvir):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_rvir stat: mean={np.mean(map_vy_rvir):.4g}, "f"median={np.median(map_vy_rvir):.4g}, "f"std={np.std(map_vy_rvir):.4g}, "f"skewness={skew(map_vy_rvir):.4g}, "f"kurtosis={kurtosis(map_vy_rvir):.4g}")
        # print(
        #    f"map_vz_rvir stat: mean={np.mean(map_vz_rvir):.4g}, "f"median={np.median(map_vz_rvir):.4g}, "f"std={np.std(map_vz_rvir):.4g}, "f"skewness={skew(map_vz_rvir):.4g}, "f"kurtosis={kurtosis(map_vz_rvir):.4g}")

        # map_vx_r500 = vx[r < r2]
        # map_vy_r500 = vy[r < r2]
        # map_vz_r500 = vz[r < r2]

        # print(
        #    f"map_vx_r500 stat: mean={np.mean(map_vx_r500):.4g}, "f"median={np.median(map_vx_r500):.4g}, "f"std={np.std(map_vx_r500):.4g}, "f"skewness={skew(map_vx_r500):.4g}, "f"kurtosis={kurtosis(map_vx_r500):.4g}")
        # print(
        #    f"map_vy_r500 stat: mean={np.mean(map_vy_r500):.4g}, "f"median={np.median(map_vy_r500):.4g}, "f"std={np.std(map_vy_r500):.4g}, "f"skewness={skew(map_vy_r500):.4g}, "f"kurtosis={kurtosis(map_vy_r500):.4g}")
        # print(
        #    f"map_vz_r500 stat: mean={np.mean(map_vz_r500):.4g}, "f"median={np.median(map_vz_r500):.4g}, "f"std={np.std(map_vz_r500):.4g}, "f"skewness={skew(map_vz_r500):.4g}, "f"kurtosis={kurtosis(map_vz_r500):.4g}")

        # print(
        #    f"map_vx_500 stat: mean={np.mean(map_vx_500):.4g}, "f"median={np.median(map_vx_500):.4g}, "f"std={np.std(map_vx_500):.4g}, "f"skewness={skew(map_vx_500):.4g}, "f"kurtosis={kurtosis(map_vx_500):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_500 stat: mean={np.mean(map_vy_500):.4g}, "f"median={np.median(map_vy_500):.4g}, "f"std={np.std(map_vy_500):.4g}, "f"skewness={skew(map_vy_500):.4g}, "f"kurtosis={kurtosis(map_vy_500):.4g}")
        # print(
        #    f"map_vz_500 stat: mean={np.mean(map_vz_500):.4g}, "f"median={np.median(map_vz_500):.4g}, "f"std={np.std(map_vz_500):.4g}, "f"skewness={skew(map_vz_500):.4g}, "f"kurtosis={kurtosis(map_vz_500):.4g}")

        # map_vx_100 = vx[r < r2]
        # map_vy_100 = vy[r < r2]
        # map_vz_100 = vz[r < r2]

        # print(
        #    f"map_vx_100 stat: mean={np.mean(map_vx_100):.4g}, "f"median={np.median(map_vx_100):.4g}, "f"std={np.std(map_vx_100):.4g}, "f"skewness={skew(map_vx_100):.4g}, "f"kurtosis={kurtosis(map_vx_100):.4g}")
        # print(
        #    f"map_vy_100 stat: mean={np.mean(map_vy_100):.4g}, "f"median={np.median(map_vy_100):.4g}, "f"std={np.std(map_vy_100):.4g}, "f"skewness={skew(map_vy_100):.4g}, "f"kurtosis={kurtosis(map_vy_100):.4g}")
        # print(
        #    f"map_vz_100 stat: mean={np.mean(map_vz_100):.4g}, "f"median={np.median(map_vz_100):.4g}, "f"std={np.std(map_vz_100):.4g}, "f"skewness={skew(map_vz_100):.4g}, "f"kurtosis={kurtosis(map_vz_100):.4g}")

        count, bins, _ = axs[0].hist(map_vx_ew_rvir, bins=20, alpha=0.6, color='darkred', density=True, label="$R_{vir}$")

        # print("count",count)

        print("vx rvir")

        # axs[0,0].yscale('log')
        axs[0].set_xlim(-990, 990)
        axs[0].set_ylim(1e-5, height)
        # axs[0].set_ylim(0, 1.2e6)
        # axs[0,0].legend(fontsize=10)
        # axs[0].set_title("$V_x$")
        # axs[0,0].set_xlabel("Vx [km/s]")
        # axs[0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[0].set_ylabel("PDF")
        #axs[0].set_xticks([])
        axs[0].set_xlabel("$v_{x}~[\mathrm{km~s^{-1}}]$")
        #axs[0].legend(fontsize=10)
        axs[0].set_yscale('log')
        #axs[0].axvline(np.mean(map_vx_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        #axs[0].axvline(np.mean(map_vx_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vy rvir")

        count, bins, _ = axs[1].hist(map_vy_ew_rvir, bins=20, alpha=0.6, color='darkblue', density=True, label="$R_{vir}$")

        # xs[0,1].yscale('log')
        axs[1].set_xlim(-990, 990)
        axs[1].set_ylim(1e-5, height)
        # axs[1].set_ylim(0, 1.2e6)
        # axs[0,1].legend(fontsize=10)
        # axs[1].set_title("y component")
        axs[1].set_yticks([])
        axs[1].yaxis.set_visible(False)
        # axs[0,1].set_xlabel("Vy [km/s]")
        #axs[1].set_xticks([])
        axs[1].set_xlabel("$v_{y}~[\mathrm{km~s^{-1}}]$")
        #axs[1].legend(fontsize=10)
        axs[1].set_yscale('log')
        #axs[1].axvline(np.mean(map_vy_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        #axs[1].axvline(np.mean(map_vy_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vz rvir")

        count, bins, _ = axs[2].hist(map_vz_ew_rvir, bins=20, alpha=0.6, color='darkgreen', density=True, label="$R_{vir}$")

        # axs[0,2].yscale('log')
        axs[2].set_xlim(-990, 990)
        axs[2].set_ylim(1e-5, height)
        # axs[2].set_ylim(0, 1.2e6)
        # axs[0,2].legend(fontsize=10)
        # axs[2].set_title("z projection")
        # axs[0,2].set_xlabel("Vz [km/s]")
        axs[2].set_yticks([])
        #axs[2].set_xticks([])
        axs[2].set_xlabel("$v_{z}~[\mathrm{km~s^{-1}}]$")
        axs[2].yaxis.set_visible(False)
        #axs[2].legend(fontsize=10)
        axs[2].set_yscale('log')
        #axs[2].axvline(np.mean(map_vz_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        #axs[2].axvline(np.mean(map_vz_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vcen rvir")

        count, bins, _ = axs[3].hist(map_vcen_ew_rvir, bins=20, alpha=0.6, color='mediumvioletred', density=True, label="$R_{vir}$")

        axs[3].set_xlim(-990, 990)
        axs[3].set_ylim(1e-5, height)
        # axs[3].set_ylim(0, 1.2e6)
        # axs[0,3].legend(fontsize=10)
        # axs[3].set_title("z projection")
        # axs[0,3].set_xlabel("vcen [km/s]")
        axs[3].set_yticks([])
        #axs[3].set_xticks([])
        axs[3].set_xlabel("$v_{cen}~[\mathrm{km~s^{-1}}]$")
        axs[3].yaxis.set_visible(False)
        axs[3].set_yscale('log')
        #axs[3].axvline(np.mean(map_vcen_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        #axs[3].axvline(np.mean(map_vcen_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        count, bins, _ = axs[0].hist(map_vx_ew_r500, bins=20, alpha=0.6, color='red', density=True, label='$R_{500}$')
        count, bins, _ = axs[1].hist(map_vy_ew_r500, bins=20, alpha=0.6, color='blue', density=True, label="$R_{500}$")
        count, bins, _ = axs[2].hist(map_vz_ew_r500, bins=20, alpha=0.6, color='green', density=True, label="$R_{500}$")
        count, bins, _ = axs[3].hist(map_vcen_ew_r500, bins=20, alpha=0.6, color='deeppink', density=True, label="$R_{500}$")

        count, bins, _ = axs[0].hist(map_vx_ew_500, bins=20, alpha=0.6, color='orange', density=True, label='$R_{2500}$')
        count, bins, _ = axs[1].hist(map_vy_ew_500, bins=20, alpha=0.6, color='cornflowerblue', density=True, label='$R_{2500}$')
        count, bins, _ = axs[2].hist(map_vz_ew_500, bins=20, alpha=0.6, color='turquoise', density=True, label='$R_{2500}$')
        count, bins, _ = axs[3].hist(map_vcen_ew_500, bins=20, alpha=0.6, color='hotpink', density=True, label='$R_{2500}$')

        #count, bins, _ = axs[0].hist(map_vx_ew_100, bins=10, alpha=0.6, color='gold', density=True, label="100 kpc")
        #count, bins, _ = axs[1].hist(map_vy_ew_100, bins=10, alpha=0.6, color='aqua', density=True, label="100 kpc")
        #count, bins, _ = axs[2].hist(map_vz_ew_100, bins=10, alpha=0.6, color='aquamarine', density=True, label="100 kpc")
        #count, bins, _ = axs[3].hist(map_vcen_ew_100, bins=10, alpha=0.6, color='pink', density=True, label="100 kpc")
        #plt.suptitle("EW vs MW Projected velocity distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii circles")

        axs[0].legend(fontsize=10)
        axs[1].legend(fontsize=10)
        axs[2].legend(fontsize=10)
        axs[3].legend(fontsize=10)

        plt.suptitle("Comparison of EW projected velocity PDFs within $R_{vir}$, $R_{500}$ and $R_{2500}$ ")

        plt.savefig("pdfs_2D_EW_comp.png", dpi=300)

        print("fig saved")

    def mw_overplot_comp():
        map_vx_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_ew_Tsup7_5Mpc2.bin', 'x')
        map_vy_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_ew_Tsup7_5Mpc2.bin', 'y')
        map_vz_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_ew_Tsup7_5Mpc2.bin', 'z')
        map_vcen_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_ew_Tsup7_5Mpc2.bin', 'z')

        map_vx_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_mw_Tsup7_5Mpc2.bin', 'x')
        map_vy_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_mw_Tsup7_5Mpc2.bin', 'y')
        map_vz_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_mw_Tsup7_5Mpc2.bin', 'z')
        map_vcen_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_mw_Tsup7_5Mpc2.bin', 'z')

        # print("test")
        # sys.exit()

        min_x = 0
        max_x = len(map_vx_ew[:, 0])
        print("max", max_x)
        min_y = 0
        max_y = len(map_vx_ew[0, :])

        cen_x = int(max_x / 2)
        cen_y = int(max_y / 2)

        print(cen_x, cen_y)

        # d = np.array([[np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 11.2524 for i in range(max_x)] for j in range(max_y)]) #still useful for toy model tests

        # np.save("map_distances_lvl16_proj_vel",d)

        d = np.load("map_distances_lvl15_proj_vel.npy")

        # print(np.shape(d))
        # print(np.min(d),np.max(d))
        # print(n)

        # plt.hist(d,bins=100)
        # plt.show()

        map_vx_ew_rvir = map_vx_ew[d < 2147]
        map_vx_ew_r500 = map_vx_ew[d < 1087]
        map_vx_ew_500 = map_vx_ew[d < 515]
        map_vx_ew_100 = map_vx_ew[d < 100]

        map_vy_ew_rvir = map_vy_ew[d < 2147]
        map_vy_ew_r500 = map_vy_ew[d < 1087]
        map_vy_ew_500 = map_vy_ew[d < 515]
        map_vy_ew_100 = map_vy_ew[d < 100]

        map_vz_ew_rvir = map_vz_ew[d < 2147]
        map_vz_ew_r500 = map_vz_ew[d < 1087]
        map_vz_ew_500 = map_vz_ew[d < 515]
        map_vz_ew_100 = map_vz_ew[d < 100]

        #############################

        map_vx_mw_rvir = map_vx_mw[d < 2147]
        map_vx_mw_r500 = map_vx_mw[d < 1087]
        map_vx_mw_500 = map_vx_mw[d < 515]
        map_vx_mw_100 = map_vx_mw[d < 100]

        map_vy_mw_rvir = map_vy_mw[d < 2147]
        map_vy_mw_r500 = map_vy_mw[d < 1087]
        map_vy_mw_500 = map_vy_mw[d < 515]
        map_vy_mw_100 = map_vy_mw[d < 100]

        map_vz_mw_rvir = map_vz_mw[d < 2147]
        map_vz_mw_r500 = map_vz_mw[d < 1087]
        map_vz_mw_500 = map_vz_mw[d < 515]
        map_vz_mw_100 = map_vz_mw[d < 100]

        #################################

        map_vcen_ew_rvir = map_vcen_ew[d < 2147]
        map_vcen_ew_r500 = map_vcen_ew[d < 1087]
        map_vcen_ew_500 = map_vcen_ew[d < 515]
        map_vcen_ew_100 = map_vcen_ew[d < 100]

        map_vcen_mw_rvir = map_vcen_mw[d < 2147]
        map_vcen_mw_r500 = map_vcen_mw[d < 1087]
        map_vcen_mw_500 = map_vcen_mw[d < 515]
        map_vcen_mw_100 = map_vcen_mw[d < 100]

        print(f"map_vcen_ew_rvir stat: mean={np.mean(map_vcen_ew_rvir):.4g}, "f"median={np.median(map_vcen_ew_rvir):.4g}, "f"std={np.std(map_vcen_ew_rvir):.4g}, "f"skewness={skew(map_vcen_ew_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_rvir):.4g}")
        print(f"map_vcen_mw_rvir stat: mean={np.mean(map_vcen_mw_rvir):.4g}, "f"median={np.median(map_vcen_mw_rvir):.4g}, "f"std={np.std(map_vcen_mw_rvir):.4g}, "f"skewness={skew(map_vcen_mw_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_rvir):.4g}")
        print(f"map_vcen_ew_r500 stat: mean={np.mean(map_vcen_ew_r500):.4g}, "f"median={np.median(map_vcen_ew_r500):.4g}, "f"std={np.std(map_vcen_ew_r500):.4g}, "f"skewness={skew(map_vcen_ew_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_r500):.4g}")
        print(f"map_vcen_mw_r500 stat: mean={np.mean(map_vcen_mw_r500):.4g}, "f"median={np.median(map_vcen_mw_r500):.4g}, "f"std={np.std(map_vcen_mw_r500):.4g}, "f"skewness={skew(map_vcen_mw_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_r500):.4g}")
        print(f"map_vcen_ew_500 stat: mean={np.mean(map_vcen_ew_500):.4g}, "f"median={np.median(map_vcen_ew_500):.4g}, "f"std={np.std(map_vcen_ew_500):.4g}, "f"skewness={skew(map_vcen_ew_500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_500):.4g}")
        print(f"map_vcen_mw_500 stat: mean={np.mean(map_vcen_mw_500):.4g}, "f"median={np.median(map_vcen_mw_500):.4g}, "f"std={np.std(map_vcen_mw_500):.4g}, "f"skewness={skew(map_vcen_mw_500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_500):.4g}")
        print(f"map_vcen_ew_100 stat: mean={np.mean(map_vcen_ew_100):.4g}, "f"median={np.median(map_vcen_ew_100):.4g}, "f"std={np.std(map_vcen_ew_100):.4g}, "f"skewness={skew(map_vcen_ew_100):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_100):.4g}")
        print(f"map_vcen_mw_100 stat: mean={np.mean(map_vcen_mw_100):.4g}, "f"median={np.median(map_vcen_mw_100):.4g}, "f"std={np.std(map_vcen_mw_100):.4g}, "f"skewness={skew(map_vcen_mw_100):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_100):.4g}")

        # sys.exit()
        f, axs = plt.subplots(1, 4, figsize=(10, 8), constrained_layout=True, gridspec_kw={'wspace': 0, 'hspace': 0})

        large = 1

        if large == 1:
            r1 = 2147
            r2 = 1087
            plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
            pdfrvir = "PDF \n ($R<R_{vir}$)"
            pdfr500 = "PDF \n ($R<R_{500}$)"
            height = 0.004
            # height = 0.0035

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height = 0.0035

        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

        # vx_r1 = vx_r1[t[r < r1] < 1e7]

        # meanvx,stdvx = norm.fit(vx_r1)
        # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

        # print(
        #    f"map_vx_rvir stat: mean={np.mean(map_vx_rvir):.4g}, "f"median={np.median(map_vx_rvir):.4g}, "f"std={np.std(map_vx_rvir):.4g}, "f"skewness={skew(map_vx_rvir):.4g}, "f"kurtosis={kurtosis(map_vx_rvir):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_rvir stat: mean={np.mean(map_vy_rvir):.4g}, "f"median={np.median(map_vy_rvir):.4g}, "f"std={np.std(map_vy_rvir):.4g}, "f"skewness={skew(map_vy_rvir):.4g}, "f"kurtosis={kurtosis(map_vy_rvir):.4g}")
        # print(
        #    f"map_vz_rvir stat: mean={np.mean(map_vz_rvir):.4g}, "f"median={np.median(map_vz_rvir):.4g}, "f"std={np.std(map_vz_rvir):.4g}, "f"skewness={skew(map_vz_rvir):.4g}, "f"kurtosis={kurtosis(map_vz_rvir):.4g}")

        # map_vx_r500 = vx[r < r2]
        # map_vy_r500 = vy[r < r2]
        # map_vz_r500 = vz[r < r2]

        # print(
        #    f"map_vx_r500 stat: mean={np.mean(map_vx_r500):.4g}, "f"median={np.median(map_vx_r500):.4g}, "f"std={np.std(map_vx_r500):.4g}, "f"skewness={skew(map_vx_r500):.4g}, "f"kurtosis={kurtosis(map_vx_r500):.4g}")
        # print(
        #    f"map_vy_r500 stat: mean={np.mean(map_vy_r500):.4g}, "f"median={np.median(map_vy_r500):.4g}, "f"std={np.std(map_vy_r500):.4g}, "f"skewness={skew(map_vy_r500):.4g}, "f"kurtosis={kurtosis(map_vy_r500):.4g}")
        # print(
        #    f"map_vz_r500 stat: mean={np.mean(map_vz_r500):.4g}, "f"median={np.median(map_vz_r500):.4g}, "f"std={np.std(map_vz_r500):.4g}, "f"skewness={skew(map_vz_r500):.4g}, "f"kurtosis={kurtosis(map_vz_r500):.4g}")

        # print(
        #    f"map_vx_500 stat: mean={np.mean(map_vx_500):.4g}, "f"median={np.median(map_vx_500):.4g}, "f"std={np.std(map_vx_500):.4g}, "f"skewness={skew(map_vx_500):.4g}, "f"kurtosis={kurtosis(map_vx_500):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_500 stat: mean={np.mean(map_vy_500):.4g}, "f"median={np.median(map_vy_500):.4g}, "f"std={np.std(map_vy_500):.4g}, "f"skewness={skew(map_vy_500):.4g}, "f"kurtosis={kurtosis(map_vy_500):.4g}")
        # print(
        #    f"map_vz_500 stat: mean={np.mean(map_vz_500):.4g}, "f"median={np.median(map_vz_500):.4g}, "f"std={np.std(map_vz_500):.4g}, "f"skewness={skew(map_vz_500):.4g}, "f"kurtosis={kurtosis(map_vz_500):.4g}")

        # map_vx_100 = vx[r < r2]
        # map_vy_100 = vy[r < r2]
        # map_vz_100 = vz[r < r2]

        # print(
        #    f"map_vx_100 stat: mean={np.mean(map_vx_100):.4g}, "f"median={np.median(map_vx_100):.4g}, "f"std={np.std(map_vx_100):.4g}, "f"skewness={skew(map_vx_100):.4g}, "f"kurtosis={kurtosis(map_vx_100):.4g}")
        # print(
        #    f"map_vy_100 stat: mean={np.mean(map_vy_100):.4g}, "f"median={np.median(map_vy_100):.4g}, "f"std={np.std(map_vy_100):.4g}, "f"skewness={skew(map_vy_100):.4g}, "f"kurtosis={kurtosis(map_vy_100):.4g}")
        # print(
        #    f"map_vz_100 stat: mean={np.mean(map_vz_100):.4g}, "f"median={np.median(map_vz_100):.4g}, "f"std={np.std(map_vz_100):.4g}, "f"skewness={skew(map_vz_100):.4g}, "f"kurtosis={kurtosis(map_vz_100):.4g}")

        count, bins, _ = axs[0].hist(map_vx_mw_rvir, bins=20, alpha=0.6, color='darkred', density=True, label="$R_{vir}$")

        # print("count",count)

        print("vx rvir")

        # axs[0,0].yscale('log')
        axs[0].set_xlim(-990, 990)
        axs[0].set_ylim(1e-5, height)
        # axs[0].set_ylim(0, 1.2e6)
        # axs[0,0].legend(fontsize=10)
        # axs[0].set_title("$V_x$")
        # axs[0,0].set_xlabel("Vx [km/s]")
        # axs[0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[0].set_ylabel("PDF")
        #axs[0].set_xticks([])
        axs[0].set_xlabel("$v_{x}~[\mathrm{km~s^{-1}}]$")
        #axs[0].legend(fontsize=10)
        axs[0].set_yscale('log')
        #axs[0].axvline(np.mean(map_vx_mw_rvir), color='black', linestyle='dashed', linmwidth=1)
        #axs[0].axvline(np.mean(map_vx_mw_rvir), color='grey', linestyle='dashed', linmwidth=1)

        print("vy rvir")

        count, bins, _ = axs[1].hist(map_vy_mw_rvir, bins=20, alpha=0.6, color='darkblue', density=True, label="$R_{vir}$")

        # xs[0,1].yscale('log')
        axs[1].set_xlim(-990, 990)
        axs[1].set_ylim(1e-5, height)
        # axs[1].set_ylim(0, 1.2e6)
        # axs[0,1].legend(fontsize=10)
        # axs[1].set_title("y component")
        axs[1].set_yticks([])
        axs[1].yaxis.set_visible(False)
        # axs[0,1].set_xlabel("Vy [km/s]")
        #axs[1].set_xticks([])
        axs[1].set_xlabel("$v_{y}~[\mathrm{km~s^{-1}}]$")
        #axs[1].legend(fontsize=10)
        axs[1].set_yscale('log')
        #axs[1].axvline(np.mean(map_vy_mw_rvir), color='black', linestyle='dashed', linmwidth=1)
        #axs[1].axvline(np.mean(map_vy_mw_rvir), color='grey', linestyle='dashed', linmwidth=1)

        print("vz rvir")

        count, bins, _ = axs[2].hist(map_vz_mw_rvir, bins=20, alpha=0.6, color='darkgreen', density=True, label="$R_{vir}$")

        # axs[0,2].yscale('log')
        axs[2].set_xlim(-990, 990)
        axs[2].set_ylim(1e-5, height)
        # axs[2].set_ylim(0, 1.2e6)
        # axs[0,2].legend(fontsize=10)
        # axs[2].set_title("z projection")
        # axs[0,2].set_xlabel("Vz [km/s]")
        axs[2].set_yticks([])
        #axs[2].set_xticks([])
        axs[2].set_xlabel("$v_{z}~[\mathrm{km~s^{-1}}]$")
        axs[2].yaxis.set_visible(False)
        #axs[2].legend(fontsize=10)
        axs[2].set_yscale('log')
        #axs[2].axvline(np.mean(map_vz_mw_rvir), color='black', linestyle='dashed', linmwidth=1)
        #axs[2].axvline(np.mean(map_vz_mw_rvir), color='grey', linestyle='dashed', linmwidth=1)

        print("vcen rvir")

        count, bins, _ = axs[3].hist(map_vcen_mw_rvir, bins=20, alpha=0.6, color='mediumvioletred', density=True, label="$R_{vir}$")

        axs[3].set_xlim(-990, 990)
        axs[3].set_ylim(1e-5, height)
        # axs[3].set_ylim(0, 1.2e6)
        # axs[0,3].legend(fontsize=10)
        # axs[3].set_title("z projection")
        # axs[0,3].set_xlabel("vcen [km/s]")
        axs[3].set_yticks([])
        #axs[3].set_xticks([])
        axs[3].set_xlabel("$v_{cen}~[\mathrm{km~s^{-1}}]$")
        axs[3].yaxis.set_visible(False)
        axs[3].set_yscale('log')
        #axs[3].axvline(np.mean(map_vcen_mw_rvir), color='black', linestyle='dashed', linmwidth=1)
        #axs[3].axvline(np.mean(map_vcen_mw_rvir), color='grey', linestyle='dashed', linmwidth=1)

        count, bins, _ = axs[0].hist(map_vx_mw_r500, bins=20, alpha=0.6, color='red', density=True, label='$R_{500}$')
        count, bins, _ = axs[1].hist(map_vy_mw_r500, bins=20, alpha=0.6, color='blue', density=True, label="$R_{500}$")
        count, bins, _ = axs[2].hist(map_vz_mw_r500, bins=20, alpha=0.6, color='green', density=True, label="$R_{500}$")
        count, bins, _ = axs[3].hist(map_vcen_mw_r500, bins=20, alpha=0.6, color='deeppink', density=True, label="$R_{500}$")

        count, bins, _ = axs[0].hist(map_vx_mw_500, bins=20, alpha=0.6, color='orange', density=True, label='$R_{2500}$')
        count, bins, _ = axs[1].hist(map_vy_mw_500, bins=20, alpha=0.6, color='cornflowerblue', density=True, label='$R_{2500}$')
        count, bins, _ = axs[2].hist(map_vz_mw_500, bins=20, alpha=0.6, color='turquoise', density=True, label='$R_{2500}$')
        count, bins, _ = axs[3].hist(map_vcen_mw_500, bins=20, alpha=0.6, color='hotpink', density=True, label='$R_{2500}$')

        #count, bins, _ = axs[0].hist(map_vx_mw_100, bins=10, alpha=0.6, color='gold', density=True, label="100 kpc")
        #count, bins, _ = axs[1].hist(map_vy_mw_100, bins=10, alpha=0.6, color='aqua', density=True, label="100 kpc")
        #count, bins, _ = axs[2].hist(map_vz_mw_100, bins=10, alpha=0.6, color='aquamarine', density=True, label="100 kpc")
        #count, bins, _ = axs[3].hist(map_vcen_mw_100, bins=10, alpha=0.6, color='pink', density=True, label="100 kpc")
        # plt.suptitle("mw vs MW Projected velocity distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii circles")

        axs[0].legend(fontsize=10)
        axs[1].legend(fontsize=10)
        axs[2].legend(fontsize=10)
        axs[3].legend(fontsize=10)

        plt.suptitle("Comparison of MW projected velocity PDFs within $R_{vir}$, $R_{500}$ and $R_{2500}$")

        plt.savefig("pdfs_2D_MW_comp.png", dpi=300)

        print("fig saved")

    def ew_overplot_rad():
        map_vx_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_ew_Tsup7_5Mpc2.bin', 'x')
        map_vy_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_ew_Tsup7_5Mpc2.bin', 'y')
        map_vz_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_ew_Tsup7_5Mpc2.bin', 'z')
        map_vcen_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_ew_Tsup7_5Mpc2.bin', 'z')

        map_vx_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_mw_Tsup7_5Mpc2.bin', 'x')
        map_vy_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_mw_Tsup7_5Mpc2.bin', 'y')
        map_vz_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_mw_Tsup7_5Mpc2.bin', 'z')
        map_vcen_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_mw_Tsup7_5Mpc2.bin', 'z')

        # print("test")
        # sys.exit()

        min_x = 0
        max_x = len(map_vx_ew[:, 0])
        print("max", max_x)
        min_y = 0
        max_y = len(map_vx_ew[0, :])

        cen_x = int(max_x / 2)
        cen_y = int(max_y / 2)

        print(cen_x, cen_y)

        # d = np.array([[np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 11.2524 for i in range(max_x)] for j in range(max_y)]) #still useful for toy model tests

        # np.save("map_distances_lvl15_proj_vel",d)

        d = np.load("map_distances_lvl15_proj_vel.npy")

        # print(np.shape(d))
        # print(np.min(d),np.max(d))
        # print(n)

        # plt.hist(d,bins=100)
        # plt.show()

        map_vx_ew_rvir = map_vx_ew[d < 2147]
        map_vx_ew_r500 = map_vx_ew[d < 1087]
        map_vx_ew_500 = map_vx_ew[d < 515]
        map_vx_ew_100 = map_vx_ew[d < 100]

        map_vy_ew_rvir = map_vy_ew[d < 2147]
        map_vy_ew_r500 = map_vy_ew[d < 1087]
        map_vy_ew_500 = map_vy_ew[d < 515]
        map_vy_ew_100 = map_vy_ew[d < 100]

        map_vz_ew_rvir = map_vz_ew[d < 2147]
        map_vz_ew_r500 = map_vz_ew[d < 1087]
        map_vz_ew_500 = map_vz_ew[d < 515]
        map_vz_ew_100 = map_vz_ew[d < 100]

        #############################

        map_vx_mw_rvir = map_vx_mw[d < 2147]
        map_vx_mw_r500 = map_vx_mw[d < 1087]
        map_vx_mw_500 = map_vx_mw[d < 515]
        map_vx_mw_100 = map_vx_mw[d < 100]

        map_vy_mw_rvir = map_vy_mw[d < 2147]
        map_vy_mw_r500 = map_vy_mw[d < 1087]
        map_vy_mw_500 = map_vy_mw[d < 515]
        map_vy_mw_100 = map_vy_mw[d < 100]

        map_vz_mw_rvir = map_vz_mw[d < 2147]
        map_vz_mw_r500 = map_vz_mw[d < 1087]
        map_vz_mw_500 = map_vz_mw[d < 515]
        map_vz_mw_100 = map_vz_mw[d < 100]

        #################################

        map_vcen_ew_rvir = map_vcen_ew[d < 2147]
        map_vcen_ew_r500 = map_vcen_ew[d < 1087]
        map_vcen_ew_500 = map_vcen_ew[d < 515]
        map_vcen_ew_100 = map_vcen_ew[d < 100]

        map_vcen_mw_rvir = map_vcen_mw[d < 2147]
        map_vcen_mw_r500 = map_vcen_mw[d < 1087]
        map_vcen_mw_500 = map_vcen_mw[d < 515]
        map_vcen_mw_100 = map_vcen_mw[d < 100]

        print(f"map_vcen_ew_rvir stat: mean={np.mean(map_vcen_ew_rvir):.4g}, "f"median={np.median(map_vcen_ew_rvir):.4g}, "f"std={np.std(map_vcen_ew_rvir):.4g}, "f"skewness={skew(map_vcen_ew_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_rvir):.4g}")
        print(f"map_vcen_mw_rvir stat: mean={np.mean(map_vcen_mw_rvir):.4g}, "f"median={np.median(map_vcen_mw_rvir):.4g}, "f"std={np.std(map_vcen_mw_rvir):.4g}, "f"skewness={skew(map_vcen_mw_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_rvir):.4g}")
        print(f"map_vcen_ew_r500 stat: mean={np.mean(map_vcen_ew_r500):.4g}, "f"median={np.median(map_vcen_ew_r500):.4g}, "f"std={np.std(map_vcen_ew_r500):.4g}, "f"skewness={skew(map_vcen_ew_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_r500):.4g}")
        print(f"map_vcen_mw_r500 stat: mean={np.mean(map_vcen_mw_r500):.4g}, "f"median={np.median(map_vcen_mw_r500):.4g}, "f"std={np.std(map_vcen_mw_r500):.4g}, "f"skewness={skew(map_vcen_mw_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_r500):.4g}")
        print(f"map_vcen_ew_500 stat: mean={np.mean(map_vcen_ew_500):.4g}, "f"median={np.median(map_vcen_ew_500):.4g}, "f"std={np.std(map_vcen_ew_500):.4g}, "f"skewness={skew(map_vcen_ew_500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_500):.4g}")
        print(f"map_vcen_mw_500 stat: mean={np.mean(map_vcen_mw_500):.4g}, "f"median={np.median(map_vcen_mw_500):.4g}, "f"std={np.std(map_vcen_mw_500):.4g}, "f"skewness={skew(map_vcen_mw_500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_500):.4g}")
        print(f"map_vcen_ew_100 stat: mean={np.mean(map_vcen_ew_100):.4g}, "f"median={np.median(map_vcen_ew_100):.4g}, "f"std={np.std(map_vcen_ew_100):.4g}, "f"skewness={skew(map_vcen_ew_100):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_100):.4g}")
        print(f"map_vcen_mw_100 stat: mean={np.mean(map_vcen_mw_100):.4g}, "f"median={np.median(map_vcen_mw_100):.4g}, "f"std={np.std(map_vcen_mw_100):.4g}, "f"skewness={skew(map_vcen_mw_100):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_100):.4g}")

        # sys.exit()
        f, axs = plt.subplots(1, 3, figsize=(10, 8), constrained_layout=True, gridspec_kw={'wspace': 0, 'hspace': 0})

        large = 1

        if large == 1:
            r1 = 2147
            r2 = 1087
            plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
            pdfrvir = "PDF \n ($R<R_{vir}$)"
            pdfr500 = "PDF \n ($R<R_{500}$)"
            height = 0.004
            # height = 0.0035

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height = 0.0035

        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

        # vx_r1 = vx_r1[t[r < r1] < 1e7]

        # meanvx,stdvx = norm.fit(vx_r1)
        # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

        # print(
        #    f"map_vx_rvir stat: mean={np.mean(map_vx_rvir):.4g}, "f"median={np.median(map_vx_rvir):.4g}, "f"std={np.std(map_vx_rvir):.4g}, "f"skewness={skew(map_vx_rvir):.4g}, "f"kurtosis={kurtosis(map_vx_rvir):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_rvir stat: mean={np.mean(map_vy_rvir):.4g}, "f"median={np.median(map_vy_rvir):.4g}, "f"std={np.std(map_vy_rvir):.4g}, "f"skewness={skew(map_vy_rvir):.4g}, "f"kurtosis={kurtosis(map_vy_rvir):.4g}")
        # print(
        #    f"map_vz_rvir stat: mean={np.mean(map_vz_rvir):.4g}, "f"median={np.median(map_vz_rvir):.4g}, "f"std={np.std(map_vz_rvir):.4g}, "f"skewness={skew(map_vz_rvir):.4g}, "f"kurtosis={kurtosis(map_vz_rvir):.4g}")

        # map_vx_r500 = vx[r < r2]
        # map_vy_r500 = vy[r < r2]
        # map_vz_r500 = vz[r < r2]

        # print(
        #    f"map_vx_r500 stat: mean={np.mean(map_vx_r500):.4g}, "f"median={np.median(map_vx_r500):.4g}, "f"std={np.std(map_vx_r500):.4g}, "f"skewness={skew(map_vx_r500):.4g}, "f"kurtosis={kurtosis(map_vx_r500):.4g}")
        # print(
        #    f"map_vy_r500 stat: mean={np.mean(map_vy_r500):.4g}, "f"median={np.median(map_vy_r500):.4g}, "f"std={np.std(map_vy_r500):.4g}, "f"skewness={skew(map_vy_r500):.4g}, "f"kurtosis={kurtosis(map_vy_r500):.4g}")
        # print(
        #    f"map_vz_r500 stat: mean={np.mean(map_vz_r500):.4g}, "f"median={np.median(map_vz_r500):.4g}, "f"std={np.std(map_vz_r500):.4g}, "f"skewness={skew(map_vz_r500):.4g}, "f"kurtosis={kurtosis(map_vz_r500):.4g}")

        # print(
        #    f"map_vx_500 stat: mean={np.mean(map_vx_500):.4g}, "f"median={np.median(map_vx_500):.4g}, "f"std={np.std(map_vx_500):.4g}, "f"skewness={skew(map_vx_500):.4g}, "f"kurtosis={kurtosis(map_vx_500):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_500 stat: mean={np.mean(map_vy_500):.4g}, "f"median={np.median(map_vy_500):.4g}, "f"std={np.std(map_vy_500):.4g}, "f"skewness={skew(map_vy_500):.4g}, "f"kurtosis={kurtosis(map_vy_500):.4g}")
        # print(
        #    f"map_vz_500 stat: mean={np.mean(map_vz_500):.4g}, "f"median={np.median(map_vz_500):.4g}, "f"std={np.std(map_vz_500):.4g}, "f"skewness={skew(map_vz_500):.4g}, "f"kurtosis={kurtosis(map_vz_500):.4g}")

        # map_vx_100 = vx[r < r2]
        # map_vy_100 = vy[r < r2]
        # map_vz_100 = vz[r < r2]

        # print(
        #    f"map_vx_100 stat: mean={np.mean(map_vx_100):.4g}, "f"median={np.median(map_vx_100):.4g}, "f"std={np.std(map_vx_100):.4g}, "f"skewness={skew(map_vx_100):.4g}, "f"kurtosis={kurtosis(map_vx_100):.4g}")
        # print(
        #    f"map_vy_100 stat: mean={np.mean(map_vy_100):.4g}, "f"median={np.median(map_vy_100):.4g}, "f"std={np.std(map_vy_100):.4g}, "f"skewness={skew(map_vy_100):.4g}, "f"kurtosis={kurtosis(map_vy_100):.4g}")
        # print(
        #    f"map_vz_100 stat: mean={np.mean(map_vz_100):.4g}, "f"median={np.median(map_vz_100):.4g}, "f"std={np.std(map_vz_100):.4g}, "f"skewness={skew(map_vz_100):.4g}, "f"kurtosis={kurtosis(map_vz_100):.4g}")

        count, bins, _ = axs[0].hist(map_vx_ew_rvir, bins=20, alpha=0.6, color='darkred', density=True, label="$v_x$")

        # print("count",count)

        print("vx rvir")

        # axs[0,0].yscale('log')
        axs[0].set_xlim(-990, 990)
        axs[0].set_ylim(1e-5, height)
        # axs[0].set_ylim(0, 1.2e6)
        # axs[0,0].legend(fontsize=10)
        # axs[0].set_title("$V_x$")
        # axs[0,0].set_xlabel("Vx [km/s]")
        # axs[0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[0].set_ylabel("PDF")
        #axs[0].set_xticks([])
        axs[0].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")
        #axs[0].legend(fontsize=10)
        axs[0].set_yscale('log')
        axs[0].set_title('$R<R_{vir}$')
        #axs[0].axvline(np.mean(map_vx_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        #axs[0].axvline(np.mean(map_vx_mw_rvir), color='grey', linestyle='dashed', linewidth=1)


        print("vy rvir")

        count, bins, _ = axs[0].hist(map_vy_ew_rvir, bins=20, alpha=0.6, color='darkblue', density=True, label="$v_y$")

        # xs[0,1].yscale('log')
        axs[1].set_xlim(-990, 990)
        axs[1].set_ylim(1e-5, height)
        # axs[1].set_ylim(0, 1.2e6)
        # axs[0,1].legend(fontsize=10)
        # axs[1].set_title("y component")
        axs[1].set_yticks([])
        axs[1].yaxis.set_visible(False)
        # axs[0,1].set_xlabel("Vy [km/s]")
        #axs[1].set_xticks([])
        axs[1].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")
        #axs[1].legend(fontsize=10)
        axs[1].set_yscale('log')
        axs[1].set_title('$R<R_{500}$')
        #axs[1].axvline(np.mean(map_vy_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        #axs[1].axvline(np.mean(map_vy_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vz rvir")

        count, bins, _ = axs[0].hist(map_vz_ew_rvir, bins=20, alpha=0.6, color='darkgreen', density=True, label="$v_z$")

        # axs[0,2].yscale('log')
        axs[2].set_xlim(-990, 990)
        axs[2].set_ylim(1e-5, height)
        # axs[2].set_ylim(0, 1.2e6)
        # axs[0,2].legend(fontsize=10)
        # axs[2].set_title("z projection")
        # axs[0,2].set_xlabel("Vz [km/s]")
        axs[2].set_yticks([])
        #axs[2].set_xticks([])
        axs[2].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")
        axs[2].yaxis.set_visible(False)
        #axs[2].legend(fontsize=10)
        axs[2].set_yscale('log')
        axs[2].set_title('$R<R_{2500}$')
        #axs[2].axvline(np.mean(map_vz_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        #axs[2].axvline(np.mean(map_vz_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vcen rvir")

        count, bins, _ = axs[0].hist(map_vcen_ew_rvir, bins=20, alpha=0.6, color='mediumvioletred', density=True, label="$v_{cen}$")

        #axs[3].set_xlim(-990, 990)
        #axs[3].set_ylim(1e-5, height)
        # axs[3].set_ylim(0, 1.2e6)
        # axs[0,3].legend(fontsize=10)
        # axs[3].set_title("z projection")
        # axs[0,3].set_xlabel("vcen [km/s]")
        #axs[3].set_yticks([])
        #axs[3].set_xticks([])
        #axs[3].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")
        #axs[3].yaxis.set_visible(False)
        #axs[3].set_yscale('log')
        #axs[3].set_title('R<100 kpc')
        #axs[3].axvline(np.mean(map_vcen_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        #axs[3].axvline(np.mean(map_vcen_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        count, bins, _ = axs[1].hist(map_vx_ew_r500, bins=20, alpha=0.6, color='red', density=True, label='$v_x$')
        count, bins, _ = axs[1].hist(map_vy_ew_r500, bins=20, alpha=0.6, color='blue', density=True, label="$v_y$")
        count, bins, _ = axs[1].hist(map_vz_ew_r500, bins=20, alpha=0.6, color='green', density=True, label="$v_z$")
        count, bins, _ = axs[1].hist(map_vcen_ew_r500, bins=20, alpha=0.6, color='deeppink', density=True, label="$v_{cen}$")

        count, bins, _ = axs[2].hist(map_vx_ew_500, bins=20, alpha=0.6, color='orange', density=True, label='$v_x$')
        count, bins, _ = axs[2].hist(map_vy_ew_500, bins=20, alpha=0.6, color='cornflowerblue', density=True, label='$v_y$')
        count, bins, _ = axs[2].hist(map_vz_ew_500, bins=20, alpha=0.6, color='turquoise', density=True, label='$v_z$')
        count, bins, _ = axs[2].hist(map_vcen_ew_500, bins=20, alpha=0.6, color='hotpink', density=True, label='$v_{cen}$')

        #count, bins, _ = axs[3].hist(map_vx_ew_100, bins=10, alpha=0.6, color='gold', density=True, label='$v_x$')
        #count, bins, _ = axs[3].hist(map_vy_ew_100, bins=10, alpha=0.6, color='aqua', density=True, label='$v_y$')
        #count, bins, _ = axs[3].hist(map_vz_ew_100, bins=10, alpha=0.6, color='aquamarine', density=True, label='$v_z$')
        #count, bins, _ = axs[3].hist(map_vcen_ew_100, bins=10, alpha=0.6, color='pink', density=True, label='$v_{cen}$')
        # plt.suptitle("EW vs MW Projected velocity distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii circles")

        axs[0].legend(fontsize=10)
        axs[1].legend(fontsize=10)
        axs[2].legend(fontsize=10)
        #axs[3].legend(fontsize=10)

        plt.suptitle("Comparison of EW projected velocity PDFs along different sightlines")

        plt.savefig("pdfs_2D_EW_rad.png", dpi=300)

        print("fig saved")

    def mw_overplot_rad():
        map_vx_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_ew_Tsup7_5Mpc2.bin', 'x')
        map_vy_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_ew_Tsup7_5Mpc2.bin', 'y')
        map_vz_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_ew_Tsup7_5Mpc2.bin', 'z')
        map_vcen_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_ew_Tsup7_5Mpc2.bin', 'z')

        map_vx_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_mw_Tsup7_5Mpc2.bin', 'x')
        map_vy_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_mw_Tsup7_5Mpc2.bin', 'y')
        map_vz_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_mw_Tsup7_5Mpc2.bin', 'z')
        map_vcen_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_mw_Tsup7_5Mpc2.bin', 'z')

        # print("test")
        # sys.exit()

        min_x = 0
        max_x = len(map_vx_ew[:, 0])
        print("max", max_x)
        min_y = 0
        max_y = len(map_vx_ew[0, :])

        cen_x = int(max_x / 2)
        cen_y = int(max_y / 2)

        print(cen_x, cen_y)

        # d = np.array([[np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 11.2524 for i in range(max_x)] for j in range(max_y)]) #still useful for toy model tests

        # np.save("map_distances_lvl16_proj_vel",d)

        d = np.load("map_distances_lvl15_proj_vel.npy")

        # print(np.shape(d))
        # print(np.min(d),np.max(d))
        # print(n)

        # plt.hist(d,bins=100)
        # plt.show()

        map_vx_ew_rvir = map_vx_ew[d < 2147]
        map_vx_ew_r500 = map_vx_ew[d < 1087]
        map_vx_ew_500 = map_vx_ew[d < 515]
        map_vx_ew_100 = map_vx_ew[d < 100]

        map_vy_ew_rvir = map_vy_ew[d < 2147]
        map_vy_ew_r500 = map_vy_ew[d < 1087]
        map_vy_ew_500 = map_vy_ew[d < 515]
        map_vy_ew_100 = map_vy_ew[d < 100]

        map_vz_ew_rvir = map_vz_ew[d < 2147]
        map_vz_ew_r500 = map_vz_ew[d < 1087]
        map_vz_ew_500 = map_vz_ew[d < 515]
        map_vz_ew_100 = map_vz_ew[d < 100]

        #############################

        map_vx_mw_rvir = map_vx_mw[d < 2147]
        map_vx_mw_r500 = map_vx_mw[d < 1087]
        map_vx_mw_500 = map_vx_mw[d < 515]
        map_vx_mw_100 = map_vx_mw[d < 100]

        map_vy_mw_rvir = map_vy_mw[d < 2147]
        map_vy_mw_r500 = map_vy_mw[d < 1087]
        map_vy_mw_500 = map_vy_mw[d < 515]
        map_vy_mw_100 = map_vy_mw[d < 100]

        map_vz_mw_rvir = map_vz_mw[d < 2147]
        map_vz_mw_r500 = map_vz_mw[d < 1087]
        map_vz_mw_500 = map_vz_mw[d < 515]
        map_vz_mw_100 = map_vz_mw[d < 100]

        #################################

        map_vcen_ew_rvir = map_vcen_ew[d < 2147]
        map_vcen_ew_r500 = map_vcen_ew[d < 1087]
        map_vcen_ew_500 = map_vcen_ew[d < 515]
        map_vcen_ew_100 = map_vcen_ew[d < 100]

        map_vcen_mw_rvir = map_vcen_mw[d < 2147]
        map_vcen_mw_r500 = map_vcen_mw[d < 1087]
        map_vcen_mw_500 = map_vcen_mw[d < 515]
        map_vcen_mw_100 = map_vcen_mw[d < 100]

        print(f"map_vcen_ew_rvir stat: mean={np.mean(map_vcen_ew_rvir):.4g}, "f"median={np.median(map_vcen_ew_rvir):.4g}, "f"std={np.std(map_vcen_ew_rvir):.4g}, "f"skewness={skew(map_vcen_ew_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_rvir):.4g}")
        print(f"map_vcen_mw_rvir stat: mean={np.mean(map_vcen_mw_rvir):.4g}, "f"median={np.median(map_vcen_mw_rvir):.4g}, "f"std={np.std(map_vcen_mw_rvir):.4g}, "f"skewness={skew(map_vcen_mw_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_rvir):.4g}")
        print(f"map_vcen_ew_r500 stat: mean={np.mean(map_vcen_ew_r500):.4g}, "f"median={np.median(map_vcen_ew_r500):.4g}, "f"std={np.std(map_vcen_ew_r500):.4g}, "f"skewness={skew(map_vcen_ew_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_r500):.4g}")
        print(f"map_vcen_mw_r500 stat: mean={np.mean(map_vcen_mw_r500):.4g}, "f"median={np.median(map_vcen_mw_r500):.4g}, "f"std={np.std(map_vcen_mw_r500):.4g}, "f"skewness={skew(map_vcen_mw_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_r500):.4g}")
        print(f"map_vcen_ew_500 stat: mean={np.mean(map_vcen_ew_500):.4g}, "f"median={np.median(map_vcen_ew_500):.4g}, "f"std={np.std(map_vcen_ew_500):.4g}, "f"skewness={skew(map_vcen_ew_500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_500):.4g}")
        print(f"map_vcen_mw_500 stat: mean={np.mean(map_vcen_mw_500):.4g}, "f"median={np.median(map_vcen_mw_500):.4g}, "f"std={np.std(map_vcen_mw_500):.4g}, "f"skewness={skew(map_vcen_mw_500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_500):.4g}")
        print(f"map_vcen_ew_100 stat: mean={np.mean(map_vcen_ew_100):.4g}, "f"median={np.median(map_vcen_ew_100):.4g}, "f"std={np.std(map_vcen_ew_100):.4g}, "f"skewness={skew(map_vcen_ew_100):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_100):.4g}")
        print(f"map_vcen_mw_100 stat: mean={np.mean(map_vcen_mw_100):.4g}, "f"median={np.median(map_vcen_mw_100):.4g}, "f"std={np.std(map_vcen_mw_100):.4g}, "f"skewness={skew(map_vcen_mw_100):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_100):.4g}")

        # sys.exit()
        f, axs = plt.subplots(1, 3, figsize=(10, 8), constrained_layout=True, gridspec_kw={'wspace': 0, 'hspace': 0})

        large = 1

        if large == 1:
            r1 = 2147
            r2 = 1087
            plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
            pdfrvir = "PDF \n ($R<R_{vir}$)"
            pdfr500 = "PDF \n ($R<R_{500}$)"
            height = 0.004
            # height = 0.0035

        if large == 0:
            r1 = 500
            r2 = 100
            plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height = 0.0035

        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

        # vx_r1 = vx_r1[t[r < r1] < 1e7]

        # meanvx,stdvx = norm.fit(vx_r1)
        # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

        # print(
        #    f"map_vx_rvir stat: mean={np.mean(map_vx_rvir):.4g}, "f"median={np.median(map_vx_rvir):.4g}, "f"std={np.std(map_vx_rvir):.4g}, "f"skewness={skew(map_vx_rvir):.4g}, "f"kurtosis={kurtosis(map_vx_rvir):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_rvir stat: mean={np.mean(map_vy_rvir):.4g}, "f"median={np.median(map_vy_rvir):.4g}, "f"std={np.std(map_vy_rvir):.4g}, "f"skewness={skew(map_vy_rvir):.4g}, "f"kurtosis={kurtosis(map_vy_rvir):.4g}")
        # print(
        #    f"map_vz_rvir stat: mean={np.mean(map_vz_rvir):.4g}, "f"median={np.median(map_vz_rvir):.4g}, "f"std={np.std(map_vz_rvir):.4g}, "f"skewness={skew(map_vz_rvir):.4g}, "f"kurtosis={kurtosis(map_vz_rvir):.4g}")

        # map_vx_r500 = vx[r < r2]
        # map_vy_r500 = vy[r < r2]
        # map_vz_r500 = vz[r < r2]

        # print(
        #    f"map_vx_r500 stat: mean={np.mean(map_vx_r500):.4g}, "f"median={np.median(map_vx_r500):.4g}, "f"std={np.std(map_vx_r500):.4g}, "f"skewness={skew(map_vx_r500):.4g}, "f"kurtosis={kurtosis(map_vx_r500):.4g}")
        # print(
        #    f"map_vy_r500 stat: mean={np.mean(map_vy_r500):.4g}, "f"median={np.median(map_vy_r500):.4g}, "f"std={np.std(map_vy_r500):.4g}, "f"skewness={skew(map_vy_r500):.4g}, "f"kurtosis={kurtosis(map_vy_r500):.4g}")
        # print(
        #    f"map_vz_r500 stat: mean={np.mean(map_vz_r500):.4g}, "f"median={np.median(map_vz_r500):.4g}, "f"std={np.std(map_vz_r500):.4g}, "f"skewness={skew(map_vz_r500):.4g}, "f"kurtosis={kurtosis(map_vz_r500):.4g}")

        # print(
        #    f"map_vx_500 stat: mean={np.mean(map_vx_500):.4g}, "f"median={np.median(map_vx_500):.4g}, "f"std={np.std(map_vx_500):.4g}, "f"skewness={skew(map_vx_500):.4g}, "f"kurtosis={kurtosis(map_vx_500):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_500 stat: mean={np.mean(map_vy_500):.4g}, "f"median={np.median(map_vy_500):.4g}, "f"std={np.std(map_vy_500):.4g}, "f"skewness={skew(map_vy_500):.4g}, "f"kurtosis={kurtosis(map_vy_500):.4g}")
        # print(
        #    f"map_vz_500 stat: mean={np.mean(map_vz_500):.4g}, "f"median={np.median(map_vz_500):.4g}, "f"std={np.std(map_vz_500):.4g}, "f"skewness={skew(map_vz_500):.4g}, "f"kurtosis={kurtosis(map_vz_500):.4g}")

        # map_vx_100 = vx[r < r2]
        # map_vy_100 = vy[r < r2]
        # map_vz_100 = vz[r < r2]

        # print(
        #    f"map_vx_100 stat: mean={np.mean(map_vx_100):.4g}, "f"median={np.median(map_vx_100):.4g}, "f"std={np.std(map_vx_100):.4g}, "f"skewness={skew(map_vx_100):.4g}, "f"kurtosis={kurtosis(map_vx_100):.4g}")
        # print(
        #    f"map_vy_100 stat: mean={np.mean(map_vy_100):.4g}, "f"median={np.median(map_vy_100):.4g}, "f"std={np.std(map_vy_100):.4g}, "f"skewness={skew(map_vy_100):.4g}, "f"kurtosis={kurtosis(map_vy_100):.4g}")
        # print(
        #    f"map_vz_100 stat: mean={np.mean(map_vz_100):.4g}, "f"median={np.median(map_vz_100):.4g}, "f"std={np.std(map_vz_100):.4g}, "f"skewness={skew(map_vz_100):.4g}, "f"kurtosis={kurtosis(map_vz_100):.4g}")

        count, bins, _ = axs[0].hist(map_vx_mw_rvir, bins=20, alpha=0.6, color='darkred', density=True, label="$v_x$")

        # print("count",count)

        print("vx rvir")

        # axs[0,0].yscale('log')
        axs[0].set_xlim(-990, 990)
        axs[0].set_ylim(1e-5, height)
        # axs[0].set_ylim(0, 1.2e6)
        # axs[0,0].legend(fontsize=10)
        # axs[0].set_title("$V_x$")
        # axs[0,0].set_xlabel("Vx [km/s]")
        # axs[0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[0].set_ylabel("PDF")
        #axs[0].set_xticks([])
        axs[0].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")
        #axs[0].legend(fontsize=10)
        axs[0].set_yscale('log')
        axs[0].set_title('$R<R_{vir}$')
        #axs[0].axvline(np.mean(map_vx_mw_rvir), color='black', linestyle='dashed', linmwidth=1)
        #axs[0].axvline(np.mean(map_vx_mw_rvir), color='grey', linestyle='dashed', linmwidth=1)


        print("vy rvir")

        count, bins, _ = axs[0].hist(map_vy_mw_rvir, bins=20, alpha=0.6, color='darkblue', density=True, label="$v_y$")

        # xs[0,1].yscale('log')
        axs[1].set_xlim(-990, 990)
        axs[1].set_ylim(1e-5, height)
        # axs[1].set_ylim(0, 1.2e6)
        # axs[0,1].legend(fontsize=10)
        # axs[1].set_title("y component")
        axs[1].set_yticks([])
        axs[1].yaxis.set_visible(False)
        # axs[0,1].set_xlabel("Vy [km/s]")
        #axs[1].set_xticks([])
        axs[1].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")
        #axs[1].legend(fontsize=10)
        axs[1].set_yscale('log')
        axs[1].set_title('$R<R_{500}$')
        #axs[1].axvline(np.mean(map_vy_mw_rvir), color='black', linestyle='dashed', linmwidth=1)
        #axs[1].axvline(np.mean(map_vy_mw_rvir), color='grey', linestyle='dashed', linmwidth=1)

        print("vz rvir")

        count, bins, _ = axs[0].hist(map_vz_mw_rvir, bins=20, alpha=0.6, color='darkgreen', density=True, label="$v_z$")

        # axs[0,2].yscale('log')
        axs[2].set_xlim(-990, 990)
        axs[2].set_ylim(1e-5, height)
        # axs[2].set_ylim(0, 1.2e6)
        # axs[0,2].legend(fontsize=10)
        # axs[2].set_title("z projection")
        # axs[0,2].set_xlabel("Vz [km/s]")
        axs[2].set_yticks([])
        #axs[2].set_xticks([])
        axs[2].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")
        axs[2].yaxis.set_visible(False)
        #axs[2].legend(fontsize=10)
        axs[2].set_yscale('log')
        axs[2].set_title('$R<R_{2500}$')
        #axs[2].axvline(np.mean(map_vz_mw_rvir), color='black', linestyle='dashed', linmwidth=1)
        #axs[2].axvline(np.mean(map_vz_mw_rvir), color='grey', linestyle='dashed', linmwidth=1)

        print("vcen rvir")

        count, bins, _ = axs[0].hist(map_vcen_mw_rvir, bins=20, alpha=0.6, color='mediumvioletred', density=True, label="$v_{cen}$")

        #axs[3].set_xlim(-990, 990)
        #axs[3].set_ylim(1e-5, height)
        # axs[3].set_ylim(0, 1.2e6)
        # axs[0,3].legend(fontsize=10)
        # axs[3].set_title("z projection")
        # axs[0,3].set_xlabel("vcen [km/s]")
        #axs[3].set_yticks([])
        #axs[3].set_xticks([])
        #axs[3].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")
        #axs[3].yaxis.set_visible(False)
        #axs[3].set_yscale('log')
        #axs[3].set_title('R<100 kpc')
        #axs[3].axvline(np.mean(map_vcen_mw_rvir), color='black', linestyle='dashed', linmwidth=1)
        #axs[3].axvline(np.mean(map_vcen_mw_rvir), color='grey', linestyle='dashed', linmwidth=1)

        count, bins, _ = axs[1].hist(map_vx_mw_r500, bins=20, alpha=0.6, color='red', density=True, label='$v_x$')
        count, bins, _ = axs[1].hist(map_vy_mw_r500, bins=20, alpha=0.6, color='blue', density=True, label="$v_y$")
        count, bins, _ = axs[1].hist(map_vz_mw_r500, bins=20, alpha=0.6, color='green', density=True, label="$v_z$")
        count, bins, _ = axs[1].hist(map_vcen_mw_r500, bins=20, alpha=0.6, color='deeppink', density=True, label="$v_{cen}$")

        count, bins, _ = axs[2].hist(map_vx_mw_500, bins=20, alpha=0.6, color='orange', density=True, label='$v_x$')
        count, bins, _ = axs[2].hist(map_vy_mw_500, bins=20, alpha=0.6, color='cornflowerblue', density=True, label='$v_y$')
        count, bins, _ = axs[2].hist(map_vz_mw_500, bins=20, alpha=0.6, color='turquoise', density=True, label='$v_z$')
        count, bins, _ = axs[2].hist(map_vcen_mw_500, bins=20, alpha=0.6, color='hotpink', density=True, label='$v_{cen}$')

        #count, bins, _ = axs[3].hist(map_vx_mw_100, bins=10, alpha=0.6, color='gold', density=True, label='$v_x$')
        #count, bins, _ = axs[3].hist(map_vy_mw_100, bins=10, alpha=0.6, color='aqua', density=True, label='$v_y$')
        #count, bins, _ = axs[3].hist(map_vz_mw_100, bins=10, alpha=0.6, color='aquamarine', density=True, label='$v_z$')
        #count, bins, _ = axs[3].hist(map_vcen_mw_100, bins=10, alpha=0.6, color='pink', density=True, label='$v_{cen}$')
        # plt.suptitle("mw vs MW Projected velocity distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii circles")

        axs[0].legend(fontsize=10)
        axs[1].legend(fontsize=10)
        axs[2].legend(fontsize=10)
        #axs[3].legend(fontsize=10)

        plt.suptitle("Comparison of MW projected velocity PDFs along different sightlines")

        plt.savefig("pdfs_2D_MW_rad.png", dpi=300)

        print("fig saved")

    def mw_vs_ew_wo_100_plot():
        map_vx_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_ew_Tsup7_5Mpc2.bin', 'x')
        map_vy_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_ew_Tsup7_5Mpc2.bin', 'y')
        map_vz_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_ew_Tsup7_5Mpc2.bin', 'z')

        map_vx_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_mw_Tsup7_5Mpc2.bin', 'x')
        map_vy_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_mw_Tsup7_5Mpc2.bin', 'y')
        map_vz_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_mw_Tsup7_5Mpc2.bin', 'z')

        map_vcen_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_ew_Tsup7_5Mpc2.bin', 'z')
        map_vcen_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_mw_Tsup7_5Mpc2.bin', 'z')

        # print("test")
        # sys.exit()

        min_x = 0
        max_x = len(map_vx_ew[:, 0])
        print("max", max_x)
        min_y = 0
        max_y = len(map_vx_ew[0, :])

        cen_x = int(max_x / 2)
        cen_y = int(max_y / 2)

        print(cen_x, cen_y)

        d = np.array([[np.sqrt((cen_x - (i + 0.5)) ** 2 + (cen_y - (j + 0.5)) ** 2) * 22.5049 for i in range(max_x)] for j in range(max_y)])  # still useful for toy model tests

        # np.save("map_distances_lvl15_proj_vel",d)

        # print("dist file saved")

        d = np.load("map_distances_lvl15_proj_vel.npy")

        # print(np.shape(d))
        # print(np.min(d),np.max(d))
        # print(n)

        # plt.hist(d,bins=100)
        # plt.show()

        map_vx_ew_rvir = map_vx_ew[d < 2147]
        map_vx_ew_r500 = map_vx_ew[d < 1087]
        map_vx_ew_500 = map_vx_ew[d < 515]
        map_vx_ew_100 = map_vx_ew[d < 100]

        map_vy_ew_rvir = map_vy_ew[d < 2147]
        map_vy_ew_r500 = map_vy_ew[d < 1087]
        map_vy_ew_500 = map_vy_ew[d < 515]
        map_vy_ew_100 = map_vy_ew[d < 100]

        map_vz_ew_rvir = map_vz_ew[d < 2147]
        map_vz_ew_r500 = map_vz_ew[d < 1087]
        map_vz_ew_500 = map_vz_ew[d < 515]
        map_vz_ew_100 = map_vz_ew[d < 100]

        #############################

        map_vx_mw_rvir = map_vx_mw[d < 2147]
        map_vx_mw_r500 = map_vx_mw[d < 1087]
        map_vx_mw_500 = map_vx_mw[d < 515]
        map_vx_mw_100 = map_vx_mw[d < 100]

        map_vy_mw_rvir = map_vy_mw[d < 2147]
        map_vy_mw_r500 = map_vy_mw[d < 1087]
        map_vy_mw_500 = map_vy_mw[d < 515]
        map_vy_mw_100 = map_vy_mw[d < 100]

        map_vz_mw_rvir = map_vz_mw[d < 2147]
        map_vz_mw_r500 = map_vz_mw[d < 1087]
        map_vz_mw_500 = map_vz_mw[d < 515]
        map_vz_mw_100 = map_vz_mw[d < 100]

        #################################

        map_vcen_ew_rvir = map_vcen_ew[d < 2147]
        map_vcen_ew_r500 = map_vcen_ew[d < 1087]
        map_vcen_ew_500 = map_vcen_ew[d < 515]
        map_vcen_ew_100 = map_vcen_ew[d < 100]

        map_vcen_mw_rvir = map_vcen_mw[d < 2147]
        map_vcen_mw_r500 = map_vcen_mw[d < 1087]
        map_vcen_mw_500 = map_vcen_mw[d < 515]
        map_vcen_mw_100 = map_vcen_mw[d < 100]

        print(f"map_vcen_ew_rvir stat: mean={np.mean(map_vcen_ew_rvir):.4g}, "f"median={np.median(map_vcen_ew_rvir):.4g}, "f"std={np.std(map_vcen_ew_rvir):.4g}, "f"skewness={skew(map_vcen_ew_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_rvir):.4g}")
        print(f"map_vcen_mw_rvir stat: mean={np.mean(map_vcen_mw_rvir):.4g}, "f"median={np.median(map_vcen_mw_rvir):.4g}, "f"std={np.std(map_vcen_mw_rvir):.4g}, "f"skewness={skew(map_vcen_mw_rvir):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_rvir):.4g}")
        print(f"map_vcen_ew_r500 stat: mean={np.mean(map_vcen_ew_r500):.4g}, "f"median={np.median(map_vcen_ew_r500):.4g}, "f"std={np.std(map_vcen_ew_r500):.4g}, "f"skewness={skew(map_vcen_ew_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_r500):.4g}")
        print(f"map_vcen_mw_r500 stat: mean={np.mean(map_vcen_mw_r500):.4g}, "f"median={np.median(map_vcen_mw_r500):.4g}, "f"std={np.std(map_vcen_mw_r500):.4g}, "f"skewness={skew(map_vcen_mw_r500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_r500):.4g}")
        print(f"map_vcen_ew r2500 stat: mean={np.mean(map_vcen_ew_500):.4g}, "f"median={np.median(map_vcen_ew_500):.4g}, "f"std={np.std(map_vcen_ew_500):.4g}, "f"skewness={skew(map_vcen_ew_500):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_500):.4g}")
        print(f"map_vcen_mw r2500 stat: mean={np.mean(map_vcen_mw_500):.4g}, "f"median={np.median(map_vcen_mw_500):.4g}, "f"std={np.std(map_vcen_mw_500):.4g}, "f"skewness={skew(map_vcen_mw_500):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_500):.4g}")
        print(f"map_vcen_ew_100 stat: mean={np.mean(map_vcen_ew_100):.4g}, "f"median={np.median(map_vcen_ew_100):.4g}, "f"std={np.std(map_vcen_ew_100):.4g}, "f"skewness={skew(map_vcen_ew_100):.4g}, "f"kurtosis={kurtosis(map_vcen_ew_100):.4g}")
        print(f"map_vcen_mw_100 stat: mean={np.mean(map_vcen_mw_100):.4g}, "f"median={np.median(map_vcen_mw_100):.4g}, "f"std={np.std(map_vcen_mw_100):.4g}, "f"skewness={skew(map_vcen_mw_100):.4g}, "f"kurtosis={kurtosis(map_vcen_mw_100):.4g}")

        # sys.exit()
        f, axs = plt.subplots(3, 4, figsize=(10, 8), constrained_layout=True, gridspec_kw={'wspace': 0, 'hspace': 0})

        large = 1

        if large == 1:
            r1 = 2147
            r2 = 1087
            plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
            pdfrvir = "PDF \n ($R<R_{vir}$)"
            pdfr500 = "PDF \n ($R<R_{500}$)"
            height = 0.004
            # height = 0.0035

        if large == 0:
            r1 = 515
            r2 = 100
            plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<500 kpc$)"
            pdfr500 = "PDF \n ($R<100 kpc$)"
            height = 0.0035

        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

        # vx_r1 = vx_r1[t[r < r1] < 1e7]

        # meanvx,stdvx = norm.fit(vx_r1)
        # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

        # print(
        #    f"map_vx_rvir stat: mean={np.mean(map_vx_rvir):.4g}, "f"median={np.median(map_vx_rvir):.4g}, "f"std={np.std(map_vx_rvir):.4g}, "f"skewness={skew(map_vx_rvir):.4g}, "f"kurtosis={kurtosis(map_vx_rvir):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_rvir stat: mean={np.mean(map_vy_rvir):.4g}, "f"median={np.median(map_vy_rvir):.4g}, "f"std={np.std(map_vy_rvir):.4g}, "f"skewness={skew(map_vy_rvir):.4g}, "f"kurtosis={kurtosis(map_vy_rvir):.4g}")
        # print(
        #    f"map_vz_rvir stat: mean={np.mean(map_vz_rvir):.4g}, "f"median={np.median(map_vz_rvir):.4g}, "f"std={np.std(map_vz_rvir):.4g}, "f"skewness={skew(map_vz_rvir):.4g}, "f"kurtosis={kurtosis(map_vz_rvir):.4g}")

        # map_vx_r500 = vx[r < r2]
        # map_vy_r500 = vy[r < r2]
        # map_vz_r500 = vz[r < r2]

        # print(
        #    f"map_vx_r500 stat: mean={np.mean(map_vx_r500):.4g}, "f"median={np.median(map_vx_r500):.4g}, "f"std={np.std(map_vx_r500):.4g}, "f"skewness={skew(map_vx_r500):.4g}, "f"kurtosis={kurtosis(map_vx_r500):.4g}")
        # print(
        #    f"map_vy_r500 stat: mean={np.mean(map_vy_r500):.4g}, "f"median={np.median(map_vy_r500):.4g}, "f"std={np.std(map_vy_r500):.4g}, "f"skewness={skew(map_vy_r500):.4g}, "f"kurtosis={kurtosis(map_vy_r500):.4g}")
        # print(
        #    f"map_vz_r500 stat: mean={np.mean(map_vz_r500):.4g}, "f"median={np.median(map_vz_r500):.4g}, "f"std={np.std(map_vz_r500):.4g}, "f"skewness={skew(map_vz_r500):.4g}, "f"kurtosis={kurtosis(map_vz_r500):.4g}")

        # print(
        #    f"map_vx_500 stat: mean={np.mean(map_vx_500):.4g}, "f"median={np.median(map_vx_500):.4g}, "f"std={np.std(map_vx_500):.4g}, "f"skewness={skew(map_vx_500):.4g}, "f"kurtosis={kurtosis(map_vx_500):.4g}")

        # sys.exit()

        # print(
        #    f"map_vy_500 stat: mean={np.mean(map_vy_500):.4g}, "f"median={np.median(map_vy_500):.4g}, "f"std={np.std(map_vy_500):.4g}, "f"skewness={skew(map_vy_500):.4g}, "f"kurtosis={kurtosis(map_vy_500):.4g}")
        # print(
        #    f"map_vz_500 stat: mean={np.mean(map_vz_500):.4g}, "f"median={np.median(map_vz_500):.4g}, "f"std={np.std(map_vz_500):.4g}, "f"skewness={skew(map_vz_500):.4g}, "f"kurtosis={kurtosis(map_vz_500):.4g}")

        # map_vx_100 = vx[r < r2]
        # map_vy_100 = vy[r < r2]
        # map_vz_100 = vz[r < r2]

        # print(
        #    f"map_vx_100 stat: mean={np.mean(map_vx_100):.4g}, "f"median={np.median(map_vx_100):.4g}, "f"std={np.std(map_vx_100):.4g}, "f"skewness={skew(map_vx_100):.4g}, "f"kurtosis={kurtosis(map_vx_100):.4g}")
        # print(
        #    f"map_vy_100 stat: mean={np.mean(map_vy_100):.4g}, "f"median={np.median(map_vy_100):.4g}, "f"std={np.std(map_vy_100):.4g}, "f"skewness={skew(map_vy_100):.4g}, "f"kurtosis={kurtosis(map_vy_100):.4g}")
        # print(
        #    f"map_vz_100 stat: mean={np.mean(map_vz_100):.4g}, "f"median={np.median(map_vz_100):.4g}, "f"std={np.std(map_vz_100):.4g}, "f"skewness={skew(map_vz_100):.4g}, "f"kurtosis={kurtosis(map_vz_100):.4g}")

        count, bins, _ = axs[0, 0].hist(map_vx_ew_rvir, bins=20, alpha=0.6, color='darkred', density=True, label="EW")

        # print("count",count)

        stat_matrix_ew = np.zeros((12,9))
        stat_matrix_mw = np.zeros((12,9))

        print("vx rvir")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_ew_rvir, count, bins)
        print(f"map_vx_ew_rvir stat: {np.median(map_vx_ew_rvir):.1f} "f"& {np.mean(map_vx_ew_rvir):.1F} "f"& {np.std(map_vx_ew_rvir):.1f} "f"& {skew(map_vx_ew_rvir):.2f} "f"& {kurtosis(map_vx_ew_rvir):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[0, :] = [np.median(map_vx_ew_rvir),np.mean(map_vx_ew_rvir),np.std(map_vx_ew_rvir),skew(map_vx_ew_rvir),kurtosis(map_vx_ew_rvir),popt[1],errors[1],popt[2],errors[2]]

        axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[0, 0].hist(map_vx_mw_rvir, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        # print("count",count)

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_mw_rvir, count, bins)
        print(f"map_vx_mw_rvir stat: {np.median(map_vx_mw_rvir):.1f} "f"& {np.mean(map_vx_mw_rvir):.1F} "f"& {np.std(map_vx_mw_rvir):.1f} "f"& {skew(map_vx_mw_rvir):.2f} "f"& {kurtosis(map_vx_mw_rvir):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[0, :] = [np.median(map_vx_mw_rvir),np.mean(map_vx_mw_rvir),np.std(map_vx_mw_rvir),skew(map_vx_mw_rvir),kurtosis(map_vx_mw_rvir),popt[1],errors[1],popt[2],errors[2]]


        axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[0,0].yscale('log')
        axs[0, 0].set_xlim(-990, 990)
        axs[0, 0].set_ylim(1e-5, height)
        # axs[0, 0].set_ylim(0, 1.2e6)
        # axs[0,0].legend(fontsize=10)
        # axs[0, 0].set_title("$V_x$")
        # axs[0,0].set_xlabel("Vx [km/s]")
        # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[0, 0].set_ylabel(pdfrvir)
        axs[0, 0].set_xticks([])
        axs[0, 0].legend(fontsize=10)
        axs[0, 0].set_yscale('log')
        axs[0, 0].axvline(np.mean(map_vx_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        axs[0, 0].axvline(np.mean(map_vx_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vy rvir")

        count, bins, _ = axs[0, 1].hist(map_vy_ew_rvir, bins=20, alpha=0.6, color='darkblue', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_ew_rvir, count, bins)
        print(f"map_vy_ew_rvir stat: {np.median(map_vy_ew_rvir):.1f} "f"& {np.mean(map_vy_ew_rvir):.1F} "f"& {np.std(map_vy_ew_rvir):.1f} "f"& {skew(map_vy_ew_rvir):.2f} "f"& {kurtosis(map_vy_ew_rvir):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[1, :] = [np.median(map_vy_ew_rvir), np.mean(map_vy_ew_rvir), np.std(map_vy_ew_rvir), skew(map_vy_ew_rvir), kurtosis(map_vy_ew_rvir), popt[1], errors[1], popt[2], errors[2]]

        axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[0, 1].hist(map_vy_mw_rvir, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_mw_rvir, count, bins)
        print(f"map_vy_mw_rvir stat: {np.median(map_vy_mw_rvir):.1f} "f"& {np.mean(map_vy_mw_rvir):.1F} "f"& {np.std(map_vy_mw_rvir):.1f} "f"& {skew(map_vy_mw_rvir):.2f} "f"& {kurtosis(map_vy_mw_rvir):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[1, :] = [np.median(map_vy_mw_rvir), np.mean(map_vy_mw_rvir), np.std(map_vy_mw_rvir), skew(map_vy_mw_rvir), kurtosis(map_vy_mw_rvir), popt[1], errors[1], popt[2], errors[2]]

        axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[0,1].yscale('log')
        axs[0, 1].set_xlim(-990, 990)
        axs[0, 1].set_ylim(1e-5, height)
        # axs[0, 1].set_ylim(0, 1.2e6)
        # axs[0,1].legend(fontsize=10)
        # axs[0, 1].set_title("y component")
        axs[0, 1].set_yticks([])
        axs[0, 1].yaxis.set_visible(False)
        # axs[0,1].set_xlabel("Vy [km/s]")
        axs[0, 1].set_xticks([])
        axs[0, 1].legend(fontsize=10)
        axs[0, 1].set_yscale('log')
        axs[0, 1].axvline(np.mean(map_vy_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        axs[0, 1].axvline(np.mean(map_vy_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vz rvir")

        count, bins, _ = axs[0, 2].hist(map_vz_ew_rvir, bins=20, alpha=0.6, color='darkgreen', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_ew_rvir, count, bins)
        print(f"map_vz_ew_rvir stat: {np.median(map_vz_ew_rvir):.1f} "f"& {np.mean(map_vz_ew_rvir):.1F} "f"& {np.std(map_vz_ew_rvir):.1f} "f"& {skew(map_vz_ew_rvir):.2f} "f"& {kurtosis(map_vz_ew_rvir):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[2, :] = [np.median(map_vz_ew_rvir), np.mean(map_vz_ew_rvir), np.std(map_vz_ew_rvir), skew(map_vz_ew_rvir), kurtosis(map_vz_ew_rvir), popt[1], errors[1], popt[2], errors[2]]

        axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[0, 2].hist(map_vz_mw_rvir, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_mw_rvir, count, bins)
        print(f"map_vz_mw_rvir stat: {np.median(map_vz_mw_rvir):.1f} "f"& {np.mean(map_vz_mw_rvir):.1F} "f"& {np.std(map_vz_mw_rvir):.1f} "f"& {skew(map_vz_mw_rvir):.2f} "f"& {kurtosis(map_vz_mw_rvir):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[2, :] = [np.median(map_vz_mw_rvir), np.mean(map_vz_mw_rvir), np.std(map_vz_mw_rvir), skew(map_vz_mw_rvir), kurtosis(map_vz_mw_rvir), popt[1], errors[1], popt[2], errors[2]]

        axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[0,2].yscale('log')
        axs[0, 2].set_xlim(-990, 990)
        axs[0, 2].set_ylim(1e-5, height)
        # axs[0, 2].set_ylim(0, 1.2e6)
        # axs[0,2].legend(fontsize=10)
        # axs[0, 2].set_title("z projection")
        # axs[0,2].set_xlabel("Vz [km/s]")
        axs[0, 2].set_yticks([])
        axs[0, 2].set_xticks([])
        axs[0, 2].yaxis.set_visible(False)
        axs[0, 2].legend(fontsize=10)
        axs[0, 2].set_yscale('log')
        axs[0, 2].axvline(np.mean(map_vz_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        axs[0, 2].axvline(np.mean(map_vz_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        print("vcen rvir")

        count, bins, _ = axs[0, 3].hist(map_vcen_ew_rvir, bins=20, alpha=0.6, color='mediumvioletred', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_ew_rvir, count, bins)
        print(f"map_vcen_ew_rvir stat: {np.median(map_vcen_ew_rvir):.1f} "f"& {np.mean(map_vcen_ew_rvir):.1F} "f"& {np.std(map_vcen_ew_rvir):.1f} "f"& {skew(map_vcen_ew_rvir):.2f} "f"& {kurtosis(map_vcen_ew_rvir):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[3, :] = [np.median(map_vcen_ew_rvir), np.mean(map_vcen_ew_rvir), np.std(map_vcen_ew_rvir), skew(map_vcen_ew_rvir), kurtosis(map_vcen_ew_rvir), popt[1], errors[1], popt[2], errors[2]]

        axs[0, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[0, 3].hist(map_vcen_mw_rvir, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_mw_rvir, count, bins)
        print(f"map_vcen_mw_rvir stat: {np.median(map_vcen_mw_rvir):.1f} "f"& {np.mean(map_vcen_mw_rvir):.1F} "f"& {np.std(map_vcen_mw_rvir):.1f} "f"& {skew(map_vcen_mw_rvir):.2f} "f"& {kurtosis(map_vcen_mw_rvir):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[3, :] = [np.median(map_vcen_mw_rvir), np.mean(map_vcen_mw_rvir), np.std(map_vcen_mw_rvir), skew(map_vcen_mw_rvir), kurtosis(map_vcen_mw_rvir), popt[1], errors[1], popt[2], errors[2]]

        axs[0, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        # axs[0,3].yscale('log')
        axs[0, 3].set_xlim(-990, 990)
        axs[0, 3].set_ylim(1e-5, height)
        # axs[0, 3].set_ylim(0, 1.2e6)
        # axs[0,3].legend(fontsize=10)
        # axs[0, 3].set_title("z projection")
        # axs[0,3].set_xlabel("vcen [km/s]")
        axs[0, 3].set_yticks([])
        axs[0, 3].set_xticks([])
        axs[0, 3].yaxis.set_visible(False)
        axs[0, 3].legend(fontsize=10)
        axs[0, 3].set_yscale('log')
        axs[0, 3].axvline(np.mean(map_vcen_ew_rvir), color='black', linestyle='dashed', linewidth=1)
        axs[0, 3].axvline(np.mean(map_vcen_mw_rvir), color='grey', linestyle='dashed', linewidth=1)

        # axs[0, 3].hist(map_vx_ew_rvir, bins=20, alpha=0.6, color='darkred', label='$V_x$', density=True)
        # axs[0, 3].hist(map_vy_ew_rvir, bins=20, alpha=0.6, color='darkblue', label='$V_y$', density=True)
        # axs[0, 3].hist(map_vz_ew_rvir, bins=20, alpha=0.6, color='darkgreen', label='$V_z$', density=True)
        # axs[0, 3].set_xlim(-990,990)
        # axs[0, 3].set_ylim(1e-5, height)
        # axs[0, 3].set_ylim(0, 1.2e6)
        # axs[0, 3].set_yticks([])
        # axs[0, 3].set_xticks([])
        # axs[0, 3].legend(fontsize=10)

        # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        print("vx r500")

        count, bins, _ = axs[1, 0].hist(map_vx_ew_r500, bins=20, alpha=0.6, color='red', density=True, label='EW')

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_ew_r500, count, bins)
        print(f"map_vx_ew_r500 stat: {np.median(map_vx_ew_r500):.1f} "f"& {np.mean(map_vx_ew_r500):.1F} "f"& {np.std(map_vx_ew_r500):.1f} "f"& {skew(map_vx_ew_r500):.2f} "f"& {kurtosis(map_vx_ew_r500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[4, :] = [np.median(map_vx_ew_r500), np.mean(map_vx_ew_r500), np.std(map_vx_ew_r500), skew(map_vx_ew_r500), kurtosis(map_vx_ew_r500), popt[1], errors[1], popt[2], errors[2]]

        axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[1, 0].hist(map_vx_mw_r500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_mw_r500, count, bins)
        print(f"map_vx_mw_r500 stat: {np.median(map_vx_mw_r500):.1f} "f"& {np.mean(map_vx_mw_r500):.1F} "f"& {np.std(map_vx_mw_r500):.1f} "f"& {skew(map_vx_mw_r500):.2f} "f"& {kurtosis(map_vx_mw_r500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[4, :] = [np.median(map_vx_mw_r500), np.mean(map_vx_mw_r500), np.std(map_vx_mw_r500), skew(map_vx_mw_r500), kurtosis(map_vx_mw_r500), popt[1], errors[1], popt[2], errors[2]]

        axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[1,0].yscale('log')
        axs[1, 0].set_xlim(-990, 990)
        axs[1, 0].set_ylim(1e-5, height)
        # axs[1, 0].set_ylim(0, 1.3e4)
        # axs[1,0].legend(fontsize=10)
        # axs[1,0].set_title("x projection")
        # axs[1,0].set_xlabel("Vx [km/s]")
        # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
        axs[1, 0].set_ylabel(pdfr500)
        axs[1, 0].set_xticks([])
        axs[1, 0].legend(fontsize=10)
        axs[1, 0].set_yscale('log')
        axs[1, 0].axvline(np.mean(map_vx_ew_r500), color='black', linestyle='dashed', linewidth=1)
        axs[1, 0].axvline(np.mean(map_vx_mw_r500), color='grey', linestyle='dashed', linewidth=1)

        print("vy r500")

        count, bins, _ = axs[1, 1].hist(map_vy_ew_r500, bins=20, alpha=0.6, color='blue', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_ew_r500, count, bins)
        print(f"map_vy_ew_r500 stat: {np.median(map_vy_ew_r500):.1f} "f"& {np.mean(map_vy_ew_r500):.1F} "f"& {np.std(map_vy_ew_r500):.1f} "f"& {skew(map_vy_ew_r500):.2f} "f"& {kurtosis(map_vy_ew_r500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[5, :] = [np.median(map_vy_ew_r500), np.mean(map_vy_ew_r500), np.std(map_vy_ew_r500), skew(map_vy_ew_r500), kurtosis(map_vy_ew_r500), popt[1], errors[1], popt[2], errors[2]]


        axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[1, 1].hist(map_vy_mw_r500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_mw_r500, count, bins)
        print(f"map_vy_mw_r500 stat: {np.median(map_vy_mw_r500):.1f} "f"& {np.mean(map_vy_mw_r500):.1F} "f"& {np.std(map_vy_mw_r500):.1f} "f"& {skew(map_vy_mw_r500):.2f} "f"& {kurtosis(map_vy_mw_r500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[5, :] = [np.median(map_vy_mw_r500), np.mean(map_vy_mw_r500), np.std(map_vy_mw_r500), skew(map_vy_mw_r500), kurtosis(map_vy_mw_r500), popt[1], errors[1], popt[2], errors[2]]

        axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[1,1].yscale('log')
        axs[1, 1].set_xlim(-990, 990)
        axs[1, 1].set_ylim(1e-5, height)
        # axs[1, 1].set_ylim(0, 1.3e4)
        # axs[1,1].legend(fontsize=10)
        # axs[1,1].set_title("y projection")
        axs[1, 1].set_yticks([])
        # axs[1,1].set_xlabel("Vy [km/s]")
        axs[1, 1].set_xticks([])
        axs[1, 1].legend(fontsize=10)
        axs[1, 1].set_yscale('log')
        axs[1, 1].yaxis.set_visible(False)
        axs[1, 1].axvline(np.mean(map_vy_ew_r500), color='black', linestyle='dashed', linewidth=1)
        axs[1, 1].axvline(np.mean(map_vy_mw_r500), color='grey', linestyle='dashed', linewidth=1)

        print("vz r500")

        count, bins, _ = axs[1, 2].hist(map_vz_ew_r500, bins=20, alpha=0.6, color='green', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_ew_r500, count, bins)
        print(f"map_vz_ew_r500 stat: {np.median(map_vz_ew_r500):.1f} "f"& {np.mean(map_vz_ew_r500):.1F} "f"& {np.std(map_vz_ew_r500):.1f} "f"& {skew(map_vz_ew_r500):.2f} "f"& {kurtosis(map_vz_ew_r500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[6, :] = [np.median(map_vz_ew_r500), np.mean(map_vz_ew_r500), np.std(map_vz_ew_r500), skew(map_vz_ew_r500), kurtosis(map_vz_ew_r500), popt[1], errors[1], popt[2], errors[2]]


        axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[1, 2].hist(map_vz_mw_r500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_mw_r500, count, bins)
        print(f"map_vz_mw_r500 stat: {np.median(map_vz_mw_r500):.1f} "f"& {np.mean(map_vz_mw_r500):.1F} "f"& {np.std(map_vz_mw_r500):.1f} "f"& {skew(map_vz_mw_r500):.2f} "f"& {kurtosis(map_vz_mw_r500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[6, :] = [np.median(map_vz_mw_r500), np.mean(map_vz_mw_r500), np.std(map_vz_mw_r500), skew(map_vz_mw_r500), kurtosis(map_vz_mw_r500), popt[1], errors[1], popt[2], errors[2]]

        axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[1,2].yscale('log')
        axs[1, 2].set_xlim(-990, 990)
        axs[1, 2].set_ylim(1e-5, height)
        # axs[1, 2].set_ylim(0, 1.3e4)
        # axs[1,2].legend(fontsize=10)
        # axs[1,2].set_title("z projection")
        # axs[1,2].set_xlabel("Vz [km/s]")
        axs[1, 2].set_yticks([])
        axs[1, 2].set_xticks([])
        axs[1, 2].legend(fontsize=10)
        axs[1, 2].set_yscale('log')
        axs[1, 2].yaxis.set_visible(False)
        axs[1, 2].axvline(np.mean(map_vz_ew_r500), color='black', linestyle='dashed', linewidth=1)
        axs[1, 2].axvline(np.mean(map_vz_mw_r500), color='grey', linestyle='dashed', linewidth=1)

        print("vcen r500")

        count, bins, _ = axs[1, 3].hist(map_vcen_ew_r500, bins=20, alpha=0.6, color='deeppink', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_ew_r500, count, bins)
        print(f"map_vcen_ew_r500 stat: {np.median(map_vcen_ew_r500):.1f} "f"& {np.mean(map_vcen_ew_r500):.1F} "f"& {np.std(map_vcen_ew_r500):.1f} "f"& {skew(map_vcen_ew_r500):.2f} "f"& {kurtosis(map_vcen_ew_r500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        axs[1, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        stat_matrix_ew[7, :] = [np.median(map_vcen_ew_r500), np.mean(map_vcen_ew_r500), np.std(map_vcen_ew_r500), skew(map_vcen_ew_r500), kurtosis(map_vcen_ew_r500), popt[1], errors[1], popt[2], errors[2]]


        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[1, 3].hist(map_vcen_mw_r500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_mw_r500, count, bins)
        print(f"map_vcen_mw_r500 stat: {np.median(map_vcen_mw_r500):.1f} "f"& {np.mean(map_vcen_mw_r500):.1F} "f"& {np.std(map_vcen_mw_r500):.1f} "f"& {skew(map_vcen_mw_r500):.2f} "f"& {kurtosis(map_vcen_mw_r500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[7, :] = [np.median(map_vcen_mw_r500), np.mean(map_vcen_mw_r500), np.std(map_vcen_mw_r500), skew(map_vcen_mw_r500), kurtosis(map_vcen_mw_r500), popt[1], errors[1], popt[2], errors[2]]

        axs[1, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        # axs[1,3].yscale('log')
        axs[1, 3].set_xlim(-990, 990)
        axs[1, 3].set_ylim(1e-5, height)
        # axs[1, 3].set_ylim(0, 1.3e4)
        # axs[1,3].legend(fontsize=10)
        # axs[1,3].set_title("z projection")
        # axs[1,3].set_xlabel("vcen [km/s]")
        axs[1, 3].set_yticks([])
        axs[1, 3].set_xticks([])
        axs[1, 3].legend(fontsize=10)
        axs[1, 3].set_yscale('log')
        axs[1, 3].yaxis.set_visible(False)
        axs[1, 3].axvline(np.mean(map_vcen_ew_r500), color='black', linestyle='dashed', linewidth=1)
        axs[1, 3].axvline(np.mean(map_vcen_mw_r500), color='grey', linestyle='dashed', linewidth=1)

        # axs[1, 3].hist(map_vx_ew_r500, bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
        # axs[1, 3].hist(map_vy_ew_r500, bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
        # axs[1, 3].hist(map_vz_ew_r500, bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
        # axs[1, 3].set_xlim(-990,990)
        # axs[1, 3].set_ylim(1e-5, height)
        # axs[1, 3].set_ylim(0, 1.3e4)
        # axs[1, 3].set_yticks([])
        # axs[1, 3].set_xticks([])
        # axs[1, 3].legend(fontsize=10)
        # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
        #         rotation=270, fontsize=14)

        ########################################
        ########################################

        large = 0

        if large == 0:
            r1 = 515
            r2 = 100
            plt.suptitle("Velocity components PDFs within spheres of 500kpc and 100kpc radii")
            pdfrvir = "PDF \n ($R<R_{2500}$)"
            pdfr500 = "PDF \n ($R<100\, \mathrm{kpc}$)"
            height1 = 0.004
            height = 0.01

        # vx_r1 = vx[r < r1]
        # vy_r1 = vy[r < r1]
        # vz_r1 = vz[r < r1]

        # vx_r2 = vx[r < r2]
        # vy_r2 = vy[r < r2]
        # vz_r2 = vz[r < r2]

        print("vx 500")

        count, bins, _ = axs[2, 0].hist(map_vx_ew_500, bins=20, alpha=0.6, color='orange', density=True, label="EW")

        # print("count",count)
        # sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_ew_500, count, bins)
        print(f"map_vx_ew_500 stat: {np.median(map_vx_ew_500):.1f} "f"& {np.mean(map_vx_ew_500):.1F} "f"& {np.std(map_vx_ew_500):.1f} "f"& {skew(map_vx_ew_500):.2f} "f"& {kurtosis(map_vx_ew_500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[8, :] = [np.median(map_vx_ew_500), np.mean(map_vx_ew_500), np.std(map_vx_ew_500), skew(map_vx_ew_500), kurtosis(map_vx_ew_500), popt[1], errors[1], popt[2], errors[2]]


        axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[2, 0].hist(map_vx_mw_500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        # print("count",count)
        # sys.exit()

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vx_mw_500, count, bins)
        print(f"map_vx_mw_500 stat: {np.median(map_vx_mw_500):.1f} "f"& {np.mean(map_vx_mw_500):.1F} "f"& {np.std(map_vx_mw_500):.1f} "f"& {skew(map_vx_mw_500):.2f} "f"& {kurtosis(map_vx_mw_500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[8, :] = [np.median(map_vx_mw_500), np.mean(map_vx_mw_500), np.std(map_vx_mw_500), skew(map_vx_mw_500), kurtosis(map_vx_mw_500), popt[1], errors[1], popt[2], errors[2]]

        axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[2,0].yscale('log')
        axs[2, 0].set_xlim(-990, 990)
        axs[2, 0].set_ylim(2e-4, height1)
        # axs[2, 0].set_ylim(0, 1.2e6)
        # axs[2,0].legend(fontsize=10)
        # axs[2, 0].set_title("$V_x$")
        # axs[2,0].set_xlabel("Vx [km/s]")
        # axs[2, 0].set_ylabel("PDF ($R<R_{vir}$)")
        axs[2, 0].set_ylabel(pdfrvir)
        axs[2, 0].set_xlabel("$v_{x}~[\mathrm{km~s^{-1}}]$")
        axs[2, 0].legend(fontsize=10)
        axs[2, 0].set_yscale('log')
        axs[2, 0].axvline(np.mean(map_vx_ew_500), color='black', linestyle='dashed', linewidth=1)
        axs[2, 0].axvline(np.mean(map_vx_mw_500), color='grey', linestyle='dashed', linewidth=1)

        print("vy 500")

        count, bins, _ = axs[2, 1].hist(map_vy_ew_500, bins=20, alpha=0.6, color='cornflowerblue', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_ew_500, count, bins)
        print(f"map_vy_ew_500 stat: {np.median(map_vy_ew_500):.1f} "f"& {np.mean(map_vy_ew_500):.1F} "f"& {np.std(map_vy_ew_500):.1f} "f"& {skew(map_vy_ew_500):.2f} "f"& {kurtosis(map_vy_ew_500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[9, :] = [np.median(map_vy_ew_500), np.mean(map_vy_ew_500), np.std(map_vy_ew_500), skew(map_vy_ew_500), kurtosis(map_vy_ew_500), popt[1], errors[1], popt[2], errors[2]]


        axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[2, 1].hist(map_vy_mw_500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vy_mw_500, count, bins)
        print(f"map_vy_mw_500 stat: {np.median(map_vy_mw_500):.1f} "f"& {np.mean(map_vy_mw_500):.1F} "f"& {np.std(map_vy_mw_500):.1f} "f"& {skew(map_vy_mw_500):.2f} "f"& {kurtosis(map_vy_mw_500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[9, :] = [np.median(map_vy_mw_500), np.mean(map_vy_mw_500), np.std(map_vy_mw_500), skew(map_vy_mw_500), kurtosis(map_vy_mw_500), popt[1], errors[1], popt[2], errors[2]]

        axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # xs[2,1].yscale('log')
        axs[2, 1].set_xlim(-990, 990)
        axs[2, 1].set_ylim(2e-4, height1)
        # axs[2, 1].set_ylim(0, 1.2e6)
        # axs[2,1].legend(fontsize=10)
        # axs[2, 1].set_title("y component")
        axs[2, 1].set_yticks([])
        # axs[2,1].set_xlabel("Vy [km/s]")
        axs[2, 1].set_xlabel("$v_{y}~[\mathrm{km~s^{-1}}]$")
        axs[2, 1].legend(fontsize=10)
        axs[2, 1].set_yscale('log')
        axs[2, 1].yaxis.set_visible(False)
        axs[2, 1].axvline(np.mean(map_vy_ew_500), color='black', linestyle='dashed', linewidth=1)
        axs[2, 1].axvline(np.mean(map_vy_mw_500), color='grey', linestyle='dashed', linewidth=1)

        print("vz 500")

        count, bins, _ = axs[2, 2].hist(map_vz_ew_500, bins=20, alpha=0.6, color='turquoise', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_ew_500, count, bins)
        print(f"map_vz_ew_500 stat: {np.median(map_vz_ew_500):.1f} "f"& {np.mean(map_vz_ew_500):.1F} "f"& {np.std(map_vz_ew_500):.1f} "f"& {skew(map_vz_ew_500):.2f} "f"& {kurtosis(map_vz_ew_500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[10, :] = [np.median(map_vz_ew_500), np.mean(map_vz_ew_500), np.std(map_vz_ew_500), skew(map_vz_ew_500), kurtosis(map_vz_ew_500), popt[1], errors[1], popt[2], errors[2]]


        axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[2, 2].hist(map_vz_mw_500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vz_mw_500, count, bins)
        print(f"map_vz_mw_500 stat: {np.median(map_vz_mw_500):.1f} "f"& {np.mean(map_vz_mw_500):.1F} "f"& {np.std(map_vz_mw_500):.1f} "f"& {skew(map_vz_mw_500):.2f} "f"& {kurtosis(map_vz_mw_500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[10, :] = [np.median(map_vz_mw_500), np.mean(map_vz_mw_500), np.std(map_vz_mw_500), skew(map_vz_mw_500), kurtosis(map_vz_mw_500), popt[1], errors[1], popt[2], errors[2]]

        axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

        # axs[2,2].yscale('log')
        axs[2, 2].set_xlim(-990, 990)
        axs[2, 2].set_ylim(2e-4, height1)
        # axs[2, 2].set_ylim(0, 1.2e6)
        # axs[2,2].legend(fontsize=10)
        # axs[2, 2].set_title("z projection")
        # axs[2,2].set_xlabel("Vz [km/s]")
        axs[2, 2].set_xlabel("$v_{z}~[\mathrm{km~s^{-1}}]$")
        axs[2, 2].set_yticks([])
        axs[2, 2].legend(fontsize=10)
        axs[2, 2].set_yscale('log')
        axs[2, 2].yaxis.set_visible(False)
        axs[2, 2].axvline(np.mean(map_vz_ew_500), color='black', linestyle='dashed', linewidth=1)
        axs[2, 2].axvline(np.mean(map_vz_mw_500), color='grey', linestyle='dashed', linewidth=1)

        print("vcen 500")

        count, bins, _ = axs[2, 3].hist(map_vcen_ew_500, bins=20, alpha=0.6, color='hotpink', density=True, label="EW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_ew_500, count, bins)
        print(f"map_vcen_ew_500 stat: {np.median(map_vcen_ew_500):.1f} "f"& {np.mean(map_vcen_ew_500):.1F} "f"& {np.std(map_vcen_ew_500):.1f} "f"& {skew(map_vcen_ew_500):.2f} "f"& {kurtosis(map_vcen_ew_500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_ew[11, :] = [np.median(map_vcen_ew_500), np.mean(map_vcen_ew_500), np.std(map_vcen_ew_500), skew(map_vcen_ew_500), kurtosis(map_vcen_ew_500), popt[1], errors[1], popt[2], errors[2]]


        axs[2, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        count, bins, _ = axs[2, 3].hist(map_vcen_mw_500, bins=20, alpha=0.5, color='grey', density=True, label="MW")

        popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(map_vcen_mw_500, count, bins)
        print(f"map_vcen_mw_500 stat: {np.median(map_vcen_mw_500):.1f} "f"& {np.mean(map_vcen_mw_500):.1F} "f"& {np.std(map_vcen_mw_500):.1f} "f"& {skew(map_vcen_mw_500):.2f} "f"& {kurtosis(map_vcen_mw_500):.2f} "f"& {popt[1]:.1f} ± {errors[1]:.1f} "f"& {popt[2]:.1f} ± {errors[2]:.1f}")
        stat_matrix_mw[11, :] = [np.median(map_vcen_mw_500), np.mean(map_vcen_mw_500), np.std(map_vcen_mw_500), skew(map_vcen_mw_500), kurtosis(map_vcen_mw_500), popt[1], errors[1], popt[2], errors[2]]

        axs[2, 3].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='grey')  # ,
        # label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
        #    popt[1], errors[1], popt[3], errors[3], popt[3], errors[3], chi2, red_chi2))

        # axs[2,3].yscale('log')
        axs[2, 3].set_xlim(-990, 990)
        axs[2, 3].set_ylim(2e-4, height1)
        # axs[2, 3].set_ylim(0, 1.2e6)
        # axs[2,3].legend(fontsize=10)
        # axs[2, 3].set_title("z projection")
        # axs[2,3].set_xlabel("vcen [km/s]")
        axs[2, 3].set_yticks([])
        axs[2, 3].set_xlabel("$v_{cen}~[\mathrm{km~s^{-1}}]$")
        axs[2, 3].legend(fontsize=10)
        axs[2, 3].set_yscale('log')
        axs[2, 3].yaxis.set_visible(False)
        axs[2, 3].axvline(np.mean(map_vcen_ew_500), color='black', linestyle='dashed', linewidth=1)
        axs[2, 3].axvline(np.mean(map_vcen_mw_500), color='grey', linestyle='dashed', linewidth=1)

        plt.suptitle("MW vs EW projected velocity distribution within $R_{vir}$, $R_{500}$ and $R_{2500}$ ")

        #plt.savefig("pdfs_2D.png", dpi=300)

        print(stat_matrix_ew)
        np.save("stats_2D_pdf_ew.npy",stat_matrix_ew)

        print(stat_matrix_mw)
        np.save("stats_2D_pdf_mw.npy", stat_matrix_mw)

        print("files saved")

    #mw_maps_plot()

    #mw_vs_ew_plot()

    #mw_overplot_rad()

    mw_vs_ew_wo_100_plot()

    plt.show()

    sys.exit()


    sys.exit()

def scaling_relation_2D_vs_3D_stats():

    stat_3D = np.load('stats_3D_pdf.npy')
    stats_2D_ew = np.load('stats_2D_pdf_ew.npy')
    stats_2D_mw = np.load('stats_2D_pdf_mw.npy')


    diag=[-100,30]

    f,ax = plt.subplots(1,5,figsize=(16,4))

    range_l_x = [-120,-100,180,-0.5,-0.4]
    range_r_x = [40,20,380,0.7,3]

    range_l_y = [-120, -100, 90, -0.75, -1.2]
    range_r_y = [40, 25, 240, 1.1, 3.3]

    def affine_fit(x,a,b):
        return a*x+b


    for i in range(5):
        plt.sca(ax[i])

        #plt.plot(diag,diag,color='black')

        #EW
        #rvir
        plt.scatter(stat_3D[0, i],stats_2D_ew[0, i],color='black',marker='x')
        plt.scatter(stat_3D[1, i], stats_2D_ew[1, i],color='black',marker='x')
        plt.scatter(stat_3D[2, i], stats_2D_ew[2, i],color='black',marker='x')

        # r500
        plt.scatter(stat_3D[3, i], stats_2D_ew[4, i],color='black',marker='x')
        plt.scatter(stat_3D[4, i], stats_2D_ew[5, i],color='black',marker='x')
        plt.scatter(stat_3D[5, i], stats_2D_ew[6, i],color='black',marker='x')

        #r2500
        plt.scatter(stat_3D[6, i],stats_2D_ew[8, i],color='black',marker='x')
        plt.scatter(stat_3D[7, i], stats_2D_ew[9, i],color='black',marker='x')
        plt.scatter(stat_3D[8, i], stats_2D_ew[10, i],color='black',marker='x')

        #MW
        #rvir
        plt.scatter(stat_3D[0, i], stats_2D_mw[0, i],color='grey',marker='.')
        plt.scatter(stat_3D[1, i], stats_2D_mw[1, i],color='grey',marker='.')
        plt.scatter(stat_3D[2, i], stats_2D_mw[2, i],color='grey',marker='.')

        #r500
        plt.scatter(stat_3D[3, i], stats_2D_mw[4, i],color='grey',marker='.')
        plt.scatter(stat_3D[4, i], stats_2D_mw[5, i],color='grey',marker='.')
        plt.scatter(stat_3D[5, i], stats_2D_mw[6, i],color='grey',marker='.')

        #r2500
        plt.scatter(stat_3D[6, i], stats_2D_mw[8, i],color='grey',marker='.')
        plt.scatter(stat_3D[7, i], stats_2D_mw[9, i],color='grey',marker='.')
        plt.scatter(stat_3D[8, i], stats_2D_mw[10, i],color='grey',marker='.')

        plt.xlim(range_l_x[i], range_r_x[i])
        plt.ylim(range_l_y[i], range_r_y[i])

        stats_2D_ew_fit = [*stats_2D_ew[0:3,i], *stats_2D_ew[4:7,i], *stats_2D_ew[8:11,i]]
        stats_2D_mw_fit = [*stats_2D_mw[0:3,i], *stats_2D_mw[4:7,i], *stats_2D_mw[8:11,i]]

        popt, pcov = curve_fit(affine_fit,stat_3D[:, i], stats_2D_ew_fit)
        label = 'EW: a=' + str(round(popt[0],2)) + "±" + str(round(pcov[0,0],2)) + '\n' + 'b=' + str(round(popt[1],2)) + "±" + str(round(pcov[1,1],2))
        print(label)
        plt.plot(stat_3D[:, i], affine_fit(stat_3D[:, i],*popt), color='black',ls='dashed',label=label)
        popt, pcov = curve_fit(affine_fit, stat_3D[:, i], stats_2D_mw_fit)
        label = 'MW: a=' + str(round(popt[0],2)) + "±" + str(round(pcov[0,0],2)) + '\n' + 'b=' + str(round(popt[1],2)) + "±" + str(round(pcov[1,1],2))
        print(label)
        plt.plot(stat_3D[:, i], affine_fit(stat_3D[:, i], *popt), color='grey', ls='dashed',label=label)
        plt.legend(prop={'size': 9},loc='best')

        plt.xlabel('3D')
        if i==0:
            plt.ylabel('2D')

    ax[0].set_title("median [$\mathrm{km~s^{-1}}$]")
    ax[1].set_title("$\mu$ [$\mathrm{km~s^{-1}}$]")
    ax[2].set_title("$\sigma$ [$\mathrm{km~s^{-1}}$]")
    ax[3].set_title("skewnees")
    ax[4].set_title("kurtosis")
    plt.tight_layout()
    plt.suptitle("affine fit : $y_{2D}=ax_{3D}+b$")
    plt.show()


def scaling_relation_2D_vs_3D_stats_random_projs():

    pdf_stats_2D= np.zeros((100,15))

    create_stat_file=0


    if create_stat_file==1:

        def load_map(file,proj):
            h = FortranFile(file, 'r')
            nx, ny, nz = h.read_ints()
            cen_x, cen_y, cen_z = h.read_reals()
            #print("nx,ny,nz", nx, ny, nz)
            # print("cen_x,cen_y,cen_z",cen_x,cen_y,cen_z)
            # sys.exit()
            # ncell = 0
            # print(ncell.dtype)
            # sys.exit()
            # ncell = np
            # sys.exit()
            if proj == "x":
                ncell = nz * ny
            elif proj == "y":
                ncell = nx * nz
            elif proj == "z":
                # ncell = np.uint64(nx * ny)
                ncell = nx * ny
            #print("ncell", ncell)

            map = np.zeros(ncell)

            map = ftp.f90_to_py.read_map_file(ncell, file, 0)
            # map=h.read_reals()

            print("len nan",len(map[np.isnan(map)==True]),'ratio, ',len(map[np.isnan(map)==True])/len(map))
            #sys.exit()

            if proj == "x":
                map = np.reshape(map, (nz, ny))
                #map2 = np.reshape(map2, (nz, ny))
                #map3 = np.reshape(map3, (nz, ny))
                nl = nx
            elif proj == "y":
                map = np.reshape(map, (nx, nz))
                #map2 = np.reshape(map2, (nx, nz))
                #map3 = np.reshape(map3, (nx, nz))
                nl = ny
            elif proj == "z":
                map = np.reshape(map, (ny, nx))
                #map2 = np.reshape(map2, (ny, nx))
                #map3 = np.reshape(map3, (ny, nx))
                nl = nz

            #print('file loaded')
            # sys.exit()

            # for i in range(len(map[0, :])):
            #    for j in range(len(map[:, 0])):
            #        if (map[i, j] == 0):
            #            map[i, j] = np.nan

            # map2 = np.loadtxt("map_2000px_z_ne_los_cleanall+T1e5_highr.txt")
            # for i in range(len(map2[0, :])):
            #    for j in range(len(map2[:, 0])):
            # if (map2[i, j] == 0):
            #    map2[i, j] = 1e-50

            # map-=map2
            #print(map)
            #print("min=", np.min(map))
            #print("max=", np.max(map))

            return map

        d = np.load("map_distances_lvl15_proj_vel_5Mpc_222.npy")

        #print("max d",np.max(d))
        #sys.exit()

        for i in range(0,100):
            print("i",i)
            if i<10:
                #file = "map_high_15f15_rand_0" + str(i) + "_map_v_mw_Tsup7_5Mpc2.bin"
                file = "map_high_15f15_rand_0" + str(i) + "_map_vd_ew_Tsup7_5Mpc2.bin"
            else:
                #file = "map_high_15f15_rand_" + str(i) + "_map_v_mw_Tsup7_5Mpc2.bin"
                file = "map_high_15f15_rand_" + str(i) + "_map_vd_ew_Tsup7_5Mpc2.bin"

            print('filename',file)

            file = "./maps/high_res/velocity/15f15_analysis/random_proj/"+file

            map=load_map(file,"z")

            map_rvir=map[d<2147]
            map_r500=map[d<1087]
            map_r2500=map[d<515]

            pdf_stats_2D[i, 0:5] = [np.nanmedian(map_rvir), np.nanmean(map_rvir),np.nanstd(map_rvir), skew(map_rvir,nan_policy='omit'), kurtosis(map_rvir,nan_policy='omit')]
            pdf_stats_2D[i, 5:10] = [np.nanmedian(map_r500), np.nanmean(map_r500), np.nanstd(map_r500), skew(map_r500,nan_policy='omit'), kurtosis(map_r500,nan_policy='omit')]
            pdf_stats_2D[i, 10:15] = [np.nanmedian(map_r2500), np.nanmean(map_r2500), np.nanstd(map_r2500), skew(map_r2500,nan_policy='omit'), kurtosis(map_r2500,nan_policy='omit')]
            #print(np.nanmedian(map_rvir), np.nanmean(map_rvir), np.nanstd(map_rvir), skew(map_rvir, nan_policy='omit'), kurtosis(map_rvir, nan_policy='omit'))

            #print("pdf_stats_2D",pdf_stats_2D[i,:])
            #sys.exit()
        #sys.exit()
        np.save("stats_2D_pdf_100_rand_proj_EW_vd.npy",pdf_stats_2D)

        stats_2D = pdf_stats_2D
        print("stats saved")
        sys.exit()

    else:
        #stats_2D_EW = np.load("stats_2D_pdf_100_rand_proj_EW.npy")
        #stats_2D_MW = np.load("stats_2D_pdf_100_rand_proj_MW.npy")

        vd=0

        if vd==1:
            stats_2D_EW = np.load("stats_2D_pdf_100_rand_proj_EW_vd.npy")
            stats_2D_MW = np.load("stats_2D_pdf_100_rand_proj_MW_vd.npy")
        else:
            stats_2D_EW = np.load("stats_2D_pdf_100_rand_proj_EW.npy")
            stats_2D_MW = np.load("stats_2D_pdf_100_rand_proj_MW.npy")

        #print(stats_2D[:,0])
        #plt.hist(stats_2D[:, 0])
        #plt.show()
        #sys.exit()
        #print("stats_2D_EW",stats_2D_EW)
        #print("stats_2D_MW", stats_2D_MW)


    #stats_3D = np.load('stats_3D_pdf_vnorm.npy')
    #stats_3D_std = np.load('stats_3D_pdf_vstd.npy')

    stats_3D = np.load('stats_3D_pdf_vnorm_mw.npy')
    stats_3D_std = np.load('stats_3D_pdf_vstd_mw.npy')
    #stats_2D_ew = np.load('stats_2D_pdf_ew.npy')
    #stats_2D_mw = np.load('stats_2D_pdf_mw.npy')


    def affine_fit(x, a, b):
        return a * x + b

    def hists_sigma(vd):

        f,a=plt.subplots(1,3)

        data_EW = (stats_2D_EW[:, 12-vd] / stats_3D[12])
        data_MW = (stats_2D_MW[:, 12-vd] / stats_3D[12])

        print("len nan EW", len(data_EW[np.isnan(data_EW) == True]), 'ratio, ', len(data_EW[np.isnan(data_EW) == True]) / len(data_EW))
        print("len nan MW", len(data_MW[np.isnan(data_MW) == True]), 'ratio, ', len(data_MW[np.isnan(data_MW) == True]) / len(data_MW))
        #print("data EW",data_EW)
        #print("data MW",data_MW)
        #sys.exit()

        a[0].hist(data_EW, alpha=0.6, color='orange', label='EW',bins=20,range=[0,2])
        a[0].axvline(np.nanmean(data_EW), ls="dashed", color='orange',label="mean ="+str(round(np.nanmean(data_EW),2)))
        a[0].axvline(np.nanmedian(data_EW), ls="dotted", color='orange', label='median =' + str(round(np.nanmedian(data_EW), 2)))

        a[0].hist(data_MW, alpha=0.6, color='cornflowerblue', label='MW',bins=20,range=[0,2])
        a[0].axvline(np.nanmean(data_MW), ls="dashed", color='cornflowerblue',label="mean ="+str(round(np.nanmean(data_MW),2)))
        a[0].axvline(np.nanmedian(data_MW), ls="dotted", color='cornflowerblue',label='median ='+str(round(np.nanmedian(data_MW),2)))

        a[0].set_title("$R_{2500}$",fontsize=22)
        a[0].set_ylabel('$N_{projections}$',fontsize=22)
        a[0].set_xlim(0,2)
        #a[0].set_ylim(0, 40)
        a[0].axvline(1,ls="dashed",color='grey')#,label=r'$\sqrt{3}\approx 1.73$')
        #a[0].text(np.sqrt(3), 0.2, "$\sqrt{3}$", size=14, color='grey')

        a[0].legend(prop={'size': 16})

        a[0].tick_params(axis="x",labelsize=20)
        a[0].tick_params(axis="y", labelsize=20)

        #print('mean data_MW',np.mean(data_MW))

        data_EW = (stats_2D_EW[:, 7-vd] / stats_3D[7])
        data_MW = (stats_2D_MW[:, 7-vd] / stats_3D[7])

        a[1].hist(data_EW, alpha=0.6, color='red', label='EW',bins=20,range=[0,2])
        a[1].axvline(np.nanmean(data_EW), ls="dashed", color='red',label="mean ="+str(round(np.nanmean(data_EW),2)))
        a[1].axvline(np.nanmedian(data_EW), ls="dotted", color='red', label='median =' + str(round(np.nanmedian(data_EW), 2)))

        a[1].hist(data_MW, alpha=0.6, color='blue', label='MW',bins=20,range=[0,2])
        a[1].axvline(np.nanmean(data_MW), ls="dashed", color='blue', label="mean =" + str(round(np.nanmean(data_MW), 2)))
        a[1].axvline(np.nanmedian(data_MW), ls="dotted", color='blue', label='median =' + str(round(np.nanmedian(data_MW), 2)))
        a[1].set_title("$R_{500}$",fontsize=22)
        a[1].set_xlim(0, 2)
        #a[1].set_ylim(0, 40)
        a[1].set_yticks([])
        a[1].axvline(1, ls="dashed", color='grey')#,label=r'$\sqrt{3}\approx 1.73$')
        #a[1].text(np.sqrt(3), 0.2, "$\sqrt{3}$", size=14, color='grey')
        a[1].legend(prop={'size': 16})

        a[1].tick_params(axis="x",labelsize=20)
        a[1].tick_params(axis="y", labelsize=20)



        data_EW = (stats_2D_EW[:, 2-vd] / stats_3D[2])
        data_MW = (stats_2D_MW[:, 2-vd] / stats_3D[2])

        a[2].hist(data_EW, alpha=0.6, color='darkred', label='EW',bins=20,range=[0,2])
        a[2].axvline(np.nanmean(data_EW), ls="dashed", color='darkred', label='mean =' + str(round(np.nanmean(data_EW), 2)))
        a[2].axvline(np.nanmedian(data_EW), ls="dotted", color='darkred', label='median =' + str(round(np.nanmedian(data_EW), 2)))

        a[2].hist(data_MW, alpha=0.6, color='darkblue', label='MW',bins=20,range=[0,2])
        a[2].axvline(np.nanmean(data_MW), ls="dashed", color='darkblue', label='mean =' + str(round(np.nanmean(data_MW), 2)))
        a[2].axvline(np.nanmedian(data_MW), ls="dotted", color='darkblue', label='median =' + str(round(np.nanmedian(data_MW), 2)))

        a[2].set_title("$R_{vir}$",fontsize=22)
        a[2].set_xlim(0, 2)
        #a[2].set_ylim(0, 40)
        a[2].set_yticks([])
        a[2].axvline(1, ls="dashed", color='grey')#,label=r'$\sqrt{3}\approx 1.73$')
        #a[2].text(np.sqrt(3), 0.2, "$\sqrt{3}$", size=14, color='grey')
        a[2].legend(prop={'size': 16})

        a[2].tick_params(axis="x",labelsize=20)
        a[2].tick_params(axis="y", labelsize=20)


        if vd==1:
            a[0].set_xlabel('$\sigma_{los}/\sigma_{sim}$',fontsize=22)
            a[1].set_xlabel('$\sigma_{los}/\sigma_{sim}$',fontsize=22)
            a[2].set_xlabel('$\sigma_{los}/\sigma_{sim}$',fontsize=22)
            plt.suptitle('$\sigma_{los}$',fontsize=22)
        else:
            a[0].set_xlabel('$\sigma_{proj}/\sigma_{sim}$',fontsize=22)
            a[1].set_xlabel('$\sigma_{proj}/\sigma_{sim}$',fontsize=22)
            a[2].set_xlabel('$\sigma_{proj}/\sigma_{sim}$',fontsize=22)
            plt.suptitle('$\sigma_{proj}=std(v_{los})$',fontsize=22)


        plt.show()

        sys.exit()

    def hist_std_comp_Gatuzz():

        f, a = plt.subplots(1, 1)

        data_EW = stats_2D_EW[:, 12 - vd]
        data_MW = stats_2D_MW[:, 12 - vd]

        print("len nan EW", len(data_EW[np.isnan(data_EW) == True]), 'ratio, ', len(data_EW[np.isnan(data_EW) == True]) / len(data_EW))
        print("len nan MW", len(data_MW[np.isnan(data_MW) == True]), 'ratio, ', len(data_MW[np.isnan(data_MW) == True]) / len(data_MW))
        # print("data EW",data_EW)
        # print("data MW",data_MW)
        # sys.exit()

        a.hist(data_EW, alpha=0.6, color='orange', label='EW', bins=20)#, range=[0, 2])
        a.axvline(np.nanmean(data_EW), ls="dashed", color='orange', label="mean =" + str(round(np.nanmean(data_EW), 2)))
        a.axvline(np.nanmedian(data_EW), ls="dotted", color='orange', label='median =' + str(round(np.nanmedian(data_EW), 2)))

        a.hist(data_MW, alpha=0.6, color='cornflowerblue', label='MW', bins=20)#, range=[0, 2])
        a.axvline(np.nanmean(data_MW), ls="dashed", color='cornflowerblue', label="mean =" + str(round(np.nanmean(data_MW), 2)))
        a.axvline(np.nanmedian(data_MW), ls="dotted", color='cornflowerblue', label='median =' + str(round(np.nanmedian(data_MW), 2)))

        a.set_title(r"$R_{2500}\approx500~kpc$", fontsize=22)
        a.set_ylabel('$N_{projections}$', fontsize=22)
        #a.set_xlim(0, 2)
        # a.set_ylim(0, 40)
        a.axvline(344, ls="dashed", color='red',label='Gatuzz et al. 2023')# ,label=r'$\sqrt{3}\approx 1.73$')
        a.axvspan(326, 362, alpha=0.5, color='red')
        # a.text(np.sqrt(3), 0.2, "$\sqrt{3}$", size=14, color='grey')

        a.legend(prop={'size': 16},loc="upper left", bbox_to_anchor=(0.4,0.95))

        a.tick_params(axis="x", labelsize=20)
        a.tick_params(axis="y", labelsize=20)

        a.set_xlabel('$\sigma_{proj}~[\mathrm{km~s^{-1}}]$', fontsize=22)

        plt.show()

        sys.exit()

    def bootstrap_test():

        start=time.time()
        data = [stats_2D_EW[i,4] for i in range(len(stats_2D_EW[:,0]))]
        #print(data)
        #sys.exit()

        sample_mean=[]# samples must be in a sequence
        
        for i in range(500):
            #print("i",i)
            y=random.sample(data,20)
            avg=np.mean(y)
            sample_mean.append(avg)

        #res = bootstrap(data, np.mean,n_resamples=1000)

        print("calculation time", time.time() - start)

        plt.hist(sample_mean, bins=25)

        #fig, ax = plt.subplots()

        #plt.hist(res.bootstrap_distribution, bins=25)

        plt.title('EW skewness within $R_{vir}$')

        plt.xlabel('Mean')

        plt.ylabel('$N_{subsample}$')

        plt.show()

        sys.exit()

    #bootstrap_test()

    hist_std_comp_Gatuzz()


    #hists_sigma(vd)


    diag = [-100, 30]

    f, ax = plt.subplots(1, 5, figsize=(16, 4))

    range_l_x = [-120, -120, 180, -0.5, -0.4]
    range_r_x = [40, 40, 380, 0.7, 3]

    range_l_y = [-120, -100, 90, -0.75, -1.2]
    range_r_y = [40, 25, 240, 1.1, 3.3]

    for i in range(5):
        #print("i",i)
        plt.sca(ax[i])


        # plt.plot(diag,diag,color='black')

        # EW
        # rvir
        #plt.scatter(stat_3D[0, i], stats_2D_EW_ew[0, i], color='black', marker='x')
        #plt.scatter(stat_3D[1, i], stats_2D_EW_ew[1, i], color='black', marker='x')
        #plt.scatter(stat_3D[2, i], stats_2D_EW_ew[2, i], color='black', marker='x')
        plt.scatter(stats_3D[i],np.nanmean(stats_2D_EW[:,i]),c='darkred',alpha=0.6,label="ew $R_{vir}$")
        plt.errorbar(stats_3D[i], np.nanmean(stats_2D_EW[:, i]),yerr=np.nanstd(stats_2D_EW[:,i]),xerr=stats_3D_std[i],c='darkred',alpha=0.6)
        #print("2D_EW mean",np.nanmean(stats_2D_EW[:, i]),"std",np.nanstd(stats_2D_EW[:,i]))
        #print("3D",stats_3D[i])
        # r500
        #plt.scatter(stat_3D[3, i], stats_2D_EW_ew[4, i], color='black', marker='x')
        #plt.scatter(stat_3D[4, i], stats_2D_EW_ew[5, i], color='black', marker='x')
        #plt.scatter(stat_3D[5, i], stats_2D_EW_ew[6, i], color='black', marker='x')

        plt.scatter(stats_3D[i+5], np.nanmean(stats_2D_EW[:, i+5]),c='red',alpha=0.6, label="ew $R_{500}$")
        plt.errorbar(stats_3D[i+5], np.nanmean(stats_2D_EW[:, i+5]), yerr=np.nanstd(stats_2D_EW[:, i+5]),xerr=stats_3D_std[i+5],c='red',alpha=0.6)

        # r2500
        #plt.scatter(stat_3D[6, i], stats_2D_EW_ew[8, i], color='black', marker='x')
        #plt.scatter(stat_3D[7, i], stats_2D_EW_ew[9, i], color='black', marker='x')
        #plt.scatter(stat_3D[8, i], stats_2D_EW_ew[10, i], color='black', marker='x')

        plt.scatter(stats_3D[i+10], np.nanmean(stats_2D_EW[:, i+10]),c='orange',alpha=0.6,label="ew $R_{2500}$")
        plt.errorbar(stats_3D[i+10], np.nanmean(stats_2D_EW[:, i+10]), yerr=np.nanstd(stats_2D_EW[:, i+10]),xerr=stats_3D_std[i+10],c='orange',alpha=0.6)

        # MW
        # rvir
        #plt.scatter(stat_3D[0, i], stats_2D_mw[0, i], color='grey', marker='.')
        #plt.scatter(stat_3D[1, i], stats_2D_mw[1, i], color='grey', marker='.')
        #plt.scatter(stat_3D[2, i], stats_2D_mw[2, i], color='grey', marker='.')
        plt.scatter(stats_3D[i],np.nanmean(stats_2D_MW[:,i]),c='darkblue',alpha=0.6,label="mw $R_{vir}$")
        eb=plt.errorbar(stats_3D[i], np.nanmean(stats_2D_MW[:, i]),yerr=np.nanstd(stats_2D_MW[:,i]),xerr=stats_3D_std[i],c='darkblue',alpha=0.6, ls='-.')
        eb[-1][0].set_linestyle('--')
        eb[-1][1].set_linestyle('--')

        #print("errorbar mw rvir", np.nanstd(stats_2D_MW[:,i]))

        # r500
        #plt.scatter(stat_3D[3, i], stats_2D_mw[4, i], color='grey', marker='.')
        #plt.scatter(stat_3D[4, i], stats_2D_mw[5, i], color='grey', marker='.')
        #plt.scatter(stat_3D[5, i], stats_2D_mw[6, i], color='grey', marker='.')
        plt.scatter(stats_3D[i+5], np.nanmean(stats_2D_MW[:, i+5]),c='blue',alpha=0.6,label="mw $R_{500}$")
        eb=plt.errorbar(stats_3D[i+5], np.nanmean(stats_2D_MW[:, i+5]), yerr=np.nanstd(stats_2D_MW[:, i+5]),xerr=stats_3D_std[i+5],c='blue',alpha=0.6, fmt='-.')
        eb[-1][0].set_linestyle('--')
        eb[-1][1].set_linestyle('--')


        # r2500
        #plt.scatter(stat_3D[6, i], stats_2D_mw[8, i], color='grey', marker='.')
        #plt.scatter(stat_3D[7, i], stats_2D_mw[9, i], color='grey', marker='.')
        #plt.scatter(stat_3D[8, i], stats_2D_mw[10, i], color='grey', marker='.')
        plt.scatter(stats_3D[i + 10], np.nanmean(stats_2D_MW[:, i + 10]), c='cornflowerblue',alpha=0.6,label="mw $R_{2500}$")
        eb=plt.errorbar(stats_3D[i + 10], np.nanmean(stats_2D_MW[:, i + 10]), yerr=np.nanstd(stats_2D_MW[:, i + 10]),xerr=stats_3D_std[i+10], c='cornflowerblue',alpha=0.6, fmt='-.')
        eb[-1][0].set_linestyle('--')
        eb[-1][1].set_linestyle('--')

        x=np.linspace(80,320)
        if i ==2:
            plt.plot(x,x,ls='dotted',color='grey')
            plt.xlim(85,320)
            plt.ylim(85,320)


        else:
            plt.axvline(x=0,ls='dotted',color='grey')
            plt.axhline(y=0,ls='dotted', color='grey')

            if i==0 or i==1:
                plt.xlim(-120,20)
                plt.ylim(-80,80)

        #plt.xlim(range_l_x[i], range_r_x[i])
        #plt.ylim(range_l_y[i], range_r_y[i])
        if i==2:
            print('ratio sigma_3D/sigma_2D ew : rvir ',stats_3D[i]/np.nanmean(stats_2D_EW[:,i]),'r500 ',stats_3D[i+5]/np.nanmean(stats_2D_EW[:,i+5]),'r2500 ',stats_3D[i+10]/np.nanmean(stats_2D_EW[:,i+10]))
            print('ratio sigma_3D/sigma_2D mw : rvir ', stats_3D[i] / np.nanmean(stats_2D_MW[:, i]), 'r500 ', stats_3D[i + 5] / np.nanmean(stats_2D_MW[:, i + 5]), 'r2500 ', stats_3D[i + 10] / np.nanmean(stats_2D_MW[:, i + 10]))

        stat_3D_fit = np.array([stats_3D[i],stats_3D[i + 5],stats_3D[i + 10]])
        stat_2D_ew_fit = np.array([[np.nanmean(stats_2D_EW[:, i]),np.nanmean(stats_2D_EW[:, i + 5]),np.nanmean(stats_2D_EW[:, i + 10])],[np.nanstd(stats_2D_EW[:, i ]),np.nanstd(stats_2D_EW[:, i + 5]),np.nanstd(stats_2D_EW[:, i + 10])]])
        stat_2D_mw_fit = np.array([[np.nanmean(stats_2D_MW[:, i]),np.nanmean(stats_2D_MW[:, i + 5]),np.nanmean(stats_2D_MW[:, i + 10])],[np.nanstd(stats_2D_MW[:, i ]),np.nanstd(stats_2D_MW[:, i + 5]),np.nanstd(stats_2D_MW[:, i + 10])]])

        #print(stat_2D_ew_fit[0,:])
        #sys.exit()
        #stats_2D_ew_fit = [*stats_2D_ew[0:3, i], *stats_2D_ew[4:7, i], *stats_2D_ew[8:11, i]]
        #stats_2D_mw_fit = [*stats_2D_mw[0:3, i], *stats_2D_mw[4:7, i], *stats_2D_mw[8:11, i]]

        #popt, pcov = curve_fit(affine_fit, stat_3D[:, i], stats_2D_ew_fit)
        #popt, pcov = curve_fit(affine_fit, stat_3D_fit, stat_2D_ew_fit[0,:])
        #label = 'EW: a=' + str(round(popt[0], 2)) + "±" + str(round(pcov[0, 0], 2)) + '\n' + 'b=' + str(round(popt[1], 2)) + "±" + str(round(pcov[1, 1], 2))
        #print(label)
        #plt.plot(stat_3D_fit, affine_fit(stat_3D_fit, *popt), color='black', ls='dashed', label=label)

        #popt, pcov = curve_fit(affine_fit, stat_3D_fit, stat_2D_mw_fit[0,:])
        #label = 'MW: a=' + str(round(popt[0], 2)) + "±" + str(round(pcov[0, 0], 2)) + '\n' + 'b=' + str(round(popt[1], 2)) + "±" + str(round(pcov[1, 1], 2))
        #print(label)
        #plt.plot(stat_3D_fit, affine_fit(stat_3D_fit, *popt), color='grey', ls='dashed', label=label)
        #plt.legend(prop={'size': 9}, loc='best')

        plt.xlabel('3D')
        if i == 0:
            plt.ylabel('projected')
        #if i==4:
            #plt.legend(loc='upper right',ncol=1,prop={'size': 12})

    ax[0].set_title("median [$\mathrm{km~s^{-1}}$]")
    ax[1].set_title("$\mu$ [$\mathrm{km~s^{-1}}$]")
    ax[2].set_title("$\sigma$ [$\mathrm{km~s^{-1}}$]")
    ax[3].set_title("skewness")
    ax[4].set_title("kurtosis")
    plt.tight_layout()
    #plt.suptitle("affine fit : $y_{2D}=ax_{3D}+b$")
    plt.show()

def masses_estimation(dim):

    ##dim : 3 = 3D, 2 =2D
    def hydro(file, t_cut, mean_med, log_before, n):
        print('hydro')
        print(file)
        h = FortranFile(file, 'r')

        ncell = h.read_ints()
        print("ncell", ncell)

        print("ne")
        n_e = []
        n_e = h.read_reals()

        print("t")
        t = []
        t = h.read_reals()

        print("p")
        p = []
        p = h.read_reals()

        print("x")
        x = []
        x = h.read_reals()

        print('y')
        y = []
        y = h.read_reals()

        print("z")
        z = []
        z = h.read_reals()

        print("vx")
        vx = []
        vx = h.read_reals()

        print("vy")
        vy = []
        vy = h.read_reals()

        print("vz")
        vz = []
        vz = h.read_reals()

        print("m")
        m = []
        m = h.read_reals()

        print("lvl")
        lvl = []
        lvl = h.read_reals()

        m_cumul_ba = np.zeros(21)

        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        # @jit(nopython=True)
        def change_units(x, y, z, p, n_e, t, m, vx, vy, vz, lvl,t_cut):
            x_cen = 0.48461068
            y_cen = 0.50809848
            z_cen = 0.49687076

            x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
            y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
            z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

            # print("x_cen", x_cen, "y_cen", y_cen, "z_cen", z_cen)

            x-=x_cen
            y-=y_cen
            z-=z_cen

            r = np.sqrt(x ** 2 + y ** 2 + z ** 2)
            # r=np.array(r)

            vx_virgo = -509.1301
            vy_virgo = 228.9488
            vz_virgo = -131.9249

            vz -= vz_virgo
            vy -= vy_virgo
            vx -= vx_virgo

            # n_e *= 1E6 / 0.864
            n_e /= 0.864  # np/ne = 0.864
            # plt.hist(np.log10(n_e),bins=100,range=[-3,7])
            # plt.show()
            # sys.exit()

            p /= 10
            #print("max p in km m s units", np.max(p))
            p /= 1.602 * 10 ** (-10)
            p *= (0.76 / 0.864)
            #print("max p in Kev",np.max(p))
            sys.exit()
            # print("P",p)
            print("nb part", len(n_e))

            ###define velocity in spherical coordinates and velocity dispersion

            rho = np.sqrt(x ** 2 + y ** 2)

            vr = (x*vx + y*vy + z*vz)/r
            vtheta = (z*(vx*x+vy*y)-(x**2+y**2)*vz)/(r*rho)
            vphi=(x*vy-y*vx)/rho



            # m_no_cut = m
            # r_no_cut = r

            if t_cut == 1:
                rnocut=r
                mnocut=m
                lim = 0
                cond = np.logical_and(t > 1E5, n_e > 0)  # Standard condition
                # cond = np.logical_and(t > 1E5,np.logical_and(n_e > 0,np.logical_and(x>x_cen,np.logical_and(y>y_cen,z>z_cen)))) #Conditions for sectors study
                n_e2 = n_e[cond]
                t = t[cond]
                x = x[cond]
                y = y[cond]
                z = z[cond]
                p = p[cond]
                r = r[cond]
                m = m[cond]
                t = t[cond]
                vx = vx[cond]
                vy = vy[cond]
                vz = vz[cond]
                lvl = lvl[cond]
                n_e = n_e2
                #t = t_2
                #x = x_2
                #y = y_2
                #z = z_2

            if t_cut == 2:
                rnocut = r
                mnocut = m
                cond = np.logical_and(t > 1E7, n_e > 0)
                n_e2 = n_e[cond]
                p = p[cond]
                r = r[cond]
                m = m[cond]
                t = t[cond]
                vr = vr[cond]
                vtheta = vtheta[cond]
                vphi = vphi[cond]
                vx = vx[cond]
                vy = vy[cond]
                vz = vz[cond]
                n_e = n_e2

            print("nb part after cut", len(n_e))

            # t *= kb / 1.602e-16

            k = t / n_e ** (2 / 3)

            rho = n_e * me * 1e3

            # vx*=1e6
            # vy*=1e6
            # vz*=1e6 #comprendre pk j'avais mis *1e6 et pk ça a l'air de marcher (plutôt que *1e5 qui permettrait de passer de km/s à cm/s)

            rlog = np.log10(r)
            rlognocut = np.log10(rnocut)

            if log_before == 1:
                p = np.log10(p)
                t = np.log10(t)
                n_e = np.log10(n_e)
                k = np.log10(k)


            ####test for validity of method : log before sum ok ?

            # np.save("p_test.npy",p)
            # np.save("m_test.npy",m)
            # np.save("ne_test.npy",n_e)

            ####

            return x, y, z, p, n_e, t, m, rlog, k, rho, vx, vy, vz, lvl, vr , vtheta, vphi, rlognocut, mnocut

        # start=time.time()
        x, y, z, p, n_e, t, m, rlog, k, rho, vx, vy, vz, lvl, vr, vtheta, vphi, rlognocut,mnocut = change_units(x, y, z, p, n_e, t, m, vx, vy, vz, lvl,2)

        print("unit change done")#, plotting histogram")

        def normal_scale():
            for i in range(400):
                print(i)
                cond = np.logical_and(r > i * 10, r < (i + 1) * 10)
                t_sum = t[cond]
                m_sum = m[cond]
                if np.sum(m_sum) > 0:
                    t_rad[i] = np.sum(t_sum * m_sum) / np.sum(m_sum)
                else:
                    t_rad[i] = np.nan
                ne_rad[i] = np.median(n_e[cond])
                p_rad[i] = np.median(p[cond])
                # m_rad[i]=np.sum(m_sum)
                m_rad[i] = np.sum(m_no_cut[np.logical_and(r_no_cut > i * 10, r_no_cut < (i + 1) * 10)])
                n_rad[i] = len(m_sum)
                # print(n_rad)
                # nb=int(n_rad[i]*0.5)
                # print("nb",nb)
                # med=np.zeros(100)
                # if(nb>1):
                #    for j in range(100):
                #        #print(j)
                #        med[j]=np.median(resample(n_e[cond],n_samples=nb))
                #
                #        ne_rad_std[i]=np.std(med)
                #    else:
                #        ne_rad_std[i]=0

        # @jit(nopython=True)
        def log_scale(n):
            x_cen = 0.48461068
            y_cen = 0.50809848
            z_cen = 0.49687076
            x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
            y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
            z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

            # n = 40 #modif pr secteurs :77, 40 avant (pour 40 bins de 0.05)

            p_rad_log = np.zeros(n)
            t_rad_log = np.zeros(n)
            ne_rad_log = np.zeros(n)
            n_log = np.zeros(n)
            m_rad_log = np.zeros(n)
            err_p = np.zeros(n)
            err_ne = np.zeros(n)
            err_t = np.zeros(n)

            p_turb = np.zeros(n)
            err_pturb = np.zeros(n)

            k_rad_log = np.zeros(n)
            err_k = np.zeros(n)

            vt_rad_log = np.zeros(n)
            vr_rad_log = np.zeros(n)
            sigma_r_2_rad_log = np.zeros(n)
            sigma_t_2_rad_log = np.zeros(n)

            print("med_mean=", mean_med)

            ####test for validity of method : log before sum ok ?

            # p_test = np.load("p_test.npy")
            # m_test = np.load("m_test.npy")
            # n_e_test = np.load("ne_test.npy")

            # p_rad_test = np.zeros(n)
            # ne_rad_test = np.zeros(n)

            ####

            # m_cumul_ba=np.zeros(40)

            ###### modif pour secteurs:
            # n = 77
            rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])
            rlogbin = np.array([10 ** ((35 + i) * 0.05) for i in range(n)])



            for i in range(0, n):
                print(i)

                #cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
                # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
                #cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))

                # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y > y_cen,z > z_cen)))) #Sector 8 = Spherical Collapse
                # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x < x_cen,np.logical_and(y < y_cen,z < z_cen))))  # Sector 1 = Relaxed
                # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y < y_cen, z < z_cen))))  # Sector 5 = Filament

                #cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)
                cond = np.logical_and(rlog > (i + 17.5) * 0.1, rlog < (i + 18.5) * 0.1)


                m_sum_log = m[cond]
                m_rad_log[i] = m_sum_log.sum()
                n_log[i] = len(m[cond])
                # rlim = 10 ** ((35.5 + i) * 0.05)
                # print(i, 'rlim ', rlim)
                # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
                # m_cumul_ba[i] = np.sum(m[r < rlim])

                # print('test')
                if mean_med == 1:
                    # print('test 1')
                    p_sum_log = p[cond]
                    ne_sum_log = n_e[cond]
                    t_sum_log = t[cond]
                    k_sum_log = k[cond]



                    # print('test 1.5')
                    # print("msumlog",m_sum_log)
                    # print("psumlog",p_sum_log)
                    p_rad_log[i] = np.sum(p_sum_log * m_sum_log) / np.sum(m_sum_log)
                    # print('test 2')
                    ne_rad_log[i] = np.sum(ne_sum_log * m_sum_log) / np.sum(m_sum_log)
                    # print('test 3')
                    t_rad_log[i] = np.sum(t_sum_log * m_sum_log) / np.sum(m_sum_log)
                    # print('test 4')
                    err_ne[i] = np.sqrt(np.sum(m_sum_log * (ne_sum_log - ne_rad_log[i]) ** 2) / np.sum(m_sum_log))
                    err_t[i] = np.sqrt(np.sum(m_sum_log * (t_sum_log - t_rad_log[i]) ** 2) / np.sum(m_sum_log))
                    err_p[i] = np.sqrt(np.sum(m_sum_log * (p_sum_log - p_rad_log[i]) ** 2) / np.sum(m_sum_log))

                    k_rad_log[i] = np.sum(k_sum_log * m_sum_log) / np.sum(m_sum_log)
                    err_k[i] = np.sqrt(np.sum(m_sum_log * (k_sum_log - k_rad_log[i]) ** 2) / np.sum(m_sum_log))

                    # used in paper 1 to estimate p_nth

                    vxmean = np.mean(vx[cond])
                    vymean = np.mean(vy[cond])
                    vzmean = np.mean(vz[cond])
                    sigmax = np.sum(m_sum_log * (vx[cond] - vxmean) ** 2) / np.sum(m_sum_log)
                    sigmay = np.sum(m_sum_log * (vy[cond] - vymean) ** 2) / np.sum(m_sum_log)
                    sigmaz = np.sum(m_sum_log * (vz[cond] - vzmean) ** 2) / np.sum(m_sum_log)
                    sigmatot = sigmax + sigmay + sigmaz
                    rhomean = np.sum(rho[cond] * m_sum_log) / np.sum(m_sum_log)

                    p_turb[i] = rhomean * sigmatot

                    ##### paper 4 ####

                    vt=np.sqrt(vtheta**2+vphi**2)

                    vt_rad_log[i] = np.sum(vt[cond] * m_sum_log) / np.sum(m_sum_log)
                    vt_rad_log_2 = np.sum(vt[cond] ** 2 * m_sum_log) / np.sum(m_sum_log)
                    sigma_t_2_rad_log[i] = vt_rad_log_2 - vt_rad_log[i] ** 2

                    vr_rad_log[i] = np.sum(vr[cond] * m_sum_log) / np.sum(m_sum_log)
                    vr_rad_log_2=np.sum(vr[cond]**2 * m_sum_log) / np.sum(m_sum_log)
                    sigma_r_2_rad_log[i]=vr_rad_log_2-vr_rad_log[i]**2

                    vtheta_rad_log = np.sum(vtheta[cond] * m_sum_log) / np.sum(m_sum_log)
                    vtheta_rad_log_2 = np.sum(vtheta[cond] ** 2 * m_sum_log) / np.sum(m_sum_log)
                    sigma_theta_2_rad_log = vtheta_rad_log_2 - vtheta_rad_log ** 2

                    vphi_rad_log = np.sum(vphi[cond] * m_sum_log) / np.sum(m_sum_log)
                    vphi_rad_log_2 = np.sum(vphi[cond] ** 2 * m_sum_log) / np.sum(m_sum_log)
                    sigma_phi_2_rad_log = vphi_rad_log_2 - vphi_rad_log ** 2

                    #print("vt_rad_log",vt_rad_log[i])
                    #print("sigma_t_2_rad_log",sigma_t_2_rad_log[i],"sigma_t_rad_log",np.sqrt(sigma_t_2_rad_log[i]))

                    #print("vr_rad_log",vr_rad_log)
                    #print("sigma_r_2_rad_log",sigma_r_2_rad_log[i],"sigma_r_rad_log",np.sqrt(sigma_r_2_rad_log[i]))

                    #print("vtheta_rad_log",vtheta_rad_log)
                    #print("sigma_theta_2_rad_log",sigma_theta_2_rad_log)

                    #print("vphi_rad_log",vphi_rad_log)
                    #print("sigma_phi_2_rad_log",sigma_phi_2_rad_log)

                    #print("v_car_module",np.sqrt(vx**2+vy**2+vz**2))
                    #print("v_sph_module",np.sqrt(vr**2+vtheta**2+vphi**2))

                    #sys.exit()

                #print("ne rad log[0]",ne_rad_log[i])
                #print("p rad log[0]",p_rad_log[i])
                #sys.exit()

                condnocut = np.logical_and(rlognocut > (i + 17.5) * 0.1, rlognocut < (i + 18.5) * 0.1)
                m_sum_log = mnocut[condnocut]
                m_rad_log[i] = m_sum_log.sum()


            p_turb /= 10
            p_turb /= 1.602 * 10 ** (-10)
            p_turb = np.log10(p_turb)
            # print("p_turb log", p_turb)

            if log_before == 0:
                err_p = err_p / (np.log(10) * p_rad_log)
                err_t = err_t / (np.log(10) * t_rad_log)
                err_ne = err_ne / (np.log(10) * ne_rad_log)
                err_k = err_k / (np.log(10) * k_rad_log)
                p_rad_log = np.log10(p_rad_log)
                t_rad_log = np.log10(t_rad_log)
                ne_rad_log = np.log10(ne_rad_log)
                k_rad_log = np.log10(k_rad_log)
                sigma_r_2_rad_log = np.log10(sigma_r_2_rad_log)
                sigma_t_2_rad_log = np.log10(sigma_t_2_rad_log)
                vt_rad_log = np.log10(vt_rad_log)
                #vr_rad_log = np.log10(vr_rad_log)

            mass_before_1st_bin = np.sum(mnocut[rlognocut < 17.5 * 0.1])

            return p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_ne, err_p, err_t, err_k, p_turb, vr_rad_log, vt_rad_log, sigma_r_2_rad_log, sigma_t_2_rad_log,mass_before_1st_bin

        def test():
            p_rad_log = np.array(
                [np.median(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
            ne_rad_log = np.array(
                [np.median(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
            n_log = np.array(
                [len(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
            m_rad_log = np.array(
                [np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
            t_rad_log = np.array([np.sum(tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * m[
                np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) / np.sum(
                m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])

            mad_ne_log = np.array(
                [np.median(
                    np.abs(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - ne_rad_log[i]))
                 for i in range(40)])
            mad_plog = np.array(
                [np.median(np.abs(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - p_rad_log[i]))
                 for
                 i in range(40)])
            w_std_plog = np.array([np.sqrt(np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * (
                    tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - t_rad_log[i]) ** 2) / np.sum(
                m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)])) for i in range(40)])

            return p_rad_log, t_rad_log, ne_rad_log, m_rad_log, n_log, mad_ne_log, mad_plog, w_std_plog

        # start=time.time()
        p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_nelog, err_plog, err_tlog, err_klog, p_turb, vr_rad_log, vt_rad_log, sigma_r_2_rad_log, sigma_t_2_rad_log, mass_before_1st_bin = log_scale(n)

        #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

        ptot = 10 ** p_rad_log + 10 ** p_turb
        alpha = (10 ** p_turb) / ptot
        # plt.scatter(rlogbin_cen,p_rad_log,s=6, c='orange')
        # plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted', label='$8192^3$', alpha=0.7, c='orange')
        # plt.xscale('log')
        # plt.show()
        # np.save("alpha.npy",alpha)
        # sys.exit()

        # end=time.time()
        # print("durée:",end-start)

        # rratio=rlogbin_cen/1087
        # krad=np.array([10**k_rad_log[i] for i in range(len(k_rad_log))])

        # rad_data = np.zeros((2, 40))
        # rad_data[0,:]=krad
        # rad_data[1,:]=krad*err_klog
        # np.save("K_prof_high",rad_data)

        # plt.plot(rratio,10**p_turb/(10**p_rad_log))
        # plt.scatter(rlogbin_cen, krad, s=6, c='green',label='Entropy')
        # plt.errorbar(rlogbin_cen, krad, yerr=krad*err_klog, ls='dotted', label='3D, 8192^3', alpha=0.7, c='orange')
        # plt.scatter(rlogbin_cen, p_rad_log, s=6, c='orange')
        # plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted',label='Rescaled data (lvl=15, low res)', alpha=0.7, c='orange')
        # plt.scatter(rlogbin_cen,np.log10(10**p_rad_log+10**p_turb),label='P_tot',s=6,c='blue')
        # plt.xscale('log')
        # plt.yscale('log')
        # plt.yscale('log')
        # plt.axvline(x=1087, color='grey')
        # plt.text(1087, 2.75, "$R_{500}$", rotation=90, size=16)
        # plt.axvline(x=2147, color='grey', ls='dashed')
        # plt.text(2147, 2.75, "$R_{vir}$", rotation=90, size=16)
        # plt.xlabel("R(kpc)", size=16)
        # plt.ylabel('$log_{10}(K[keV.cm^{2}])$')
        # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
        # plt.legend(prop={'size': 16})
        # plt.show()

        # sys.exit()

        # return t_rad, ne_rad, p_rad, m_rad, n_rad, p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, ne_rad_std, mad_ne_log, mad_plog, w_std_plog
        return p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, err_nelog, err_plog, err_tlog, err_klog, p_turb, vr_rad_log, vt_rad_log, sigma_r_2_rad_log, sigma_t_2_rad_log, mass_before_1st_bin

    def dm(file,nbin):

        d = FortranFile(file, 'r')

        ncell = d.read_ints()

        xdm, ydm, zdm, mdm, vx, vy, vz = ftp.f90_to_py.read_dm(ncell, file)
        print("lecture données fini")

        #x_cen = 0.48461068
        #y_cen = 0.50809848
        #z_cen = 0.49687076

        #x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        #y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        #z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        # print("xcen", x_cen)

        # r = [np.sqrt((x[i] - x_cen) ** 2 + (y[i] - y_cen) ** 2 + (z[i] - z_cen) ** 2) for i in range(len(x))]

        r = np.sqrt(xdm ** 2 + ydm ** 2 + zdm ** 2)
        # plt.hist(r)
        # plt.scatter(x[0::10000],y[0::10000],c='black')
        # plt.scatter(x_cen,y_cen,s=20,c="blue")
        # plt.show()
        # sys.exit()
        rlog = np.log10(r)
        rlog = np.array(rlog)
        # print(rlog)

        print('rayon part dm fini')

        #nbin = 20

        m_rad = np.zeros(nbin)
        n_rad = np.zeros(nbin)

        rlogbin = np.array([10 ** ((17.5 + i) * 0.1) for i in range(nbin + 1)])
        #rlogbin = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])

        for i in range(0,nbin):
            #cond = np.logical_and(rlog > (i + 35) * 0.1, rlog < (i + 36) * 0.1)
            cond = np.logical_and(rlog > (i + 17.5) * 0.1, rlog < (i + 18.5) * 0.1)
            m_rad[i] = np.sum(mdm[cond])
            n_rad[i] = len(mdm[cond])
            # print("mass in bin", i, " :", m_rad[i])
            # print("nbr of particles in rad", i, " :", n_rad[i])

        # msum=np.array(np.sum(m_rad[0:i] for i in range(nbin)))
        # print("msums",msum)
        # np.savetxt("lograd_dm_21.txt")
        # sys.exit()

        mass_before_1st_bin = np.sum(mdm[rlog < 17.5 * 0.1])

        return m_rad, n_rad, mass_before_1st_bin

    def compute_mass(plog, tlog, ne_log, m_tot, unit, sigma_r2_log, sigma_t2_log, vt_log,nbin):
        def mhex(i, tlog, ne_log, unit):
            r_bin = i
            b = 0.1
            dt = np.gradient(tlog, b)
            dne = np.gradient(ne_log, b)
            dt = dt[r_bin]
            dne = dne[r_bin]
            if unit == 0:
                #m = (((-10 ** ((i + 35.5) * 0.05) * kb * 10 ** tlog[r_bin]) / (g * mu * mp)) * (dne + dt)) * (
                #        (1E3 * pc) / m_sun)

                m = (((-10 ** ((18 + i) * 0.1) * kb * 10 ** tlog[r_bin]) / (g * mu * mp)) * (dne + dt)) * (
                        (1E3 * pc) / m_sun)


                sm = 0
                dne = 0
                dt = 0

            if unit == 1:
                m = (((-10 ** ((i + 35) * 0.05) * 10 ** tlog[r_bin]) / (g * mu * mp)) * (dne + dt)) * (
                        (1E3 * pc * kev) / m_sun)

                invt = np.array([1 / (10 ** tlog[i]) for i in range(len(tlog))])
                # print("invt", invt)
                dinvt = np.gradient(invt, b)
                dinvt = dinvt[r_bin]

                invne = np.array([1 / (10 ** ne_log[i]) for i in range(len(ne_log))])
                # print("invp", invne)
                dinvne = np.gradient(invne, b)
                dinvne = dinvne[r_bin]

                dmdne = -((10 ** ((i + 35) * 0.05) * dinvne * 10 ** tlog[i]) / (g * mu * mp)) * (
                        (1E3 * pc * kev) / m_sun)
                dmdt = m / (10 ** tlog[r_bin]) - ((10 ** ((i + 35) * 0.05) * dinvt * 10 ** tlog[i]) / (g * mu * mp)) * (
                        (1E3 * pc * kev) / m_sun)
                sm = np.sqrt(
                    dmdne ** 2 * (10 ** sne[i] * 10 ** ne_log[i]) ** 2 + dmdt ** 2 * (10 ** st[i] * 10 ** tlog[i]) ** 2)
                # print("sm", sm)
                # print("m", m)

            return m, sm, dne, dt

        def mhesz(i, plog, ne_log, unit):
            b = 0.1
            r_bin = i
            dp = np.gradient(plog, b)
            dp = dp[r_bin]
            if unit == 0:
                #m = ((-10 ** ((i + 35.5) * 0.05) * 10 ** plog[r_bin] * dp) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                #        (1E3 * pc * kev) / m_sun)

                m = ((-10 ** ((18 + i) * 0.1) * 10 ** plog[r_bin] * dp) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                        (1E3 * pc * kev) / m_sun)



                sm = 0
                dp = 0

            if unit == 1:
                m = ((-10 ** ((i + 35) * 0.05) * 10 ** plog[r_bin] * dp) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                        (1E3 * pc * kev) / m_sun)

                invp = np.array([1 / (10 ** plog[i]) for i in range(len(plog))])
                # print("invp",invp)
                dinvp = np.gradient(invp, b)
                dinvp = dinvp[r_bin]
                # print("dinvp",dinvp)
                dmdne = -m / (10 ** ne_log[r_bin])
                dmdp = m / (10 ** plog[r_bin]) - (
                        (10 ** ((i + 35) * 0.05) * dinvp * 10 ** plog[i]) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                               (1E3 * pc * kev) / m_sun)
                # dmdp=0
                sm = np.sqrt(
                    dmdne ** 2 * (10 ** sne[i] * 10 ** ne_log[i]) ** 2 + dmdp ** 2 * (10 ** sp[i] * 10 ** plog[i]) ** 2)
                # print("sne",sne[i])
                # print("sp",sp[i])
                # print("dmdne",dmdne)
                # print("dmdp",dmdp)
                # print("sm",sm)
                # print("m ",m)
                # sys.exit()
            return m, sm, dp

        def mhecorr(i, plog, ne_log, mhesz, alpha):
            b = 0.1
            r_bin = i
            dalpha = np.gradient(alpha, b)
            dalpha = dalpha[r_bin]
            # print("dalpha",dalpha)
            #mcorr = (1 / (1 - alpha[r_bin])) * (mhesz - (alpha[r_bin] / (1 - alpha[r_bin])) * (
                    #(10 ** ((i + 35.5) * 0.05) * 10 ** plog[r_bin] * dalpha) / (g * mu * mp * 10 ** ne_log[r_bin])) * ((1E3 * pc * kev) / m_sun))

            mcorr = (1 / (1 - alpha[r_bin])) * (mhesz - (alpha[r_bin] / (1 - alpha[r_bin])) * (
                    (10 ** ((18 + i) * 0.1) * 10 ** plog[r_bin] * dalpha) / (g * mu * mp * 10 ** ne_log[r_bin])) * ((1E3 * pc * kev) / m_sun))

            # print("mcorr",mcorr)
            return mcorr

        def m_rand(i, ne_log, sigma_r2_log, sigma_t2_log):
            b = 0.1
            r_bin = i
            dne = np.gradient(ne_log, b)
            dne = dne[r_bin]
            dsigma_r2 = np.gradient(sigma_r2_log, b)
            dsigma_r2 = dsigma_r2[r_bin]

            #print("dne",dne,"dsigma_r2",dsigma_r2)

            #m = (-10 ** ((i + 35.5) * 0.05) * (10 ** sigma_r2_log[r_bin] * (dne + dsigma_r2 + 2) - 10 ** sigma_t2_log[r_bin]) / g) * ((1E3 * pc * 1E6) / m_sun)

            m = (-10 ** ((18 + i) * 0.1) * (10 ** sigma_r2_log[r_bin] * (dne + dsigma_r2 + 2) - 10 ** sigma_t2_log[r_bin]) / g) * ((1E3 * pc * 1E6) / m_sun)

            #print("sigma_r2*dne",10 ** sigma_r2_log[r_bin] * dne,"sigma_r2*dsigma_r2",10 ** sigma_r2_log[r_bin] * dsigma_r2,"sigma_r2*2",10 ** sigma_r2_log[r_bin] * 2 ,"sigma_t2", -10 ** sigma_t2_log[r_bin])
            #print("Ratios : sigma_r2*dne ", (10 ** sigma_r2_log[r_bin] * dne)/(10 ** sigma_r2_log[r_bin] * (dne + dsigma_r2 + 2) - 10 ** sigma_t2_log[r_bin]), "sigma_r2*dsigma_r2", (10 ** sigma_r2_log[r_bin] * dsigma_r2)/(10 ** sigma_r2_log[r_bin] * (dne + dsigma_r2 + 2) - 10 ** sigma_t2_log[r_bin]), "sigma_r2*2", (10 ** sigma_r2_log[r_bin] * 2)/(10 ** sigma_r2_log[r_bin] * (dne + dsigma_r2 + 2) - 10 ** sigma_t2_log[r_bin]), "sigma_t2", (-10 ** sigma_t2_log[r_bin])/(10 ** sigma_r2_log[r_bin] * (dne + dsigma_r2 + 2) - 10 ** sigma_t2_log[r_bin]))
            #print()
            #sys.exit()

            return m

        def m_rot(i, vt_log):
            b = 0.1
            r_bin = i

            #m = (10 ** ((i + 35.5) * 0.05) * (10**vt_log[r_bin]) ** 2 / g) * ((1E3 * pc * 1E6) / m_sun)

            m = (10 ** ((18 + i) * 0.1) * (10 ** vt_log[r_bin]) ** 2 / g) * ((1E3 * pc * 1E6) / m_sun)

            return m

        def compar_bias(i, plog, tlog, ne_log, m_tot, alpha, sigma_r2_log, sigma_t2_log, vt_log):
            mxlog, smx, dne, dt = mhex(i, tlog, ne_log, unit)
            # print("mhexlog", f"{mxlog:.3e}", "M_sun")
            mszlog, smsz, dp = mhesz(i, plog, ne_log, unit)
            mcorrlog = mhecorr(i, plog, ne_log, mszlog, alpha)
            mrandlog = m_rand(i, ne_log, sigma_r2_log, sigma_t2_log)
            mrotlog = m_rot(i, vt_log)
            malllog = mszlog + mrandlog + mrotlog

            #print("i",i,"msz", f"{mszlog:.3e}"," mcorr", f"{mcorrlog:.3e}", " mrand", f"{mrandlog:.3e}", " mrot", f"{mrotlog:.3e}", " mall", f"{malllog:.3e}"," mtot[i]",f"{m_tot[i]:.3e}", "M_sun")

            #sys.exit()

            #print("mrand", f"{mrandlog:.3e}", "M_sun")
            #return mxlog / m_tot[i], mszlog / m_tot[i], dne, dt, dp, smx / m_tot[i], smsz / m_tot[i], mcorr / m_tot[i], mall / m_tot[i]
            return mxlog, mszlog, mcorrlog, mrandlog, mrotlog, malllog
            # return mxlog,mszlog,dne,dt,dp,smx,smsz

        bx = np.zeros(nbin)
        bsz = np.zeros(nbin)
        dne = np.zeros(nbin)
        dt = np.zeros(nbin)
        dp = np.zeros(nbin)
        smx = np.zeros(nbin)
        smsz = np.zeros(nbin)
        bcorr = np.zeros(nbin)
        ball = np.zeros(nbin)

        mx = np.zeros(nbin)
        msz = np.zeros(nbin)
        mrand = np.zeros(nbin)
        mrot = np.zeros(nbin)
        mall = np.zeros(nbin)
        mcorr = np.zeros(nbin)

        alpha = np.load('alpha.npy')

        for i in range(nbin):
            #bx[i], bsz[i], dne[i], dt[i], dp[i], smx[i], smsz[i], bcorr[i], ball[i] = compar_bias(i, plog, tlog, ne_log, m_tot,alpha, sigma_r2_log, sigma_t2_log, vt_log)
            mx[i], msz[i], mcorr[i], mrand[i], mrot[i], mall[i] = compar_bias(i, plog, tlog, ne_log, m_tot, alpha,sigma_r2_log,sigma_t2_log, vt_log)

        #rlogbin = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])

        # print("mtot r500", f"{m_tot[25]:.3e}")
        # print("mhe r500", f"{m_tot[25] * bsz[25]:.3e}")
        # print("mhe r500 corr", f"{m_tot[25] * bcorr[25]:.3e}")

        # print("presure derivative",dp)
        # sys.exit()

        def derivatives_plot():
            plt.plot(rlogbin, dne, label="dln(n_e)/dln(r)")
            plt.plot(rlogbin, dt, label="dln(T)/dln(r)")
            plt.plot(rlogbin, dp, label="dln(P)/dln(r)")
            plt.plot(rlogbin, dt + dne, label="dln(T)/dln(r)+dln(ne)/dln(r)", ls='dashed')
            plt.axvline(x=1087, color='grey', label='$R_{500}$')
            plt.axvline(x=2024, color='grey', ls='dashed', label='$R_{Vir}$')
            plt.axvline(x=850, color='black', ls='dashed', label='$R_{bump}$')
            plt.legend()
            plt.show()
            sys.exit()

        # print("smsz", smsz)
        # print("smx", smx)

        # sys.exit()
        return mx, msz, mcorr, mrand, mrot, mall

    def compute_mass_proj(plog, ne_log, m_tot, unit, sigma_r2_log, sigma_t2_log, vt_log, bin):
        def mhex(i, tlog, ne_log, unit):
            r_bin = i
            b = 0.05
            dt = np.gradient(tlog, b)
            dne = np.gradient(ne_log, b)
            dt = dt[r_bin]
            dne = dne[r_bin]
            if unit == 0:
                m = (((-10 ** ((i + 35.5) * 0.05) * kb * 10 ** tlog[r_bin]) / (g * mu * mp)) * (dne + dt)) * (
                        (1E3 * pc) / m_sun)

                sm = 0
                dne = 0
                dt = 0

            if unit == 1:
                m = (((-10 ** ((i + 35) * 0.05) * 10 ** tlog[r_bin]) / (g * mu * mp)) * (dne + dt)) * (
                        (1E3 * pc * kev) / m_sun)

                invt = np.array([1 / (10 ** tlog[i]) for i in range(len(tlog))])
                # print("invt", invt)
                dinvt = np.gradient(invt, b)
                dinvt = dinvt[r_bin]

                invne = np.array([1 / (10 ** ne_log[i]) for i in range(len(ne_log))])
                # print("invp", invne)
                dinvne = np.gradient(invne, b)
                dinvne = dinvne[r_bin]

                dmdne = -((10 ** ((i + 35) * 0.05) * dinvne * 10 ** tlog[i]) / (g * mu * mp)) * (
                        (1E3 * pc * kev) / m_sun)
                dmdt = m / (10 ** tlog[r_bin]) - ((10 ** ((i + 35) * 0.05) * dinvt * 10 ** tlog[i]) / (g * mu * mp)) * (
                        (1E3 * pc * kev) / m_sun)
                sm = np.sqrt(
                    dmdne ** 2 * (10 ** sne[i] * 10 ** ne_log[i]) ** 2 + dmdt ** 2 * (10 ** st[i] * 10 ** tlog[i]) ** 2)
                # print("sm", sm)
                # print("m", m)

            return m, sm, dne, dt

        def mhesz(i, plog, ne_log, unit):
            b = 0.1
            r_bin = i
            dp = np.gradient(plog, b)
            dp = dp[r_bin]
            if unit == 0:
                m = ((-10 ** ((i + 18) * 0.1) * 10 ** plog[r_bin] * dp) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                        (1E3 * pc * kev) / m_sun)

                sm = 0
                dp = 0

            if unit == 1:
                m = ((-10 ** ((i + 35) * 0.05) * 10 ** plog[r_bin] * dp) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                        (1E3 * pc * kev) / m_sun)

                invp = np.array([1 / (10 ** plog[i]) for i in range(len(plog))])
                # print("invp",invp)
                dinvp = np.gradient(invp, b)
                dinvp = dinvp[r_bin]
                # print("dinvp",dinvp)
                dmdne = -m / (10 ** ne_log[r_bin])
                dmdp = m / (10 ** plog[r_bin]) - (
                        (10 ** ((i + 35) * 0.05) * dinvp * 10 ** plog[i]) / (g * mu * mp * 10 ** ne_log[r_bin])) * (
                               (1E3 * pc * kev) / m_sun)
                # dmdp=0
                sm = np.sqrt(
                    dmdne ** 2 * (10 ** sne[i] * 10 ** ne_log[i]) ** 2 + dmdp ** 2 * (10 ** sp[i] * 10 ** plog[i]) ** 2)
                # print("sne",sne[i])
                # print("sp",sp[i])
                # print("dmdne",dmdne)
                # print("dmdp",dmdp)
                # print("sm",sm)
                # print("m ",m)
                # sys.exit()
            return m, sm, dp

        def mhecorr(i, plog, ne_log, mhesz, alpha):
            b = 0.1
            r_bin = i
            dalpha = np.gradient(alpha, b)
            dalpha = dalpha[r_bin]
            # print("dalpha",dalpha)
            mcorr = (1 / (1 - alpha[r_bin])) * (mhesz - (alpha[r_bin] / (1 - alpha[r_bin])) * (
                    (10 ** ((i + 18) * 0.1) * 10 ** plog[r_bin] * dalpha) / (
                    g * mu * mp * 10 ** ne_log[r_bin])) * (
                                                        (1E3 * pc * kev) / m_sun))
            # print("mcorr",mcorr)
            return mcorr

        def m_rand(i, ne_log, sigma_r2_log):
            b = 0.1
            r_bin = i
            dne = np.gradient(ne_log, b)
            dne = dne[r_bin]
            #dsigma_r2 = np.gradient(sigma_r2_log, b)
            #dsigma_r2 = dsigma_r2[r_bin]

            # print("dne",dne,"dsigma_r2",dsigma_r2)

            m = (-10 ** ((i + 18) * 0.1) * (10 ** sigma_r2_log * dne) / g) * ((1E3 * pc * 1E6) / m_sun)

            #m = (-10 ** ((i + 35.5) * 0.05) * (
            #        10 ** sigma_r2_log[r_bin] * (dne + dsigma_r2 + 2) - 10 ** sigma_t2_log[r_bin]) / g) * (
            #            (1E3 * pc * 1E6) / m_sun)

            return m

        def m_rand_2(i, ne_log, sigma_r2_log,sigma_t2_log):
            b = 0.1
            r_bin = i
            dne = np.gradient(ne_log, b)
            dne = dne[r_bin]
            #dsigma_r2 = np.gradient(sigma_r2_log, b)
            #dsigma_r2 = dsigma_r2[r_bin]

            # print("dne",dne,"dsigma_r2",dsigma_r2)

            m = (-10 ** ((i + 18) * 0.1) * (10 ** sigma_r2_log * (dne+2)-10 ** sigma_t2_log) / g) * ((1E3 * pc * 1E6) / m_sun)

            #m = (-10 ** ((i + 35.5) * 0.05) * (
            #        10 ** sigma_r2_log[r_bin] * (dne + dsigma_r2 + 2) - 10 ** sigma_t2_log[r_bin]) / g) * (
            #            (1E3 * pc * 1E6) / m_sun)

            return m

        def m_rot(i, vt_log):
            b = 0.1
            r_bin = i

            m = (10 ** ((i + 18) * 0.1) * (10 ** vt_log) ** 2 / g) * (
                    (1E3 * pc * 1E6) / m_sun)

            return m

        def compar_bias(i, plog, ne_log, m_tot, alpha, sigma_r2_log, sigma_t2_log, vt_log):
            #mxlog, smx, dne, dt = mhex(i, tlog, ne_log, unit)
            # print("mhexlog", f"{mxlog:.3e}", "M_sun")
            mszlog, smsz, dp = mhesz(i, plog, ne_log, unit)
            mcorrlog = mhecorr(i, plog, ne_log, mszlog, alpha)
            mrandlog = m_rand(i, ne_log, sigma_r2_log)
            mrandlog2 = m_rand_2(i, ne_log, sigma_r2_log, sigma_t2_log)
            mrotlog = m_rot(i, vt_log)
            malllog = mszlog + mrandlog + mrotlog
            malllog2 = mszlog + mrandlog2 + mrotlog


            #print("i",i,"msz", f"{mszlog:.3e}"," mcorr", f"{mcorrlog:.3e}", " mrand", f"{mrandlog:.3e}", " mrand2", f"{mrandlog2:.3e}" " mrot", f"{mrotlog:.3e}", " mall", f"{malllog:.3e}"," mtot[i]",f"{m_tot[i]:.3e}", "M_sun")
            #print("ratio 1 ",f"{mrandlog/malllog:.3e}")
            #print("ratio 2 ", f"{mrandlog2 / malllog2:.3e}")

            #sys.exit()

            # print("mrand", f"{mrandlog:.3e}", "M_sun")
            # return mxlog / m_tot[i], mszlog / m_tot[i], dne, dt, dp, smx / m_tot[i], smsz / m_tot[i], mcorr / m_tot[i], mall / m_tot[i]
            return mszlog, mcorrlog, mrandlog, mrotlog, malllog
            # return mxlog,mszlog,dne,dt,dp,smx,smsz

        #bx = np.zeros(40)
        #bsz = np.zeros(40)
        #dne = np.zeros(40)
        #dt = np.zeros(40)
        #dp = np.zeros(40)
        #smx = np.zeros(40)
        #smsz = np.zeros(40)
        #bcorr = np.zeros(40)
        #ball = np.zeros(40)

        #mx = np.zeros(40)
        #msz = np.zeros(40)
        #mrand = np.zeros(40)
        #mrot = np.zeros(40)
        #mall = np.zeros(40)
        #mcorr = np.zeros(40)

        alpha = np.load('alpha.npy')

        i=bin

        #for i in range(40):
            # bx[i], bsz[i], dne[i], dt[i], dp[i], smx[i], smsz[i], bcorr[i], ball[i] = compar_bias(i, plog, tlog, ne_log, m_tot,alpha, sigma_r2_log, sigma_t2_log, vt_log)
        msz, mcorr, mrand, mrot, mall = compar_bias(i, plog, ne_log, m_tot, alpha, sigma_r2_log, sigma_t2_log, vt_log)

        #rlogbin = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])

        # print("mtot r500", f"{m_tot[25]:.3e}")
        # print("mhe r500", f"{m_tot[25] * bsz[25]:.3e}")
        # print("mhe r500 corr", f"{m_tot[25] * bcorr[25]:.3e}")

        # print("presure derivative",dp)
        # sys.exit()

        def derivatives_plot():
            plt.plot(rlogbin, dne, label="dln(n_e)/dln(r)")
            plt.plot(rlogbin, dt, label="dln(T)/dln(r)")
            plt.plot(rlogbin, dp, label="dln(P)/dln(r)")
            plt.plot(rlogbin, dt + dne, label="dln(T)/dln(r)+dln(ne)/dln(r)", ls='dashed')
            plt.axvline(x=1087, color='grey', label='$R_{500}$')
            plt.axvline(x=2024, color='grey', ls='dashed', label='$R_{Vir}$')
            plt.axvline(x=850, color='black', ls='dashed', label='$R_{bump}$')
            plt.legend()
            plt.show()
            sys.exit()

        # print("smsz", smsz)
        # print("smx", smx)

        # sys.exit()
        return msz, mcorr, mrand, mrot, mall

    if (dim == 3) :

        save_profiles=1

        if save_profiles==1:
            p_rad_log, t_rad_log, ne_rad_log, n_log, m_ba_rad_log, err_nelog, err_plog, err_tlog, err_klog, p_turb, vr_rad_log, vt_rad_log, sigma_r_2_rad_log, sigma_t_2_rad_log, mass_ba_before_1st_bin = hydro("./virgo_xyz_files/virgo_xyz_hydro_l15_high.dat",2, 1, 0, 20)

            #np.save("m_rad_log_l21_20b.npy",m_ba_rad_log)
            #print("mass profiles saved")
            #sys.exit()

            np.save("p_rad_log_l15_20b.npy", p_rad_log)
            np.save("t_rad_log_l15_20b.npy", t_rad_log)
            np.save("ne_rad_log_l15_20b.npy", ne_rad_log)
            np.save("std_p_rad_log_l15_20b.npy", err_plog)
            np.save("std_t_rad_log_l15_20b.npy", err_tlog)
            np.save("std_ne_rad_log_l15_20b.npy", err_nelog)
            np.save("sigma_r_2_rad_log_l15_20b.npy",sigma_r_2_rad_log)
            np.save("sigma_t_2_rad_log_l15_20b.npy",sigma_t_2_rad_log)
            np.save("vr_rad_l15_20b.npy",vr_rad_log)
            np.save("vt_rad_log_l15_20b.npy",vt_rad_log)
            np.save("m_rad_log_l15_20b.npy",m_ba_rad_log)
            #np.save("err_plog.npy",err_plog)
            #np.save("err_ne_log.npy",err_nelog)


            m_dm_rad_log, n_dm_rad_log, mass_dm_before_1st_bin = dm('./virgo_xyz_files/virgo_xyz_dm_high_res.dat',20)

            np.save('m_dm_rad_log_high_20b.npy',m_dm_rad_log)
            print("mass_ba_before_1st_bin","{:.2e}".format(mass_ba_before_1st_bin))
            #print("T_mean", "{:.2e}".format(t_mean))
            print("m bar", m_ba_rad_log)
            print("mass_dm_before_1st_bin","{:.2e}".format(mass_dm_before_1st_bin))
            print("m_dm", m_dm_rad_log)
            # sys.exit()

            # m_cumul_dm = np.load("m_cumul_dm.npy")
            # m_cumul_ba = np.load("m_cumul_ba.npy")
            # m_cumul_sum = m_cumul_dm + m_cumul_ba

            m_cumul_dm = np.array([mass_dm_before_1st_bin+np.sum(m_dm_rad_log[0:i+1]) for i in range(0, len(m_dm_rad_log))])
            m_cumul_ba = np.array([mass_ba_before_1st_bin+np.sum(m_ba_rad_log[0:i+1]) for i in range(0, len(m_ba_rad_log))])

            m_cumul_sum = m_cumul_ba + m_cumul_dm

            print("m_cumul_dm", m_cumul_dm)
            print("m_cumul_ba", m_cumul_ba)
            print("m_cumul_sum", m_cumul_sum)

            np.save("m_cumul_sum",m_cumul_sum)

            print("data saved")
            #sys.exit()

        p_rad_log = np.load("p_rad_log_l15_20b.npy")
        t_rad_log = np.load("t_rad_log_l15_20b.npy")
        ne_rad_log = np.load("ne_rad_log_l15_20b.npy")
        sigma_r_2_rad_log = np.load("sigma_r_2_rad_log_l15_20b.npy")
        #print("sigma_r_2_rad_log",np.sqrt(10**sigma_r_2_rad_log[31]))
        sigma_t_2_rad_log = np.load("sigma_t_2_rad_log_l15_20b.npy")
        #print("sigma_t_2_rad_log",np.sqrt(10**sigma_t_2_rad_log[31]))
        #sys.exit()
        vt_rad_log = np.load("vt_rad_log_l15_20b.npy")
        #err_plog = np.load("err_plog_l15_20b.npy")
        #err_nelog = np.load("err_ne_log_l15_20b.npy")
        m_ba_rad_log = np.load("m_rad_log_l15_20b.npy")
        m_dm_rad_log = np.load("m_dm_rad_log_high_20b.npy")

        m_ba_rad_log_21 = np.load("m_rad_log_l21_20b.npy")

        m_cumul_sum = np.load("m_cumul_sum.npy")

        #nbin=20
        #rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(nbin)])
        #plt.plot(rlogbin_cen,m_ba_rad_log,marker=".",ls='solid')
        #plt.plot(rlogbin_cen,m_ba_rad_log_21,ls='dotted',marker=".")
        #plt.show()
        #sys.exit()


        print('profiles loaded')

        #sys.exit()

        #print("m_cumul_sum",m_cumul_sum)
        #sys.exit()

        #print("profiles loaded")
        #print("ne_rad_log", ne_rad_log)
        #print("p_rad_log", p_rad_log)
        #sys.exit()

        #rlogbin = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])
        #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

        nbin=20

        rlogbin = np.array([10 ** ((17.5 + i) * 0.1) for i in range(nbin)])
        rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(nbin)])

        print("rlogbin",rlogbin)

        #sys.exit()

        #print("rlogbin_cen",rlogbin_cen[31])
        #sys.exit()

        #plt.scatter(rlogbin_cen, p_rad_log, label='p_rad_log')
        #plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted', label='p_rad_log', alpha=0.7)
        #plt.scatter(rlogbin_cen, ne_rad_log, label='ne_rad_log')
        #plt.errorbar(rlogbin_cen, ne_rad_log, yerr=err_nelog, ls='dotted', label='ne_rad_log', alpha=0.7)
        #plt.xscale('log')
        #plt.xlim(50, 5500)
        #plt.show()
        #plt.legend()
        #sys.exit()

        mx = np.zeros(nbin)
        msz = np.zeros(nbin)
        mrand = np.zeros(nbin)
        mrot = np.zeros(nbin)
        mall = np.zeros(nbin)
        mcorr = np.zeros(nbin)

        mx, msz, mcorr, mrand, mrot, mall = compute_mass(p_rad_log, t_rad_log, ne_rad_log, m_cumul_sum,0,sigma_r_2_rad_log, sigma_t_2_rad_log, vt_rad_log,nbin)

        #print("bsz", bsz)
        #sys.exit()

        def masses_plot():

            plt.plot(rlogbin_cen, msz ,label='mhe_sz')
            plt.plot(rlogbin_cen, mcorr, label='mhe_corr')
            plt.plot(rlogbin_cen, mall, label="mall=mhe_sz+mrand+mrot")
            plt.plot(rlogbin_cen, mrand, label='mrand',ls='dotted')
            plt.plot(rlogbin_cen, mrot, label="mrot",ls='dotted')
            plt.plot(rlogbin_cen, m_cumul_sum, label="m_tot=m_dm+m_bar from sim",color='black')
            #plt.plot(rlogbin_cen, ball, label='ball')
            plt.xscale('log')
            plt.xlim(200,4000)
            plt.ylim(-3e14,1.1e15)
            plt.axvline(x=1087, color='grey',ls='dotted')#, label='$R_{500}$')
            plt.axvline(x=2024, color='grey',ls="dotted")#, ls='dashed', label='$R_{Vir}$')
            plt.text(1087, 0.9e15, "$R_{500}$", rotation=90, size=16)
            plt.text(2024, 0.9e15, "$R_{Vir}$", rotation=90, size=16)
            plt.xlabel("R [kpc]")
            plt.ylabel("M $\mathrm{[M_{\odot}]}$")

            plt.legend()
            plt.show()

            sys.exit()

        def bias_plot():

            plt.plot(rlogbin_cen, msz/m_cumul_sum, label='$M_{HE}$',color='blue',ls='dashed',marker='.')
            #plt.plot(rlogbin_cen, mcorr/m_cumul_sum, label='bcorr')
            #plt.plot(rlogbin_cen, mrand, label='mrand')
            #plt.plot(rlogbin_cen, mrot, label="mrot")
            plt.plot(rlogbin_cen, mall/m_cumul_sum, label="$M_{corr}$",color='black',ls='dashed',marker=".")
            #plt.plot(rlogbin_cen, m_cumul_sum, label="msum from sim", color='black')
            # plt.plot(rlogbin_cen, ball, label='ball')
            plt.xscale('log')
            plt.xlim(200, 4000)
            plt.ylim(0.75,1.7)
            #plt.ylim(0.7, 2)
            plt.axhline(y=1, color='darkgrey', ls='solid')
            plt.axvline(x=1087, color='grey',ls='dotted')  # , label='$R_{500}$')
            plt.axvline(x=2024, color='grey',ls='dotted')  # , ls='dashed', label='$R_{Vir}$')
            plt.text(1087, 0.8, "$R_{500}$", rotation=90, size=16)
            plt.text(2024, 0.8, "$R_{Vir}$", rotation=90, size=16)
            plt.ylabel(r"$(1-b)=\frac{M}{M_{tot}}$")
            plt.xlabel("R [kpc]")
            plt.legend()
            plt.show()

            sys.exit()

        def ratio_over_mcorr_and_over_mtot_plot():

            #print('mrot/mall',mrot  [11:32]/mall  [11:32])
            #print('min mrot',np.min(mrot  [11:32]/mall  [11:32]),'max mrot',np.max(mrot  [11:32]/mall  [11:32]))
            #print("rlogbin_cen[25]",rlogbin_cen[25],"mrot[25]/mall[25]",mrot[25]/mall[25])
            #print("rlogbin_cen[31]",rlogbin_cen[31],"mrot[31]/mall[31]",mrot[31]/mall[31])

            #print('mrand/mall',mrand  [11:32]/mall  [11:32])
            #print('min mrand',np.min(mrand  [11:32]/mall  [11:32]),'max mrand',np.max(mrand  [11:32]/mall  [11:32]))
            #print("rlogbin_cen[25]",rlogbin_cen[25],"mrand[25]/mall[25]",mrand[25]/mall[25])
            #print("rlogbin_cen[31]",rlogbin_cen[31],"mrand[31]/mall[31]",mrand[31]/mall[31])

            #sys.exit()

            #print('mrot/mall', mrot[11:32] / mall[11:32])
            #print('min mrot', np.min(mrot[11:32] / mall[11:32]), 'max mrot', np.max(mrot[11:32] / mall[11:32]))
            # print("rlogbin_cen[25]",rlogbin_cen[25],"mrot[25]/mall[25]",mrot[25]/mall[25])
            # print("rlogbin_cen[31]",rlogbin_cen[31],"mrot[31]/mall[31]",mrot[31]/mall[31])

            #print('mrand/mall', mrand[11:32] / mall[11:32])
            #print('min mrand', np.min(mrand[11:32] / mall[11:32]), 'max mrand', np.max(mrand[11:32] / mall[11:32]))
            # print("rlogbin_cen[25]",rlogbin_cen[25],"mrand[25]/mall[25]",mrand[25]/mall[25])
            # print("rlogbin_cen[31]",rlogbin_cen[31],"mrand[31]/mall[31]",mrand[31]/mall[31])

            m_cumul_dm = np.load("m_cumul_dm_21.npy")
            m_cumul_ba = np.load("m_cumul_ba_21.npy")
            m_cumul_sum = m_cumul_dm + m_cumul_ba

            print('rlogbin_cen',rlogbin_cen)#,rlogbin_cen[11],rlogbin_cen[31])

            #np.save("ratio_mrand_prof.npy",mrand/mall)
            #np.save("ratio_mrot_prof.npy",mrot/mall)
            print("profs saved")
            #sys.exit()

            print("masses at R500:M_rot","{:.2e}".format(mrot[12]),"M_disp","{:.2e}".format(mrand[12]),"M_HE","{:.2e}".format(msz[12]), "M_all", "{:.2e}".format(mall[12]), "M_tot", "{:.2e}".format(m_cumul_sum[12]))
            print("masses at Rvir:M_rot", "{:.2e}".format(mrot[15]), "M_disp", "{:.2e}".format(mrand[15]), "M_HE", "{:.2e}".format(msz[15]), "M_all", "{:.2e}".format(mall[15]), "M_tot", "{:.2e}".format(m_cumul_sum[15]))
            sys.exit()

            fig,ax = plt.subplots(3,1,sharex=True)
            fig.subplots_adjust(hspace=0.05)

            ax[0].spines.bottom.set_visible(False)
            ax[1].spines.top.set_visible(False)
            ax[0].xaxis.tick_top()
            ax[0].tick_params(labeltop=False)  # don't put tick labels at the top
            ax[1].xaxis.tick_bottom()

            plt.sca(ax[0])

            #np.save("./vel_Virgo_core_project/mhe_mcorr_ratio_3D.npy",msz/mall)
            #np.save("./vel_Virgo_core_project/mdisp_mcorr_ratio_3D.npy", mrand / mall)
            #np.save("./vel_Virgo_core_project/mrot_mcorr_ratio_3D.npy", mrot / mall)

            # plt.plot(rlogbin_cen, mall/mall, label='mall')
            plt.plot(rlogbin_cen, msz / mall, label='$M_{HE}$', color='blue', marker='.', ls='dashed')
            plt.plot(rlogbin_cen, mrand / mall, label='$M_{disp}$', color='red', marker='.', ls='dashed')
            plt.plot(rlogbin_cen, mrot / mall, label='$M_{rot}$', color="purple", marker='.', ls='dashed')
            # plt.plot(rlogbin_cen, mrand, label='mrand')
            # plt.plot(rlogbin_cen, mrot, label="mrot")
            # plt.plot(rlogbin_cen, mall/m_cumul_sum, label="ball")
            # plt.plot(rlogbin_cen, m_cumul_sum, label="msum from sim", color='black')
            # plt.plot(rlogbin_cen, ball, label='ball')
            plt.xscale('log')
            plt.xlim(200, 3000)
            plt.ylim(0.86, 1.02)
            plt.axhline(y=0, color='grey', ls='dotted')
            plt.axhline(y=1, color='black', ls='solid', label="$M_{corr}=M_{HE}+M_{disp}+M_{rot}$")
            plt.axvline(x=1087, color='grey', ls='dotted')  # , label='$R_{500}$')
            plt.axvline(x=2024, color='grey', ls='dotted')  # , ls='dashed', label='$R_{Vir}$')
            #plt.text(1087, 1.1, "$R_{500}$", rotation=90, size=16)
            #plt.text(2024, 1.1, "$R_{Vir}$", rotation=90, size=16)
            fig.text(0.04,0.63,r"$M/M_{corr}$",va='center',rotation='vertical')

            plt.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False,labeltop=False)
            plt.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=14, labelbottom=False, labelleft=True,labeltop=False)

            plt.sca(ax[1])

            #plt.plot(rlogbin_cen, mall/mall, label='mall')
            plt.plot(rlogbin_cen, msz/mall, label='$M_{HE}$',color='blue',marker='.',ls='dashed')
            plt.plot(rlogbin_cen, mrand/mall, label='$M_{disp}$',color='red',marker='.',ls='dashed')
            plt.plot(rlogbin_cen, mrot/mall, label='$M_{rot}$',color="purple",marker='.',ls='dashed')
            #plt.plot(rlogbin_cen, mrand, label='mrand')
            #plt.plot(rlogbin_cen, mrot, label="mrot")
            #plt.plot(rlogbin_cen, mall/m_cumul_sum, label="ball")
            #plt.plot(rlogbin_cen, m_cumul_sum, label="msum from sim", color='black')
            # plt.plot(rlogbin_cen, ball, label='ball')
            plt.xscale('log')
            plt.xlim(200, 3000)
            plt.ylim(-0.1, 0.19)
            plt.axhline(y=0, color='grey',ls='dotted')
            plt.axhline(y=1, color='black', ls='solid',label="$M_{corr}=M_{HE}+M_{disp}+M_{rot}$")
            plt.axvline(x=1087, color='grey',ls='dotted')  # , label='$R_{500}$')
            plt.axvline(x=2024, color='grey',ls='dotted')  # , ls='dashed', label='$R_{Vir}$')
            plt.text(1087, 0.1, "$R_{500}$", rotation=90, size=15,color='grey')
            plt.text(2024, 0.1, "$R_{Vir}$", rotation=90, size=15,color='grey')

            plt.tick_params(which="minor", right=True, top=False, direction="in", length=3, labelbottom=False)
            plt.tick_params(which="major", right=True, top=False, direction="in", length=5, labelsize=14, labelbottom=False, labelleft=True)

            #plt.ylabel(r"$\frac{M}{M_{corr}}$")
            #plt.xlabel("R [kpc]")

            d = .5  # proportion of vertical to horizontal extent of the slanted line
            kwargs = dict(marker=[(-1, -d), (1, d)], markersize=12,
                          linestyle="none", color='k', mec='k', mew=1, clip_on=False)
            ax[0].plot([0, 1], [0, 0], transform=ax[0].transAxes, **kwargs)
            ax[1].plot([0, 1], [1, 1], transform=ax[1].transAxes, **kwargs)
            plt.legend(fontsize=15,ncols=2)

            plt.sca(ax[2])

            #np.save("./vel_Virgo_core_project/msz_over_mtot_3D.npy",msz/m_cumul_sum)
            #np.save("./vel_Virgo_core_project/mcorr_over_mtot_3D.npy",mall/m_cumul_sum)

            plt.axhline(y=1, color='darkgrey', ls='solid', label='$M_{tot}=M_{DM}+M_{gas}$')
            plt.plot(rlogbin_cen, msz / m_cumul_sum, label='$M_{HE}$', color='blue', ls='dashed', marker='.')
            # plt.plot(rlogbin_cen, mcorr/m_cumul_sum, label='bcorr')
            # plt.plot(rlogbin_cen, mrand, label='mrand')
            # plt.plot(rlogbin_cen, mrot, label="mrot")
            plt.plot(rlogbin_cen, mall / m_cumul_sum, label="$M_{corr}$", color='black', ls='dashed', marker=".")
            # plt.plot(rlogbin_cen, m_cumul_sum, label="msum from sim", color='black')
            # plt.plot(rlogbin_cen, ball, label='ball')
            plt.xscale('log')
            plt.xlim(200, 3000)
            plt.ylim(0.75, 1.7)
            # plt.ylim(0.7, 2)
            plt.axvline(x=1087, color='grey', ls='dotted')  # , label='$R_{500}$')
            plt.axvline(x=2024, color='grey', ls='dotted')  # , ls='dashed', label='$R_{Vir}$')
            #plt.text(1087, 0.8, "$R_{500}$", rotation=90, size=16)
            #plt.text(2024, 0.8, "$R_{Vir}$", rotation=90, size=16)
            plt.ylabel(r"$M/M_{tot}$")
            plt.xlabel("R [kpc]")
            plt.legend(loc='lower left',bbox_to_anchor=(0.42,0.02),fontsize=15)

            plt.tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            plt.tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=14, labelbottom=True, labelleft=True)

            plt.show()

            sys.exit()

        #bias_plot()
        #masses_plot()
        ratio_over_mcorr_and_over_mtot_plot()





    #sys.exit()

    if (dim==2) :

        def deproj_prof_test():
            x_p = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_x.npy")
            y_p = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_y.npy")
            z_p = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_z.npy")
            cen_p = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_cen.npy")

            x_p_std = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_x_std.npy")
            y_p_std = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_y_std.npy")
            z_p_std = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_z_std.npy")
            cen_p_std = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_cen_std.npy")

            x_ne = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_x.npy")
            y_ne = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_y.npy")
            z_ne = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_z.npy")
            cen_ne = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_cen.npy")

            x_ne_std = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_x_std.npy")
            y_ne_std = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_y_std.npy")
            z_ne_std = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_z_std.npy")
            cen_ne_std = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_cen_std.npy")



            #print("len xp",len(x_p))

            rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(21)])

            rlogbin_cen_lvl21 = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])
            ne_rad_log = np.load("ne_rad_log_l15_20b.npy")
            std_ne_rad_log = np.load("std_ne_rad_log_l15_20b.npy")

            P_rad_log = np.load("p_rad_log_l15_20b.npy")
            std_P_rad_log = np.load("std_p_rad_log_l15_20b.npy")

            ne_rad_log_lvl21 = np.load("ne_rad_log.npy")
            std_ne_rad_log_lvl21 = np.load("err_ne_log.npy")

            P_rad_log_lvl21 = np.load("p_rad_log.npy")
            std_P_rad_log_lvl21 = np.load("err_plog.npy")

            plot_p=0

            if plot_p==1:

                plt.scatter(rlogbin_cen, x_p,label="x",marker='.')
                plt.errorbar(rlogbin_cen, x_p, yerr=x_p_std, ls='dashed')
                plt.scatter(rlogbin_cen, y_p, label="y", marker='.')
                plt.errorbar(rlogbin_cen, y_p, yerr=y_p_std, ls='dashed')
                plt.scatter(rlogbin_cen, z_p, label="z", marker='.')
                plt.errorbar(rlogbin_cen, z_p, yerr=z_p_std, ls='dashed')
                plt.scatter(rlogbin_cen, cen_p, label="cen", marker='.')
                plt.errorbar(rlogbin_cen, cen_p, yerr=cen_p_std, ls='dashed')
                plt.scatter(rlogbin_cen[0:20], P_rad_log, label="3D lvl 15", marker='.',color='black')
                plt.errorbar(rlogbin_cen[0:20], P_rad_log, yerr=std_P_rad_log, ls='solid',color='black')
                plt.scatter(rlogbin_cen_lvl21, P_rad_log_lvl21,label="3D lvl 21", marker='.', color='grey')
                plt.errorbar(rlogbin_cen_lvl21, P_rad_log_lvl21, yerr=std_P_rad_log_lvl21, ls='solid',color='grey')
                plt.ylabel("$log_{10}(P~[\mathrm{keV\,cm^{-3}}])$", size=16)

            else :

                plt.scatter(rlogbin_cen, x_ne,label="x",marker='.')
                plt.errorbar(rlogbin_cen, x_ne, yerr=x_ne_std, ls='dashed')
                plt.scatter(rlogbin_cen, y_ne, label="y", marker='.')
                plt.errorbar(rlogbin_cen, y_ne, yerr=y_ne_std, ls='dashed')
                plt.scatter(rlogbin_cen, z_ne, label="z", marker='.')
                plt.errorbar(rlogbin_cen, z_ne, yerr=z_ne_std, ls='dashed')
                plt.scatter(rlogbin_cen, cen_ne, label="cen", marker='.')
                plt.errorbar(rlogbin_cen, cen_ne, yerr=cen_ne_std, ls='dashed')
                plt.scatter(rlogbin_cen[0:20], ne_rad_log, label="3D lvl 15", marker='.',color='black')
                plt.errorbar(rlogbin_cen[0:20], ne_rad_log, yerr=std_ne_rad_log, ls='solid',color='black')
                plt.scatter(rlogbin_cen_lvl21, ne_rad_log_lvl21,label="3D lvl 21", marker='.', color='grey')
                plt.errorbar(rlogbin_cen_lvl21, ne_rad_log_lvl21, yerr=std_ne_rad_log_lvl21, ls='solid',color='grey')
                plt.ylabel("$log_{10}(n_e~[\mathrm{cm^{-3}}])$", size=16)




            plt.axvline(1087, ls='dotted', color='grey')
            plt.axvline(2147, ls='dotted', color='grey')
            plt.text(1087, -6, "$R_{500}$", color='grey')
            plt.text(2147, -6, "$R_{vir}$", color='grey')
            plt.xlabel("R [kpc]")
            plt.xscale('log')
            plt.legend()
            plt.show()

            sys.exit()

        #deproj_prof_test()


        #x_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_x_h.txt")
        #y_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_y_h.txt")
        #z_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_z_h.txt")
        #cen_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_MW_h.txt")
        #fil_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_fil_h.txt")
        #filx_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_filx_h.txt")
        #fily_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/deproj_P_fily_h.txt")

        #sx_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_x_h.txt")
        #sy_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_y_h.txt")
        #sz_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_z_h.txt")
        #scen_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_MW_h.txt")
        #sfil_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_fil_h.txt")
        #filx_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_filx_h.txt")
        #sfily_p = np.loadtxt("./proj+deproj_profiles/fig_dep_p_7_high/std_deproj_P_fily_h.txt")

        #x_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_x_h.txt")
        #y_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_y_h.txt")
        #z_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_z_h.txt")
        #cen_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_cen_h.txt")
        #fil_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_fil_h.txt")
        #filx_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_filx_h.txt")
        #fily_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/deproj_ne_fily_h.txt")

        #sx_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_x_h.txt")
        #sy_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_y_h.txt")
        #sz_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_z_h.txt")
        #scen_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_cen_h.txt")
        #sfil_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_fil_h.txt")
        #sfilx_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_filx_h.txt")
        #sfily_ne = np.loadtxt("./proj+deproj_profiles/fig_dep_ne_7_high/std_deproj_ne_fily_h.txt")

        x_p = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_x.npy")
        y_p = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_y.npy")
        z_p = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_z.npy")
        cen_p = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_cen.npy")

        x_p_std = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_x_std.npy")
        y_p_std = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_y_std.npy")
        z_p_std = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_z_std.npy")
        cen_p_std = np.load("./vel_Virgo_core_project/deproj_prof/P_deproj_prof_cen_std.npy")

        x_ne = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_x.npy")
        y_ne = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_y.npy")
        z_ne = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_z.npy")
        cen_ne = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_cen.npy")

        x_ne_std = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_x_std.npy")
        y_ne_std = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_y_std.npy")
        z_ne_std = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_z_std.npy")
        cen_ne_std = np.load("./vel_Virgo_core_project/deproj_prof/ne_deproj_prof_cen_std.npy")

        rlogbin = np.array([10 ** ((17.5 + i) * 0.1) for i in range(21)])
        rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(21)])

        def fitting_profs(p, ne, r):
            r500 = 1087
            p = 10 ** p
            p500 = p[12]
            pratio = np.log10(p / p500)

            popt, pcov = curve_fit(upplog, r / r500, pratio, p0=[6.41, 1.81, 1.33, 4.13, 0.31],
                                   bounds=([0, 0, 0, 0, -10], [600, 20, 10, 15, 10]), method='trf')

            popt_ne, pcov_ne = curve_fit(log_beta_model, r, ne)

            print("popt p", popt)
            print("sigma p", np.sqrt(np.diagonal(pcov)))
            print("popt ne", popt_ne)
            print("sigma ne", np.sqrt(np.diagonal(pcov_ne)))

            pfit = np.log10(10 ** (upplog(r / r500, *popt)) * p500)
            nefit = log_beta_model(rlogbin_cen, *popt_ne)

            return pfit, nefit

        #y_p_fit, y_ne_fit = fitting_profs(y_p, y_ne, rlogbin_cen)

        #plt.plot(rlogbin_cen,y_ne,label='y_ne')
        #plt.plot(rlogbin_cen,y_ne_fit,label='y_ne_fit')
        #plt.xscale('log')
        #plt.legend()
        #plt.axvline(x=1087,ls='dashed',color='black')
        #plt.axvline(x=2187,ls='dashed',color='black')
        #plt.yscale('log')
        #plt.xlabel('R [kpc]')
        #plt.ylabel('log(n_e)')
        #plt.show()
        #sys.exit()

        m_cumul_dm = np.load("m_cumul_dm_21.npy")
        m_cumul_ba = np.load("m_cumul_ba_21.npy")
        m_cumul_sum = m_cumul_dm + m_cumul_ba
        # print("m_cumul_sum",m_cumul_sum)
        # sys.exit()

        print("profiles loaded")
        # print("ne_rad_log", ne_rad_log)
        # print("p_rad_log", p_rad_log)
        # sys.exit()

        #rlogbin = np.array([10 ** ((35 + i) * 0.05) for i in range(40)])
        #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

        #print("rlogbin",rlogbin)
        #print("rlogbin_cen",rlogbin_cen)

        #print("bin 12: rlogbin_cen",rlogbin_cen[12],"rlogbinv (bin+1)",rlogbin[13])
        #print("bin 15: rlogbin_cen",rlogbin_cen[15],"rlogbin (bin+1)",rlogbin[16])

        #sys.exit()

        # plt.scatter(rlogbin_cen, p_rad_log, label='p_rad_log')
        # plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted', label='p_rad_log', alpha=0.7)
        # plt.scatter(rlogbin_cen, ne_rad_log, label='ne_rad_log')
        # plt.errorbar(rlogbin_cen, ne_rad_log, yerr=err_nelog, ls='dotted', label='ne_rad_log', alpha=0.7)
        # plt.xscale('log')
        # plt.xlim(50, 5500)
        # plt.show()
        # plt.legend()
        # sys.exit()

        def vel_props_from_maps():

            def load_map(file,proj):
                h = FortranFile(file, 'r')
                nx, ny, nz = h.read_ints()
                cen_x, cen_y, cen_z = h.read_reals()
                #print("nx,ny,nz", nx, ny, nz)
                # print("cen_x,cen_y,cen_z",cen_x,cen_y,cen_z)
                # sys.exit()
                # ncell = 0
                # print(ncell.dtype)
                # sys.exit()
                # ncell = np
                # sys.exit()
                if proj == "x":
                    ncell = nz * ny
                elif proj == "y":
                    ncell = nx * nz
                elif proj == "z":
                    # ncell = np.uint64(nx * ny)
                    ncell = nx * ny
                #print("ncell", ncell)

                map = np.zeros(ncell)

                map = ftp.f90_to_py.read_map_file(ncell, file, 0)

                if proj == "x":
                    map = np.reshape(map, (nz, ny))
                elif proj == "y":
                    map = np.reshape(map, (nx, nz))
                elif proj == "z":
                    map = np.reshape(map, (ny, nx))

                return map

            map_vdx_ew = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_x_map_vdx_ew_Tsup7_5Mpc2.bin','x')

            map_vx_ew = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_x_map_vx_ew_Tsup7_5Mpc2.bin','x')

            map_vdy_ew = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_y_map_vdy_ew_Tsup7_5Mpc2.bin','y')

            map_vy_ew = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_y_map_vy_ew_Tsup7_5Mpc2.bin','y')

            map_vdz_ew = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_z_map_vdz_ew_Tsup7_5Mpc2.bin','z')

            map_vz_ew = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_z_map_vz_ew_Tsup7_5Mpc2.bin','z')

            map_vdx_mw = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_x_map_vdx_mw_Tsup7_5Mpc2.bin','x')

            map_vx_mw = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_x_map_vx_mw_Tsup7_5Mpc2.bin','x')

            map_vdy_mw = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_y_map_vdy_mw_Tsup7_5Mpc2.bin','y')

            map_vy_mw = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_y_map_vy_mw_Tsup7_5Mpc2.bin','y')

            map_vdz_mw = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_z_map_vdz_mw_Tsup7_5Mpc2.bin','z')

            map_vz_mw = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_z_map_vz_mw_Tsup7_5Mpc2.bin','z')

            map_vcen_mw = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_cen_map_vz_mw_Tsup7_5Mpc2.bin','z')

            map_vcen_ew = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_cen_map_vz_ew_Tsup7_5Mpc2.bin','z')

            map_vdcen_mw = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_cen_map_vdz_mw_Tsup7_5Mpc2.bin','z')

            map_vdcen_ew = load_map('./maps/high_res/velocity/16f16_analysis/map_high_16f16_cen_map_vdz_ew_Tsup7_5Mpc2.bin','z')

            #print("mean vel dis y",np.mean(map_vdy))

            d = np.load("map_distances_lvl16_proj_vel.npy")


            #print("min d",np.min(d),"max d",np.max(d))

            rvir = 2147
            r500 = 1087

            mean_vel_disp_R500_x_ew = np.mean(map_vdx_ew[d<r500])
            mean_vel_disp_Rvir_x_ew = np.mean(map_vdx_ew[d<rvir])

            print('mean vel disp R500 x ew',mean_vel_disp_R500_x_ew)
            print('mean vel disp Rvir x ew',mean_vel_disp_Rvir_x_ew)

            mean_vel_disp_R500_y_ew = np.mean(map_vdy_ew[d<r500])
            mean_vel_disp_Rvir_y_ew = np.mean(map_vdy_ew[d<rvir])

            print('mean vel disp R500 y ew',mean_vel_disp_R500_y_ew)
            print('mean vel disp Rvir y ew',mean_vel_disp_Rvir_y_ew)

            mean_vel_disp_R500_z_ew = np.mean(map_vdz_ew[d<r500])
            mean_vel_disp_Rvir_z_ew = np.mean(map_vdz_ew[d<rvir])

            print('mean vel disp R500 z ew',mean_vel_disp_R500_z_ew)
            print('mean vel disp Rvir z ew',mean_vel_disp_Rvir_z_ew)

            mean_vel_disp_R500_cen_ew = np.mean(map_vcen_ew[d<r500])
            mean_vel_disp_Rvir_cen_ew = np.mean(map_vcen_ew[d<rvir])

            print('mean vel disp R500 cen ew',mean_vel_disp_R500_cen_ew)
            print('mean vel disp Rvir cen ew',mean_vel_disp_Rvir_cen_ew)

            mean_vel_disp_R500_x_mw = np.mean(map_vdx_mw[d<r500])
            mean_vel_disp_Rvir_x_mw = np.mean(map_vdx_mw[d<rvir])

            print('mean vel disp R500 x mw',mean_vel_disp_R500_x_mw)
            print('mean vel disp Rvir x mw',mean_vel_disp_Rvir_x_mw)

            mean_vel_disp_R500_y_mw = np.mean(map_vdy_mw[d<r500])
            mean_vel_disp_Rvir_y_mw = np.mean(map_vdy_mw[d<rvir])

            print('mean vel disp R500 y mw',mean_vel_disp_R500_y_mw)
            print('mean vel disp Rvir y mw',mean_vel_disp_Rvir_y_mw)

            mean_vel_disp_R500_z_mw = np.mean(map_vdz_mw[d<r500])
            mean_vel_disp_Rvir_z_mw = np.mean(map_vdz_mw[d<rvir])

            print('mean vel disp R500 z mw',mean_vel_disp_R500_z_mw)
            print('mean vel disp Rvir z mw',mean_vel_disp_Rvir_z_mw)

            mean_vel_disp_R500_cen_mw = np.mean(map_vcen_mw[d<r500])
            mean_vel_disp_Rvir_cen_mw = np.mean(map_vcen_mw[d<rvir])

            print('mean vel disp R500 cen mw',mean_vel_disp_R500_cen_mw)
            print('mean vel disp Rvir cen mw',mean_vel_disp_Rvir_cen_mw)

            mean_vel_disps=np.array([mean_vel_disp_R500_x_ew,mean_vel_disp_Rvir_x_ew,mean_vel_disp_R500_y_ew,mean_vel_disp_Rvir_y_ew,mean_vel_disp_R500_z_ew,mean_vel_disp_Rvir_z_ew,mean_vel_disp_R500_cen_ew, mean_vel_disp_Rvir_cen_ew, mean_vel_disp_R500_x_mw,mean_vel_disp_Rvir_x_mw,mean_vel_disp_R500_y_mw,mean_vel_disp_Rvir_y_mw,mean_vel_disp_R500_z_mw,mean_vel_disp_Rvir_z_mw, mean_vel_disp_R500_cen_mw, mean_vel_disp_Rvir_cen_mw])

            #print("mean vel disp r500",mean_vel_disp_R500)

            def vlos_in_quadrants(map,d):

                rvir = 2147
                r500 = 1087
                #print("map shape",map.shape)
                x = np.linspace(-map.shape[0] / 2 + 0.5, map.shape[0] / 2 - 0.5, map.shape[0])
                y = np.linspace(-map.shape[1] / 2 + 0.5, map.shape[1] / 2 - 0.5, map.shape[1])
                X,Y = np.meshgrid(x,y)
                #print(x)
                #print(y)
                #print(X)
                theta = np.arctan2(Y,X)
                #print(np.arctan(0/-1))
                #print(X[X>0])
                #print(np.shape(theta))
                #sys.exit()
                #print(np.min(theta),np.max(theta))
                #plt.hist(theta, bins=100)
                #plt.imshow(map)

                cond_1 = np.logical_and(theta > 0, theta < np.pi / 4)
                cond_2 = np.logical_and(theta > np.pi / 4, theta < np.pi / 2)
                cond_3 = np.logical_and(theta > np.pi / 2, theta < 3 * np.pi / 4)
                cond_4 = np.logical_and(theta > 3 * np.pi / 4, theta < np.pi)
                cond_5 = np.logical_and(theta > -np.pi, theta < -3 * np.pi / 4)
                cond_6 = np.logical_and(theta > -3 * np.pi / 4, theta < -np.pi / 2)
                cond_7 = np.logical_and(theta > -np.pi / 2, theta < -np.pi / 4)
                cond_8 = np.logical_and(theta > -np.pi / 4, theta < 0)

                mean_v_rvir_quadrants = np.zeros(8)
                mean_v_r500_quadrants = np.zeros(8)

                conds= [cond_1, cond_2, cond_3, cond_4, cond_5, cond_6, cond_7, cond_8]

                for i in range(8):

                    cond_rvir = np.logical_and(d<rvir,conds[i])

                    mean_v_rvir_quadrants[i] = np.mean(map[cond_rvir])

                    cond_r500 = np.logical_and(d<r500,conds[i])

                    mean_v_r500_quadrants[i] = np.mean(map[cond_r500])





                mean_v_rvir_abs_diff = np.zeros(4)
                mean_v_r500_abs_diff = np.zeros(4)
                n=0
                for i in range(0,4):
                    mean_v_rvir_abs_diff[i] = np.abs(mean_v_rvir_quadrants[i]-mean_v_rvir_quadrants[i+4])
                    mean_v_r500_abs_diff[n] = np.abs(mean_v_r500_quadrants[i]-mean_v_r500_quadrants[i+4])
                #for i in range(0,8):
                #    for j in range(0,7-i):
                #        mean_v_rvir_abs_diff[n] = np.abs(mean_v_rvir_quadrants[i]-mean_v_rvir_quadrants[i+j+1])
                #        mean_v_r500_abs_diff[n] = np.abs(mean_v_r500_quadrants[i]-mean_v_r500_quadrants[i+j+1])
                #       n+=1

                #print("mean_v_rvir_all", mean_v_rvir_quadrants)
                print("max mean_v_rvir_abs_diff",np.max(mean_v_rvir_abs_diff))
                #print("mean_v_r500_all", mean_v_r500_quadrants)
                print("max mean_v_r500_abs_diff",np.max(mean_v_r500_abs_diff))

                max_delta_vlos_rvir = np.max(mean_v_rvir_abs_diff)
                max_delta_vlos_r500 = np.max(mean_v_r500_abs_diff)

                sigma_vt_2_rvir = np.std(mean_v_rvir_abs_diff)
                sigma_vt_2_r500 = np.std(mean_v_r500_abs_diff)

                print("sigma_vt_2_rvir",sigma_vt_2_rvir)
                print("sigma_vt_2_r500",sigma_vt_2_r500)

                #sys.exit()

                return max_delta_vlos_rvir, max_delta_vlos_r500, sigma_vt_2_rvir, sigma_vt_2_r500

                #sys.exit()

                def plot_tests():
                    size=18

                    nx=444
                    lvl=16
                    dimx = (nx / 2) * (737.441 / 2 ** lvl)
                    dimy = dimx

                    dim = [-dimx, dimx, -dimy, dimy]

                    fig, ax = plt.subplots(facecolor="white")




                    map[cond_1_rvir]=0

                    im = ax.imshow(map, cmap="bwr", origin='lower', alpha=1, extent=dim, vmin=-600,vmax=600)  # vmin=-2000, vmax=2000

                    cb = fig.colorbar(im, ax=ax)

                    cb.ax.tick_params(labelsize=size)
                    ax.set_xlabel("x [Mpc]", size=size)
                    ax.set_ylabel("y [Mpc]", size=size)
                    plt.yticks(fontsize=size)
                    plt.xticks(fontsize=size)

                    plt.show()
                    sys.exit()

                plot_tests()

            max_deltas = np.zeros(12)

            max_delta_vlos_rvir_x_ew, max_delta_vlos_r500_x_ew, sigma_vt_2_rvir_x_ew, sigma_vt_2_r500_x_ew = vlos_in_quadrants(map_vx_ew,d)
            max_delta_vlos_rvir_y_ew, max_delta_vlos_r500_y_ew, sigma_vt_2_rvir_y_ew, sigma_vt_2_r500_y_ew  = vlos_in_quadrants(map_vy_ew, d)
            max_delta_vlos_rvir_z_ew, max_delta_vlos_r500_z_ew, sigma_vt_2_rvir_z_ew, sigma_vt_2_r500_z_ew = vlos_in_quadrants(map_vz_ew, d)
            max_delta_vlos_rvir_cen_ew, max_delta_vlos_r500_cen_ew, sigma_vt_2_rvir_cen_ew, sigma_vt_2_r500_cen_ew = vlos_in_quadrants(map_vcen_ew, d)

            max_delta_vlos_rvir_x_mw, max_delta_vlos_r500_x_mw, sigma_vt_2_rvir_x_mw, sigma_vt_2_r500_x_mw = vlos_in_quadrants(map_vx_mw,d)
            max_delta_vlos_rvir_y_mw, max_delta_vlos_r500_y_mw, sigma_vt_2_rvir_y_mw, sigma_vt_2_r500_y_mw = vlos_in_quadrants(map_vy_mw, d)
            max_delta_vlos_rvir_z_mw, max_delta_vlos_r500_z_mw, sigma_vt_2_rvir_z_mw, sigma_vt_2_r500_z_mw = vlos_in_quadrants(map_vz_mw, d)
            max_delta_vlos_rvir_cen_mw, max_delta_vlos_r500_cen_mw, sigma_vt_2_rvir_cen_mw, sigma_vt_2_r500_cen_mw = vlos_in_quadrants(map_vcen_mw, d)

            max_deltas = np.array([max_delta_vlos_r500_x_ew, max_delta_vlos_rvir_x_ew, max_delta_vlos_r500_y_ew, max_delta_vlos_rvir_y_ew, max_delta_vlos_r500_z_ew, max_delta_vlos_rvir_z_ew,max_delta_vlos_r500_cen_ew, max_delta_vlos_rvir_cen_ew, max_delta_vlos_r500_x_mw, max_delta_vlos_rvir_x_mw, max_delta_vlos_r500_y_mw, max_delta_vlos_rvir_y_mw, max_delta_vlos_r500_z_mw, max_delta_vlos_rvir_z_mw, max_delta_vlos_r500_cen_mw, max_delta_vlos_rvir_cen_mw])
            sigma_t_2 = np.array([sigma_vt_2_r500_x_ew, sigma_vt_2_rvir_x_ew, sigma_vt_2_r500_y_ew, sigma_vt_2_rvir_y_ew, sigma_vt_2_r500_z_ew, sigma_vt_2_rvir_z_ew,sigma_vt_2_r500_cen_ew, sigma_vt_2_rvir_cen_ew, sigma_vt_2_r500_x_mw, sigma_vt_2_rvir_x_mw, sigma_vt_2_r500_y_mw, sigma_vt_2_rvir_y_mw, sigma_vt_2_r500_z_mw, sigma_vt_2_rvir_z_mw, sigma_vt_2_r500_cen_mw, sigma_vt_2_rvir_cen_mw])


            return mean_vel_disps,max_deltas,sigma_t_2

            #sys.exit()


        #mean_vel_disp_R500_x, mean_vel_disp_Rvir_x, max_delta_vlos_rvir_x, max_delta_vlos_r500_x, mean_vel_disp_R500_y, mean_vel_disp_Rvir_y, max_delta_vlos_rvir_y, max_delta_vlos_r500_y, mean_vel_disp_R500_z, mean_vel_disp_Rvir_z, max_delta_vlos_rvir_z, max_delta_vlos_r500_z = vel_props_from_maps()

        mean_vel_disps,max_deltas,sigma_t_2 = vel_props_from_maps()

        #sys.exit()

        sigma_r_2_log_R500_x_ew = np.log10(mean_vel_disps[0]**2)
        vt_log_R500_x_ew = np.log10(max_deltas[0])
        sigma_t_2_log_R500_x_ew = np.log10(sigma_t_2[0]**2)

        sigma_r_2_log_Rvir_x_ew = np.log10(mean_vel_disps[1]**2)
        vt_log_Rvir_x_ew = np.log10(max_deltas[1])
        sigma_t_2_log_Rvir_x_ew = np.log10(sigma_t_2[1]**2)


        sigma_r_2_log_R500_y_ew = np.log10(mean_vel_disps[2]**2)
        vt_log_R500_y_ew = np.log10(max_deltas[2])
        sigma_t_2_log_R500_y_ew = np.log10(sigma_t_2[2]**2)

        sigma_r_2_log_Rvir_y_ew = np.log10(mean_vel_disps[3]**2)
        vt_log_Rvir_y_ew = np.log10(max_deltas[3])
        sigma_t_2_log_Rvir_y_ew = np.log10(sigma_t_2[3]**2)

        sigma_r_2_log_R500_z_ew = np.log10(mean_vel_disps[4]**2)
        vt_log_R500_z_ew = np.log10(max_deltas[4])
        sigma_t_2_log_R500_z_ew = np.log10(sigma_t_2[4]**2)

        sigma_r_2_log_Rvir_z_ew = np.log10(mean_vel_disps[5]**2)
        vt_log_Rvir_z_ew = np.log10(max_deltas[5])
        sigma_t_2_log_Rvir_z_ew = np.log10(sigma_t_2[5]**2)

        sigma_r_2_log_R500_cen_ew = np.log10(mean_vel_disps[6]**2)
        vt_log_R500_cen_ew = np.log10(max_deltas[6])
        sigma_t_2_log_R500_cen_ew = np.log10(sigma_t_2[6]**2)

        sigma_r_2_log_Rvir_cen_ew = np.log10(mean_vel_disps[7]**2)
        vt_log_Rvir_cen_ew = np.log10(max_deltas[7])
        sigma_t_2_log_Rvir_cen_ew = np.log10(sigma_t_2[7]**2)

        sigma_r_2_log_R500_x_mw = np.log10(mean_vel_disps[8]**2)
        vt_log_R500_x_mw = np.log10(max_deltas[8])
        sigma_t_2_log_R500_x_mw = np.log10(sigma_t_2[8]**2)

        sigma_r_2_log_Rvir_x_mw = np.log10(mean_vel_disps[9]**2)
        vt_log_Rvir_x_mw = np.log10(max_deltas[9])
        sigma_t_2_log_Rvir_x_mw = np.log10(sigma_t_2[9]**2)

        sigma_r_2_log_R500_y_mw = np.log10(mean_vel_disps[10]**2)
        vt_log_R500_y_mw = np.log10(max_deltas[10])
        sigma_t_2_log_R500_y_mw = np.log10(sigma_t_2[10]**2)

        sigma_r_2_log_Rvir_y_mw = np.log10(mean_vel_disps[11]**2)
        vt_log_Rvir_y_mw = np.log10(max_deltas[11])
        sigma_t_2_log_Rvir_y_mw = np.log10(sigma_t_2[11]**2)

        sigma_r_2_log_R500_z_mw = np.log10(mean_vel_disps[12]**2)
        vt_log_R500_z_mw = np.log10(max_deltas[12])
        sigma_t_2_log_R500_z_mw = np.log10(sigma_t_2[12]**2)

        sigma_r_2_log_Rvir_z_mw = np.log10(mean_vel_disps[13]**2)
        vt_log_Rvir_z_mw = np.log10(max_deltas[13])
        sigma_t_2_log_Rvir_z_mw = np.log10(sigma_t_2[13]**2)

        sigma_r_2_log_R500_cen_mw = np.log10(mean_vel_disps[14]**2)
        vt_log_R500_cen_mw = np.log10(max_deltas[14])
        sigma_t_2_log_R500_cen_mw = np.log10(sigma_t_2[14]**2)

        sigma_r_2_log_Rvir_cen_mw = np.log10(mean_vel_disps[15]**2)
        vt_log_Rvir_cen_mw = np.log10(max_deltas[15])
        sigma_t_2_log_Rvir_cen_mw = np.log10(sigma_t_2[15]**2)

        mrot_ratio_r500 = np.zeros(8)
        mrot_ratio_rvir = np.zeros(8)
        mrand_ratio_r500 = np.zeros(8)
        mrand_ratio_rvir = np.zeros(8)
        mhe_ratio_r500 = np.zeros(8)
        mhe_ratio_rvir = np.zeros(8)

        mhe_mtot_ratio_r500 = np.zeros(8)
        mhe_mtot_ratio_rvir = np.zeros(8)
        mcorr_mtot_ratio_r500 = np.zeros(8)
        mcorr_mtot_ratio_rvir = np.zeros(8)

        print('Emission-weighted')

        p_prof = np.array([x_p,y_p,z_p,cen_p])
        ne_prof = np.array([x_ne,y_ne,z_ne,cen_ne])
        sl=['x','y','z','cen']

        for i in range(4):

            msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(p_prof[i], ne_prof[i], m_cumul_sum, 0, np.log10(mean_vel_disps[2*i]**2), np.log10(sigma_t_2[2*i]**2), np.log10(max_deltas[2*i]), 12)
            print("r500 ",sl[i])
            # print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
            # print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
            # print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)
            print( "mhe", "{:.2e}".format(msz_500), "mrot", "{:.2e}".format(mrot_500), "mdisp", "{:.2e}".format(mrand_500),"mcorr","{:.2e}".format(mall_500))

            mrot_ratio_r500[i] = mrot_500 / mall_500
            mrand_ratio_r500[i] = mrand_500 / mall_500
            mhe_ratio_r500[i] = msz_500 / mall_500
            mhe_mtot_ratio_r500[i] = msz_500 / m_cumul_sum[12]
            mcorr_mtot_ratio_r500[i] = mall_500 / m_cumul_sum[12]

        for i in range(4):

            msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(p_prof[i], ne_prof[i], m_cumul_sum, 0, np.log10(mean_vel_disps[8 + 2 * i] ** 2), np.log10(sigma_t_2[8 + 2 * i] ** 2), np.log10(max_deltas[8 + 2 * i]), 12)
            print("r500 ", sl[i])
            # print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
            # print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
            # print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)
            print("mhe", "{:.2e}".format(msz_500), "mrot", "{:.2e}".format(mrot_500), "mdisp", "{:.2e}".format(mrand_500), "mcorr", "{:.2e}".format(mall_500))

            mrot_ratio_r500[i] = mrot_500 / mall_500
            mrand_ratio_r500[i] = mrand_500 / mall_500
            mhe_ratio_r500[i] = msz_500 / mall_500
            mhe_mtot_ratio_r500[i] = msz_500 / m_cumul_sum[12]
            mcorr_mtot_ratio_r500[i] = mall_500 / m_cumul_sum[12]

        for i in range(4):

            msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(p_prof[i], ne_prof[i], m_cumul_sum, 0, np.log10(mean_vel_disps[2*i+1]**2), np.log10(sigma_t_2[2*i+1]**2), np.log10(max_deltas[2*i+1]), 15)
            print("rvir ",sl[i])
            # print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
            # print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
            # print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
            print( "mhe", "{:.2e}".format(msz_vir), "mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir),"mcorr","{:.2e}".format(mall_vir))

            mrot_ratio_rvir[0] = mrot_vir / mall_vir
            mrand_ratio_rvir[0] = mrand_vir / mall_vir
            mhe_ratio_rvir[0] = msz_vir / mall_vir
            mhe_mtot_ratio_rvir[0] = msz_vir / m_cumul_sum[15]
            mcorr_mtot_ratio_rvir[0] = mall_vir / m_cumul_sum[15]

        for i in range(4):

            msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(p_prof[i], ne_prof[i], m_cumul_sum, 0, np.log10(mean_vel_disps[8 + 2 * i + 1] ** 2), np.log10(sigma_t_2[8 + 2 * i + 1] ** 2), np.log10(max_deltas[8 + 2 * i + 1]), 15)
            print("rvir ", sl[i])
            # print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
            # print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
            # print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
            print("mhe", "{:.2e}".format(msz_vir), "mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir), "mcorr", "{:.2e}".format(mall_vir))

            mrot_ratio_rvir[0] = mrot_vir / mall_vir
            mrand_ratio_rvir[0] = mrand_vir / mall_vir
            mhe_ratio_rvir[0] = msz_vir / mall_vir
            mhe_mtot_ratio_rvir[0] = msz_vir / m_cumul_sum[15]
            mcorr_mtot_ratio_rvir[0] = mall_vir / m_cumul_sum[15]

        sys.exit()
        msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(x_p, x_ne, m_cumul_sum, 0, sigma_r_2_log_R500_x_ew, sigma_t_2_log_R500_x_ew ,vt_log_R500_x_ew, 12)
        print("r500 x")
        #print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
        #print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
        #print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)
        print("mrot","{:.2e}".format(mrot_500),"mdisp","{:.2e}".format(mrand_500),"mhe","{:.2e}".format(msz_500))


        mrot_ratio_r500[0] = mrot_500 / mall_500
        mrand_ratio_r500[0] = mrand_500 / mall_500
        mhe_ratio_r500[0] = msz_500 / mall_500
        mhe_mtot_ratio_r500[0] = msz_500/m_cumul_sum[12]
        mcorr_mtot_ratio_r500[0] = mall_500 / m_cumul_sum[12]

        msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(x_p, x_ne, m_cumul_sum, 0, sigma_r_2_log_Rvir_x_ew, sigma_t_2_log_Rvir_x_ew, vt_log_Rvir_x_ew, 15)
        print("rvir x")
        #print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
        print("mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir), "mhe", "{:.2e}".format(msz_vir))

        mrot_ratio_rvir[0] = mrot_vir / mall_vir
        mrand_ratio_rvir[0] = mrand_vir / mall_vir
        mhe_ratio_rvir[0] = msz_vir / mall_vir
        mhe_mtot_ratio_rvir[0] = msz_vir / m_cumul_sum[15]
        mcorr_mtot_ratio_rvir[0] = mall_vir / m_cumul_sum[15]

        msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(y_p, y_ne, m_cumul_sum, 0, sigma_r_2_log_R500_y_ew, sigma_t_2_log_R500_y_ew,  vt_log_R500_y_ew, 12)
        print("r500 y")
        # print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
        #print("bsz", msz_500 / m_cumul_sum[12], "bcorr", mcorr_500 / m_cumul_sum[12], "ball", mall_500 / m_cumul_sum[12])
        #print("msz/mall", msz_500 / mall_500, "mrand/mall", mrand_500 / mall_500, "mrot/mall", mrot_500 / mall_500)
        print("mrot", "{:.2e}".format(mrot_500), "mdisp", "{:.2e}".format(mrand_500), "mhe", "{:.2e}".format(msz_500))

        mrot_ratio_r500[1] = mrot_500 / mall_500
        mrand_ratio_r500[1] = mrand_500 / mall_500
        mhe_ratio_r500[1] = msz_500 / mall_500
        mhe_mtot_ratio_r500[1] = msz_500 / m_cumul_sum[12]
        mcorr_mtot_ratio_r500[1] = mall_500 / m_cumul_sum[12]

        msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(y_p, y_ne, m_cumul_sum, 0, sigma_r_2_log_Rvir_y_ew, sigma_t_2_log_Rvir_y_ew,  vt_log_Rvir_y_ew, 15)
        print("rvir y")
        # print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
        print("mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir), "mhe", "{:.2e}".format(msz_vir))

        mrot_ratio_rvir[1] = mrot_vir / mall_vir
        mrand_ratio_rvir[1] = mrand_vir / mall_vir
        mhe_ratio_rvir[1] = msz_vir / mall_vir
        mhe_mtot_ratio_rvir[1] = msz_vir / m_cumul_sum[15]
        mcorr_mtot_ratio_rvir[1] = mall_vir / m_cumul_sum[15]

        msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(z_p, z_ne, m_cumul_sum, 0, sigma_r_2_log_R500_z_ew, sigma_t_2_log_R500_z_ew,  vt_log_R500_z_ew, 12)
        print("r500 z")
        #print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
        #print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
        #print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)
        print("mrot", "{:.2e}".format(mrot_500), "mdisp", "{:.2e}".format(mrand_500), "mhe", "{:.2e}".format(msz_500))

        mrot_ratio_r500[2] = mrot_500 / mall_500
        mrand_ratio_r500[2] = mrand_500 / mall_500
        mhe_ratio_r500[2] = msz_500 / mall_500
        mhe_mtot_ratio_r500[2] = msz_500 / m_cumul_sum[12]
        mcorr_mtot_ratio_r500[2] = mall_500 / m_cumul_sum[12]

        msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(z_p, z_ne, m_cumul_sum, 0, sigma_r_2_log_Rvir_z_ew, sigma_t_2_log_Rvir_z_ew, vt_log_Rvir_z_ew, 15)
        print("rvir z")
        #print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
        print("mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir), "mhe", "{:.2e}".format(msz_vir))

        mrot_ratio_rvir[2] = mrot_vir / mall_vir
        mrand_ratio_rvir[2] = mrand_vir / mall_vir
        mhe_ratio_rvir[2] = msz_vir / mall_vir
        mhe_mtot_ratio_rvir[2] = msz_vir / m_cumul_sum[15]
        mcorr_mtot_ratio_rvir[2] = mall_vir / m_cumul_sum[15]

        msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(cen_p, cen_ne, m_cumul_sum, 0, sigma_r_2_log_R500_cen_ew, sigma_t_2_log_R500_cen_ew,  vt_log_R500_cen_ew, 12)
        print("r500 cen")
        #print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500
        #print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
        #print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)
        print("mrot", "{:.2e}".format(mrot_500), "mdisp", "{:.2e}".format(mrand_500), "mhe", "{:.2e}".format(msz_500))

        mrot_ratio_r500[3] = mrot_500 / mall_500
        mrand_ratio_r500[3] = mrand_500 / mall_500
        mhe_ratio_r500[3] = msz_500 / mall_500
        mhe_mtot_ratio_r500[3] = msz_500 / m_cumul_sum[12]
        mcorr_mtot_ratio_r500[3] = mall_500 / m_cumul_sum[12]

        msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(cen_p, cen_ne, m_cumul_sum, 0, sigma_r_2_log_Rvir_cen_ew, sigma_t_2_log_Rvir_cen_ew, vt_log_Rvir_cen_ew, 15)
        print("rvir cen")
        #print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
        print("mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir), "mhe", "{:.2e}".format(msz_vir))

        mrot_ratio_rvir[3] = mrot_vir / mall_vir
        mrand_ratio_rvir[3] = mrand_vir / mall_vir
        mhe_ratio_rvir[3] = msz_vir / mall_vir
        mhe_mtot_ratio_rvir[3] = msz_vir / m_cumul_sum[15]
        mcorr_mtot_ratio_rvir[3] = mall_vir / m_cumul_sum[15]

        #msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(y_p_fit, y_ne_fit, m_cumul_sum, 0, sigma_r_2_log_R500, vt_log_R500, 12)

        #print("r500 fit")
        #print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
        #print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
        #print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)

        #msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(y_p_fit, y_ne_fit, m_cumul_sum, 0, sigma_r_2_log_Rvir, vt_log_Rvir, 15)
        #print("rvir fit")
        #print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)

        print('Mass-weighted')

        msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(x_p, x_ne, m_cumul_sum, 0, sigma_r_2_log_R500_x_mw, sigma_t_2_log_R500_x_mw, vt_log_R500_x_mw, 12)
        print("r500 x")
        # print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
        #print("bsz", msz_500 / m_cumul_sum[12], "bcorr", mcorr_500 / m_cumul_sum[12], "ball", mall_500 / m_cumul_sum[12])
        #print("msz/mall", msz_500 / mall_500, "mrand/mall", mrand_500 / mall_500, "mrot/mall", mrot_500 / mall_500)
        print("mrot", "{:.2e}".format(mrot_500), "mdisp", "{:.2e}".format(mrand_500), "mhe", "{:.2e}".format(msz_500))

        mrot_ratio_r500[4] = mrot_500 / mall_500
        mrand_ratio_r500[4] = mrand_500 / mall_500
        mhe_ratio_r500[4] = msz_500 / mall_500
        mhe_mtot_ratio_r500[4] = msz_500 / m_cumul_sum[12]
        mcorr_mtot_ratio_r500[4] = mall_500 / m_cumul_sum[12]

        msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(x_p, x_ne, m_cumul_sum, 0, sigma_r_2_log_Rvir_x_mw, sigma_t_2_log_Rvir_x_mw, vt_log_Rvir_x_mw, 15)
        print("rvir x")
        # print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
        print("mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir), "mhe", "{:.2e}".format(msz_vir))

        mrot_ratio_rvir[4] = mrot_vir / mall_vir
        mrand_ratio_rvir[4] = mrand_vir / mall_vir
        mhe_ratio_rvir[4] = msz_vir / mall_vir
        mhe_mtot_ratio_rvir[4] = msz_vir / m_cumul_sum[15]
        mcorr_mtot_ratio_rvir[4] = mall_vir / m_cumul_sum[15]

        msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(y_p, y_ne, m_cumul_sum, 0, sigma_r_2_log_R500_y_mw, sigma_t_2_log_R500_y_mw, vt_log_R500_y_mw, 12)
        print("r500 y")
        #print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
        #print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
        #print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)
        print("mrot", "{:.2e}".format(mrot_500), "mdisp", "{:.2e}".format(mrand_500), "mhe", "{:.2e}".format(msz_500))

        mrot_ratio_r500[5] = mrot_500 / mall_500
        mrand_ratio_r500[5] = mrand_500 / mall_500
        mhe_ratio_r500[5] = msz_500 / mall_500
        mhe_mtot_ratio_r500[5] = msz_500 / m_cumul_sum[12]
        mcorr_mtot_ratio_r500[5] = mall_500 / m_cumul_sum[12]

        msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(y_p, y_ne, m_cumul_sum, 0, sigma_r_2_log_Rvir_y_mw, sigma_t_2_log_Rvir_y_mw, vt_log_Rvir_y_mw, 15)
        print("rvir y")
        #print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
        print("mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir), "mhe", "{:.2e}".format(msz_vir))

        mrot_ratio_rvir[5] = mrot_vir / mall_vir
        mrand_ratio_rvir[5] = mrand_vir / mall_vir
        mhe_ratio_rvir[5] = msz_vir / mall_vir
        mhe_mtot_ratio_rvir[5] = msz_vir / m_cumul_sum[15]
        mcorr_mtot_ratio_rvir[5] = mall_vir / m_cumul_sum[15]

        msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(z_p, z_ne, m_cumul_sum, 0, sigma_r_2_log_R500_z_mw, sigma_t_2_log_R500_z_mw, vt_log_R500_z_mw, 12)
        print("r500 z")
        #print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
        #print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
        #print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)
        print("mrot", "{:.2e}".format(mrot_500), "mdisp", "{:.2e}".format(mrand_500), "mhe", "{:.2e}".format(msz_500))

        mrot_ratio_r500[6] = mrot_500 / mall_500
        mrand_ratio_r500[6] = mrand_500 / mall_500
        mhe_ratio_r500[6] = msz_500 / mall_500
        mhe_mtot_ratio_r500[6] = msz_500 / m_cumul_sum[12]
        mcorr_mtot_ratio_r500[6] = mall_500 / m_cumul_sum[12]

        msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(z_p, z_ne, m_cumul_sum, 0, sigma_r_2_log_Rvir_z_mw,  sigma_t_2_log_Rvir_z_mw, vt_log_Rvir_z_mw, 15)
        print("rvir z")
        #print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
        print("mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir), "mhe", "{:.2e}".format(msz_vir))

        mrot_ratio_rvir[6] = mrot_vir / mall_vir
        mrand_ratio_rvir[6] = mrand_vir / mall_vir
        mhe_ratio_rvir[6] = msz_vir / mall_vir
        mhe_mtot_ratio_rvir[6] = msz_vir / m_cumul_sum[15]
        mcorr_mtot_ratio_rvir[6] = mall_vir / m_cumul_sum[15]

        msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(cen_p, cen_ne, m_cumul_sum, 0, sigma_r_2_log_R500_cen_mw, sigma_t_2_log_R500_cen_mw, vt_log_R500_cen_mw, 12)
        print("r500 cen")
        #print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500
        #print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
        #print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)
        print("mrot", "{:.2e}".format(mrot_500), "mdisp", "{:.2e}".format(mrand_500), "mhe", "{:.2e}".format(msz_500))

        mrot_ratio_r500[7] = mrot_500 / mall_500
        mrand_ratio_r500[7] = mrand_500 / mall_500
        mhe_ratio_r500[7] = msz_500 / mall_500
        mhe_mtot_ratio_r500[7] = msz_500 / m_cumul_sum[12]
        mcorr_mtot_ratio_r500[7] = mall_500 / m_cumul_sum[12]

        msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(cen_p, cen_ne, m_cumul_sum, 0, sigma_r_2_log_Rvir_cen_mw, sigma_t_2_log_Rvir_cen_mw, vt_log_Rvir_cen_mw, 15)
        print("rvir cen")
        #print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)
        print("mrot", "{:.2e}".format(mrot_vir), "mdisp", "{:.2e}".format(mrand_vir), "mhe", "{:.2e}".format(msz_vir))

        mrot_ratio_rvir[7] = mrot_vir / mall_vir
        mrand_ratio_rvir[7] = mrand_vir / mall_vir
        mhe_ratio_rvir[7] = msz_vir / mall_vir
        mhe_mtot_ratio_rvir[7] = msz_vir / m_cumul_sum[15]
        mcorr_mtot_ratio_rvir[7] = mall_vir / m_cumul_sum[15]

        #msz_500, mcorr_500, mrand_500, mrot_500, mall_500 = compute_mass_proj(y_p_fit, y_ne_fit, m_cumul_sum, 0, sigma_r_2_log_R500, vt_log_R500, 12)

        #print("r500 fit")
        #print("msz_500",msz_500,"mcorr_500",mcorr_500,"mrand_500",mrand_500,"mrot_500",mrot_500,"mall_500",mall_500,'m_cumul_sum',m_cumul_sum[12])
        #print("bsz",msz_500/m_cumul_sum[12],"bcorr",mcorr_500/m_cumul_sum[12],"ball",mall_500/m_cumul_sum[12])
        #print("msz/mall",msz_500/mall_500,"mrand/mall",mrand_500/mall_500,"mrot/mall",mrot_500/mall_500)

        #msz_vir, mcorr_vir, mrand_vir, mrot_vir, mall_vir = compute_mass_proj(y_p_fit, y_ne_fit, m_cumul_sum, 0, sigma_r_2_log_Rvir, vt_log_Rvir, 15)
        #print("rvir fit")
        #print("msz_vir", msz_vir, "mcorr_vir", mcorr_vir, "mrand_vir", mrand_vir, "mrot_vir", mrot_vir, "mall_vir", mall_vir, 'm_cumul_sum', m_cumul_sum[15])
        #print("bsz", msz_vir / m_cumul_sum[15], "bcorr", mcorr_vir / m_cumul_sum[15], "ball", mall_vir / m_cumul_sum[15])
        #print("msz/mall", msz_vir / mall_vir, "mrand/mall", mrand_vir / mall_vir, "mrot/mall", mrot_vir / mall_vir)



        def m_over_mcorr_2D_plot(mrot_ratio_r500,mrot_ratio_rvir,mrand_ratio_r500,mrand_ratio_rvir):

            #mrand_3D_ratio = np.load("ratio_mrand_prof.npy")
            #mrot_3D_ratio = np.load("ratio_mrot_prof.npy")
            #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

            mhe_3D_ratio = np.load("./vel_Virgo_core_project/mhe_mcorr_ratio_3D.npy")
            mdisp_3D_ratio = np.load("./vel_Virgo_core_project/mdisp_mcorr_ratio_3D.npy")
            mrot_3D_ratio = np.load("./vel_Virgo_core_project/mrot_mcorr_ratio_3D.npy")

            rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(20)])


            mrot_ratio_3D_500 = 0.04117427975943368
            mrot_ratio_3D_vir = 0.0516384864973112

            f,axs = plt.subplots(3,1,figsize=(8,12),sharex=True)
            f.subplots_adjust(hspace=0.05)

            x_mrot_500 = 1087

            axs[0].plot(x_mrot_500, mhe_ratio_r500[0], 'x', color='red', label='$x_{ew}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_ratio_r500[1], 'x', color='blue', label='$y_{ew}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_ratio_r500[2], 'x', color='green', label='$z_{ew}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_ratio_r500[3], 'x', color='pink', label='$cen_{ew}$', ms=12)

            axs[0].plot(rlogbin_cen, mhe_3D_ratio, color='black', label='3D', ls='dashed', marker='+')

            axs[0].plot(x_mrot_500, mhe_ratio_r500[4], '.', color='red', label='$x_{mw}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_ratio_r500[5], '.', color='blue', label='$y_{mw}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_ratio_r500[6], '.', color='green', label='$z_{mw}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_ratio_r500[7], '.', color='pink', label='$cen_{mw}$', ms=12)

            x_mrot_vir = 2147

            # axs[0].plot(x_mrot_vir, mhe_ratio_3D_vir, '+', color='black',ms=12)#,label='3D'

            axs[0].plot(x_mrot_vir, mhe_ratio_rvir[0], 'x', color='red', ms=12)  # , label='x')
            axs[0].plot(x_mrot_vir, mhe_ratio_rvir[1], 'x', color='blue', ms=12)  # , label='y')
            axs[0].plot(x_mrot_vir, mhe_ratio_rvir[2], 'x', color='green', ms=12)  # , label='z')
            axs[0].plot(x_mrot_vir, mhe_ratio_rvir[3], 'x', color='pink', ms=12)  # , label='z')

            axs[0].plot(x_mrot_vir, mhe_ratio_rvir[4], '.', color='red', ms=12)  # ,label='x')
            axs[0].plot(x_mrot_vir, mhe_ratio_rvir[5], '.', color='blue', ms=12)  # ,label='y')
            axs[0].plot(x_mrot_vir, mhe_ratio_rvir[6], '.', color='green', ms=12)  # ,label='z')
            axs[0].plot(x_mrot_vir, mhe_ratio_rvir[7], '.', color='pink', ms=12)  # ,label='z')

            print("mhe ratio r500", mhe_ratio_r500)
            print("mhe ratio rvir", mhe_ratio_rvir)

            axs[0].axvline(x=1087, color='grey', ls='dotted')
            # axs[0].text(1087, -0.05, '$R_{500}$', fontsize=14, color='grey',rotation=90)
            axs[0].axvline(x=2147, color='grey', ls='dotted')
            # axs[0].text(2147, -0.05, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
            axs[0].axhline(y=0, color='grey', ls='dotted')

            axs[0].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            axs[0].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=14, labelbottom=False, labelleft=True)
            axs[0].set_ylim(0.8, 1.1)
            axs[0].axhline(1, color='black', ls='dotted')
            axs[0].set_ylabel('$M_{HE}/M_{corr}$')

            axs[0].axvline(x=1087, color='grey', ls='dotted')
            axs[0].text(1087, 1.05, '$R_{500}$', fontsize=14, color='grey',rotation=90)
            axs[0].axvline(x=2147, color='grey', ls='dotted')
            axs[0].text(2147, 1.05, '$R_{vir}$', fontsize=14, color='grey',rotation=90)
            axs[0].axhline(y=0, color='grey', ls='dotted')

            axs[0].legend(ncols=2, fontsize=14)

            #axs[0].plot(x_mrot_500, mrot_ratio_3D_500, '+', color='black', label='3D',ms=12)

            axs[1].plot(x_mrot_500, mrot_ratio_r500[0], 'x', color='red', label='$x_{ew}$',ms=12)
            axs[1].plot(x_mrot_500, mrot_ratio_r500[1], 'x', color='blue', label='$y_{ew}$',ms=12)
            axs[1].plot(x_mrot_500, mrot_ratio_r500[2], 'x', color='green', label='$z_{ew}$',ms=12)
            axs[1].plot(x_mrot_500, mrot_ratio_r500[3], 'x', color='pink', label='$cen_{ew}$', ms=12)

            axs[1].plot(x_mrot_500, mrot_ratio_r500[4], '.', color='red',label='$x_{mw}$',ms=12)
            axs[1].plot(x_mrot_500, mrot_ratio_r500[5], '.', color='blue',label='$y_{mw}$',ms=12)
            axs[1].plot(x_mrot_500, mrot_ratio_r500[6], '.', color='green',label='$z_{mw}$',ms=12)
            axs[1].plot(x_mrot_500, mrot_ratio_r500[7], '.', color='pink', label='$cen_{mw}$', ms=12)


            x_mrot_vir = 2147

            #axs[1].plot(x_mrot_vir, mrot_ratio_3D_vir, '+', color='black',ms=12)#,label='3D'

            axs[1].plot(x_mrot_vir, mrot_ratio_rvir[0], 'x', color='red',ms=12)#, label='x')
            axs[1].plot(x_mrot_vir, mrot_ratio_rvir[1], 'x', color='blue',ms=12)#, label='y')
            axs[1].plot(x_mrot_vir, mrot_ratio_rvir[2], 'x', color='green',ms=12)#, label='z')
            axs[1].plot(x_mrot_vir, mrot_ratio_rvir[3], 'x', color='pink', ms=12)  # , label='z')

            axs[1].plot(x_mrot_vir, mrot_ratio_rvir[4], '.', color='red',ms=12)#,label='x')
            axs[1].plot(x_mrot_vir, mrot_ratio_rvir[5], '.', color='blue',ms=12)#,label='y')
            axs[1].plot(x_mrot_vir, mrot_ratio_rvir[6], '.', color='green',ms=12)#,label='z')
            axs[1].plot(x_mrot_vir, mrot_ratio_rvir[7], '.', color='pink',ms=12)#,label='z')


            axs[1].plot(rlogbin_cen, mrot_3D_ratio, color='black', label='3D', ls='dashed',marker='+')

            #plt.axvline(x=3,color='black',ls='solid')

            #axs[1].set_xticks([2,4],['$R_{500}$','$R_{vir}$'])

            axs[1].set_ylabel('$M_{rot}/M_{corr}$')
            axs[1].set_xlim(200,3000)
            axs[1].set_ylim(-0.01, 0.13)

            #axs[1].legend(ncols=3)
            axs[1].set_xscale('log')

            axs[1].axvline(x=1087, color='grey', ls='dotted')
            #axs[1].text(1087, -0.05, '$R_{500}$', fontsize=14, color='grey', rotation=90)
            axs[1].axvline(x=2147, color='grey', ls='dotted')
            #axs[1].text(2147, -0.05, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
            axs[1].axhline(y=0,color='grey', ls='dotted')

            axs[1].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            axs[1].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=14, labelbottom=False, labelleft=True)


            #axs[0].set_xlabel('$R\,[\mathrm{kpc}]$')

            mrand_ratio_3D_500 = -0.018998232947627983
            mrand_ratio_3D_vir = 0.04467090646625246


            x_mrand_500 = 1087

            #axs[2].plot(x_mrand_500, mrand_ratio_3D_500, '+', color='black', label='3D', ms=15)

            axs[2].plot(x_mrand_500, mrand_ratio_r500[0], 'x', color='red', label='$x_{ew}$', ms=12)
            axs[2].plot(x_mrand_500, mrand_ratio_r500[1], 'x', color='blue', label='$y_{ew}$', ms=12)
            axs[2].plot(x_mrand_500, mrand_ratio_r500[2], 'x', color='green', label='$z_{ew}$', ms=12)
            axs[2].plot(x_mrand_500, mrand_ratio_r500[3], 'x', color='pink', label='$cen_{ew}$', ms=12)

            axs[2].plot(rlogbin_cen, mdisp_3D_ratio, color='black', label='3D', ls='dashed', marker='+')


            axs[2].plot(x_mrand_500, mrand_ratio_r500[4], '.', color='red', label='$x_{mw}$', ms=12)
            axs[2].plot(x_mrand_500, mrand_ratio_r500[5], '.', color='blue', label='$y_{mw}$', ms=12)
            axs[2].plot(x_mrand_500, mrand_ratio_r500[6], '.', color='green', label='$z_{mw}$', ms=12)
            axs[2].plot(x_mrand_500, mrand_ratio_r500[7], '.', color='pink', label='$cen_{mw}$', ms=12)

            x_mrand_vir = 2147

            #axs[2].plot(x_mrand_vir, mrand_ratio_3D_vir, '+', color='black', ms=15)  # ,label='3D'

            axs[2].plot(x_mrand_vir, mrand_ratio_rvir[0], 'x', color='red', ms=12)  # , label='x')
            axs[2].plot(x_mrand_vir, mrand_ratio_rvir[1], 'x', color='blue', ms=12)  # , label='y')
            axs[2].plot(x_mrand_vir, mrand_ratio_rvir[2], 'x', color='green', ms=12)  # , label='z')
            axs[2].plot(x_mrand_vir, mrand_ratio_rvir[3], 'x', color='pink', ms=12)  # , label='z')

            axs[2].plot(x_mrand_vir, mrand_ratio_rvir[4], '.', color='red', ms=12)  # ,label='x')
            axs[2].plot(x_mrand_vir, mrand_ratio_rvir[5], '.', color='blue', ms=12)  # ,label='y')
            axs[2].plot(x_mrand_vir, mrand_ratio_rvir[6], '.', color='green', ms=12)  # ,label='z')
            axs[2].plot(x_mrand_vir, mrand_ratio_rvir[7], '.', color='pink', ms=12)  # ,label='z')



            # plt.axvline(x=3,color='black',ls='solid')

            #axs[2].set_xticks([1087, 2147], ['$R_{500}$', '$R_{vir}$'])

            axs[2].set_ylabel('$M_{disp}/M_{corr}$')
            axs[2].set_xlim(200, 3000)
            #axs[2].set_xlabel('$R\,[\mathrm{kpc}]$')
            #axs[2].set_yscale('symlog',linthresh=1e-2)
            #axs[2].set_ylim(-0.1, 0.15)

            axs[2].set_xscale('log')
            #axs[2].set_ylim(1e-3, 0.15)
            axs[2].set_ylim(-0.09, 0.12)
            axs[2].axvline(x=1087, color='grey', ls='dotted')
            #axs[2].text(1087, -0.05, '$R_{500}$', fontsize=14, color='grey',rotation=90)
            axs[2].axvline(x=2147, color='grey', ls='dotted')
            #axs[2].text(2147, -0.05, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
            axs[2].axhline(y=0, color='grey', ls='dotted')

            axs[2].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=True)
            axs[2].tick_params(which="major", right=True, top=True, direction="in", length=5, labelbottom=True, labelleft=True)

            #axs[3].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            #axs[3].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=14, labelbottom=True, labelleft=True)

            axs[2].set_xlabel('$R\,[\mathrm{kpc}]$')



            plt.show()
            sys.exit()

        def m_over_mtot_2D_plot():

            # mrand_3D_ratio = np.load("ratio_mrand_prof.npy")
            # mrot_3D_ratio = np.load("ratio_mrot_prof.npy")
            # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

            #mhe_3D_ratio = np.load("./vel_Virgo_core_project/mhe_mcorr_ratio_3D.npy")
            #mdisp_3D_ratio = np.load("./vel_Virgo_core_project/mdisp_mcorr_ratio_3D.npy")
            #mrot_3D_ratio = np.load("./vel_Virgo_core_project/mrot_mcorr_ratio_3D.npy")

            mhe_mtot_3D_ratio = np.load("./vel_Virgo_core_project/msz_over_mtot_3D.npy")
            mcorr_mtot_3D_ratio = np.load("./vel_Virgo_core_project/mcorr_over_mtot_3D.npy")

            rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(20)])

            mrot_ratio_3D_500 = 0.04117427975943368
            mrot_ratio_3D_vir = 0.0516384864973112

            f, axs = plt.subplots(1, 2, figsize=(8, 12), sharex=True)
            f.subplots_adjust(hspace=0.05)

            x_mrot_500 = 1087

            axs[0].plot(x_mrot_500, mhe_mtot_ratio_r500[0], 'x', color='red', label='$x_{ew}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_mtot_ratio_r500[1], 'x', color='blue', label='$y_{ew}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_mtot_ratio_r500[2], 'x', color='green', label='$z_{ew}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_mtot_ratio_r500[3], 'x', color='pink', label='$cen_{ew}$', ms=12)

            axs[0].plot(rlogbin_cen, mhe_mtot_3D_ratio, color='black', label='3D', ls='dashed', marker='+')

            axs[0].plot(x_mrot_500, mhe_mtot_ratio_r500[4], '.', color='red', label='$x_{mw}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_mtot_ratio_r500[5], '.', color='blue', label='$y_{mw}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_mtot_ratio_r500[6], '.', color='green', label='$z_{mw}$', ms=12)
            axs[0].plot(x_mrot_500, mhe_mtot_ratio_r500[7], '.', color='pink', label='$cen_{mw}$', ms=12)

            x_mrot_vir = 2147

            # axs[0].plot(x_mrot_vir, mhe_ratio_3D_vir, '+', color='black',ms=12)#,label='3D'

            axs[0].plot(x_mrot_vir, mhe_mtot_ratio_rvir[0], 'x', color='red', ms=12)  # , label='x')
            axs[0].plot(x_mrot_vir, mhe_mtot_ratio_rvir[1], 'x', color='blue', ms=12)  # , label='y')
            axs[0].plot(x_mrot_vir, mhe_mtot_ratio_rvir[2], 'x', color='green', ms=12)  # , label='z')
            axs[0].plot(x_mrot_vir, mhe_mtot_ratio_rvir[3], 'x', color='pink', ms=12)  # , label='z')

            axs[0].plot(x_mrot_vir, mhe_mtot_ratio_rvir[4], '.', color='red', ms=12)  # ,label='x')
            axs[0].plot(x_mrot_vir, mhe_mtot_ratio_rvir[5], '.', color='blue', ms=12)  # ,label='y')
            axs[0].plot(x_mrot_vir, mhe_mtot_ratio_rvir[6], '.', color='green', ms=12)  # ,label='z')
            axs[0].plot(x_mrot_vir, mhe_mtot_ratio_rvir[7], '.', color='pink', ms=12)  # ,label='z')

            print("mhe ratio r500", mhe_ratio_r500)
            print("mhe ratio rvir", mhe_ratio_rvir)

            axs[0].axvline(x=1087, color='grey', ls='dotted')
            # axs[0].text(1087, -0.05, '$R_{500}$', fontsize=14, color='grey',rotation=90)
            axs[0].axvline(x=2147, color='grey', ls='dotted')
            # axs[0].text(2147, -0.05, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
            axs[0].axhline(y=0, color='grey', ls='dotted')
            axs[0].set_ylim(0.8, 6)

            axs[0].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=True)
            axs[0].tick_params(which="major", right=True, top=True, direction="in", length=5, labelbottom=True, labelleft=True)
            #axs[0].set_ylim(0.8, 1.1)
            axs[0].axhline(1, color='black', ls='dotted')
            axs[0].set_ylabel('$M_{HE}/M_{tot}$')

            axs[0].axvline(x=1087, color='grey', ls='dotted')
            axs[0].text(1087, 4, '$R_{500}$', fontsize=14, color='grey', rotation=90)
            axs[0].axvline(x=2147, color='grey', ls='dotted')
            axs[0].text(2147, 4, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
            #axs[0].axhline(y=0, color='grey', ls='dotted')

            axs[0].set_xlabel('$R[\mathrm{kpc}]$')

            #axs[0].legend(ncols=2, fontsize=14)

            # axs[0].plot(x_mrot_500, mrot_ratio_3D_500, '+', color='black', label='3D',ms=12)

            axs[1].plot(x_mrot_500, mcorr_mtot_ratio_r500[0], 'x', color='red', label='$x_{ew}$', ms=12)
            axs[1].plot(x_mrot_500, mcorr_mtot_ratio_r500[1], 'x', color='blue', label='$y_{ew}$', ms=12)
            axs[1].plot(x_mrot_500, mcorr_mtot_ratio_r500[2], 'x', color='green', label='$z_{ew}$', ms=12)
            axs[1].plot(x_mrot_500, mcorr_mtot_ratio_r500[3], 'x', color='pink', label='$cen_{ew}$', ms=12)

            axs[1].plot(x_mrot_500, mcorr_mtot_ratio_r500[4], '.', color='red', label='$x_{mw}$', ms=12)
            axs[1].plot(x_mrot_500, mcorr_mtot_ratio_r500[5], '.', color='blue', label='$y_{mw}$', ms=12)
            axs[1].plot(x_mrot_500, mcorr_mtot_ratio_r500[6], '.', color='green', label='$z_{mw}$', ms=12)
            axs[1].plot(x_mrot_500, mcorr_mtot_ratio_r500[7], '.', color='pink', label='$cen_{mw}$', ms=12)

            x_mrot_vir = 2147

            # axs[1].plot(x_mrot_vir, mrot_ratio_3D_vir, '+', color='black',ms=12)#,label='3D'

            axs[1].plot(x_mrot_vir, mcorr_mtot_ratio_rvir[0], 'x', color='red', ms=12)  # , label='x')
            axs[1].plot(x_mrot_vir, mcorr_mtot_ratio_rvir[1], 'x', color='blue', ms=12)  # , label='y')
            axs[1].plot(x_mrot_vir, mcorr_mtot_ratio_rvir[2], 'x', color='green', ms=12)  # , label='z')
            axs[1].plot(x_mrot_vir, mcorr_mtot_ratio_rvir[3], 'x', color='pink', ms=12)  # , label='z')

            axs[1].plot(x_mrot_vir, mcorr_mtot_ratio_rvir[4], '.', color='red', ms=12)  # ,label='x')
            axs[1].plot(x_mrot_vir, mcorr_mtot_ratio_rvir[5], '.', color='blue', ms=12)  # ,label='y')
            axs[1].plot(x_mrot_vir, mcorr_mtot_ratio_rvir[6], '.', color='green', ms=12)  # ,label='z')
            axs[1].plot(x_mrot_vir, mcorr_mtot_ratio_rvir[7], '.', color='pink', ms=12)  # ,label='z')

            axs[1].plot(rlogbin_cen, mcorr_mtot_3D_ratio, color='black', label='3D', ls='dashed', marker='+')

            # plt.axvline(x=3,color='black',ls='solid')

            # axs[1].set_xticks([2,4],['$R_{500}$','$R_{vir}$'])

            axs[1].set_ylabel('$M_{corr}/M_{tot}$')
            axs[1].set_xlim(1000, 3000)
            axs[1].set_ylim(0.8, 6)

            # axs[1].legend(ncols=3)
            axs[1].set_xscale('log')

            axs[1].axvline(x=1087, color='grey', ls='dotted')
            axs[1].text(1087, 4, '$R_{500}$', fontsize=14, color='grey', rotation=90)
            axs[1].axvline(x=2147, color='grey', ls='dotted')
            axs[1].text(2147, 4, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
            axs[1].axhline(y=1, color='black', ls='dotted')

            axs[1].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=True)
            axs[1].tick_params(which="major", right=True, top=True, direction="in", length=5, labelbottom=True, labelleft=True)

            # axs[0].set_xlabel('$R\,[\mathrm{kpc}]$')

            mrand_ratio_3D_500 = -0.018998232947627983
            mrand_ratio_3D_vir = 0.04467090646625246

            x_mrand_500 = 1087

            # axs[2].plot(x_mrand_500, mrand_ratio_3D_500, '+', color='black', label='3D', ms=15)

            #axs[2].plot(x_mrand_500, mrand_ratio_r500[0], 'x', color='red', label='$x_{ew}$', ms=12)
            #axs[2].plot(x_mrand_500, mrand_ratio_r500[1], 'x', color='blue', label='$y_{ew}$', ms=12)
            #axs[2].plot(x_mrand_500, mrand_ratio_r500[2], 'x', color='green', label='$z_{ew}$', ms=12)
            #axs[2].plot(x_mrand_500, mrand_ratio_r500[3], 'x', color='pink', label='$cen_{ew}$', ms=12)

            #axs[2].plot(rlogbin_cen, mdisp_3D_ratio, color='black', label='3D', ls='dashed', marker='+')

            #axs[2].plot(x_mrand_500, mrand_ratio_r500[4], '.', color='red', label='$x_{mw}$', ms=12)
            #axs[2].plot(x_mrand_500, mrand_ratio_r500[5], '.', color='blue', label='$y_{mw}$', ms=12)
            #axs[2].plot(x_mrand_500, mrand_ratio_r500[6], '.', color='green', label='$z_{mw}$', ms=12)
            #axs[2].plot(x_mrand_500, mrand_ratio_r500[7], '.', color='pink', label='$cen_{mw}$', ms=12)

            x_mrand_vir = 2147

            # axs[2].plot(x_mrand_vir, mrand_ratio_3D_vir, '+', color='black', ms=15)  # ,label='3D'

            #axs[2].plot(x_mrand_vir, mrand_ratio_rvir[0], 'x', color='red', ms=12)  # , label='x')
            #axs[2].plot(x_mrand_vir, mrand_ratio_rvir[1], 'x', color='blue', ms=12)  # , label='y')
            #axs[2].plot(x_mrand_vir, mrand_ratio_rvir[2], 'x', color='green', ms=12)  # , label='z')
            #axs[2].plot(x_mrand_vir, mrand_ratio_rvir[3], 'x', color='pink', ms=12)  # , label='z')

            #axs[2].plot(x_mrand_vir, mrand_ratio_rvir[4], '.', color='red', ms=12)  # ,label='x')
            #axs[2].plot(x_mrand_vir, mrand_ratio_rvir[5], '.', color='blue', ms=12)  # ,label='y')
            #axs[2].plot(x_mrand_vir, mrand_ratio_rvir[6], '.', color='green', ms=12)  # ,label='z')
            #axs[2].plot(x_mrand_vir, mrand_ratio_rvir[7], '.', color='pink', ms=12)  # ,label='z')

            # plt.axvline(x=3,color='black',ls='solid')

            # axs[2].set_xticks([1087, 2147], ['$R_{500}$', '$R_{vir}$'])

            #axs[2].set_ylabel('$M_{disp}/M_{corr}$')
            #axs[2].set_xlim(200, 3000)
            # axs[2].set_xlabel('$R\,[\mathrm{kpc}]$')
            # axs[2].set_yscale('symlog',linthresh=1e-2)
            # axs[2].set_ylim(-0.1, 0.15)

            #axs[2].set_xscale('log')
            # axs[2].set_ylim(1e-3, 0.15)
            #axs[2].set_ylim(-0.09, 0.12)
            #axs[2].axvline(x=1087, color='grey', ls='dotted')
            # axs[2].text(1087, -0.05, '$R_{500}$', fontsize=14, color='grey',rotation=90)
            #axs[2].axvline(x=2147, color='grey', ls='dotted')
            # axs[2].text(2147, -0.05, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
            #axs[2].axhline(y=0, color='grey', ls='dotted')

            #axs[2].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            #axs[2].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=14, labelbottom=False, labelleft=True)

            # axs[3].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
            # axs[3].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=14, labelbottom=True, labelleft=True)

            axs[1].set_xlabel('$R[\mathrm{kpc}]$')

            plt.show()
            sys.exit()

        m_over_mcorr_2D_plot(mrot_ratio_r500,mrot_ratio_rvir,mrand_ratio_r500,mrand_ratio_rvir)

        #m_over_mtot_2D_plot()

def vel_rad_prof():
    p_rad_log = np.load("p_rad_log_l15_20b.npy")
    t_rad_log = np.load("t_rad_log_l15_20b.npy")
    ne_rad_log = np.load("ne_rad_log_l15_20b.npy")
    sigma_r_2_rad_log = np.load("sigma_r_2_rad_log_l15_20b.npy")
    sigma_t_2_rad_log = np.load("sigma_t_2_rad_log_l15_20b.npy")
    vr_rad_log = np.load("vr_rad_l15_20b.npy")
    vt_rad_log = np.load("vt_rad_log_l15_20b.npy")

    #print("vr rad log",vr_rad_log)

    def load_map(file, proj):
            h = FortranFile(file, 'r')
            nx, ny, nz = h.read_ints()

            if proj == "x":
                ncell = nz * ny
            elif proj == "y":
                ncell = nx * nz
            elif proj == "z":
                # ncell = np.uint64(nx * ny)
                ncell = nx * ny
            # print("ncell", ncell)

            map = np.zeros(ncell)

            map = ftp.f90_to_py.read_map_file(ncell, file, 0)

            if proj == "x":
                map = np.reshape(map, (nz, ny))
            elif proj == "y":
                map = np.reshape(map, (nx, nz))
            elif proj == "z":
                map = np.reshape(map, (ny, nx))

            return map

    map_vdx_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vdx_ew_Tsup7_5Mpc2.bin', 'x')

    map_vx_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_ew_Tsup7_5Mpc2.bin', 'x')

    map_vdy_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vdy_ew_Tsup7_5Mpc2.bin', 'y')

    map_vy_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_ew_Tsup7_5Mpc2.bin', 'y')

    map_vdz_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vdz_ew_Tsup7_5Mpc2.bin', 'z')

    map_vz_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_ew_Tsup7_5Mpc2.bin', 'z')

    map_vdx_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vdx_mw_Tsup7_5Mpc2.bin', 'x')

    map_vx_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_x_map_vx_mw_Tsup7_5Mpc2.bin', 'x')

    map_vdy_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vdy_mw_Tsup7_5Mpc2.bin', 'y')

    map_vy_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_y_map_vy_mw_Tsup7_5Mpc2.bin', 'y')

    map_vdz_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vdz_mw_Tsup7_5Mpc2.bin', 'z')

    map_vz_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_z_map_vz_mw_Tsup7_5Mpc2.bin', 'z')

    map_vcen_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_mw_Tsup7_5Mpc2.bin', 'z')

    map_vcen_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vz_ew_Tsup7_5Mpc2.bin', 'z')

    map_vdcen_mw = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vdz_mw_Tsup7_5Mpc2.bin', 'z')

    map_vdcen_ew = load_map('./maps/high_res/velocity/15f15_analysis/map_high_15f15_cen_map_vdz_ew_Tsup7_5Mpc2.bin', 'z')

    # print("mean vel dis y",np.mean(map_vdy))

    d = np.load("map_distances_lvl15_proj_vel.npy")

    def rad_prof_from_maps(map,d):

        n=20
        dlog=np.log10(d)
        rad_prof=np.zeros(n)

        for i in range(0,n):
            #print(i)
            #cond = np.logical_and(dlog > (i + 35) * 0.05, dlog < (i + 36) * 0.05)
            #cond = np.logical_and(dlog > (i + 92) * 0.025, dlog < (i + 93) * 0.025)
            cond = np.logical_and(dlog > (i + 17.5) * 0.1, dlog < (i + 18.5) * 0.1)

            rad_prof[i] = np.mean(map[cond])

        return rad_prof

    def vlos_in_quadrants_and_rad(map, d):

        #rvir = 2147
        #r500 = 1087
        # print("map shape",map.shape)
        x = np.linspace(-map.shape[0] / 2 + 0.5, map.shape[0] / 2 - 0.5, map.shape[0])
        y = np.linspace(-map.shape[1] / 2 + 0.5, map.shape[1] / 2 - 0.5, map.shape[1])
        X, Y = np.meshgrid(x, y)
        theta = np.arctan2(Y, X)

        cond_1 = np.logical_and(theta > 0, theta < np.pi / 4)
        cond_2 = np.logical_and(theta > np.pi / 4, theta < np.pi / 2)
        cond_3 = np.logical_and(theta > np.pi / 2, theta < 3 * np.pi / 4)
        cond_4 = np.logical_and(theta > 3 * np.pi / 4, theta < np.pi)
        cond_5 = np.logical_and(theta > -np.pi, theta < -3 * np.pi / 4)
        cond_6 = np.logical_and(theta > -3 * np.pi / 4, theta < -np.pi / 2)
        cond_7 = np.logical_and(theta > -np.pi / 2, theta < -np.pi / 4)
        cond_8 = np.logical_and(theta > -np.pi / 4, theta < 0)

        mean_v_quadrants = np.zeros(8)

        conds = [cond_1, cond_2, cond_3, cond_4, cond_5, cond_6, cond_7, cond_8]

        n = 20
        dlog = np.log10(d)
        vt = np.zeros(n)
        st = np.zeros(n)

        for h in range(0, n):
            # print(i)
            # cond = np.logical_and(dlog > (i + 35) * 0.05, dlog < (i + 36) * 0.05)
            # cond = np.logical_and(dlog > (i + 92) * 0.025, dlog < (i + 93) * 0.025)
            cond_r = np.logical_and(dlog > (h + 17.5) * 0.1, dlog < (h + 18.5) * 0.1)

            for i in range(8):
                cond_bin = np.logical_and(cond_r, conds[i])

                mean_v_quadrants[i] = np.mean(map[cond_bin])

            #print("mean v quad",mean_v_quadrants)

            mean_v_abs_diff = np.zeros(28)

            n = 0
            for i in range(0, 8):
                for j in range(0, 7 - i):
                    mean_v_abs_diff[n] = np.abs(mean_v_quadrants[i] - mean_v_quadrants[i + j + 1])
                    n += 1
            # print("mean_v_rvir_all", mean_v_rvir_quadrants)

            vt[h] = np.max(mean_v_abs_diff)
            st[h] = np.std(mean_v_abs_diff)

        #print("vt",vt)

        return vt,st


    prof_vx_ew = rad_prof_from_maps(map_vx_ew,d)

    #print("prof vx ew",prof_vx_ew)
    #sys.exit()
    prof_vdx_ew = rad_prof_from_maps(map_vdx_ew,d)
    prof_vy_ew = rad_prof_from_maps(map_vy_ew,d)
    prof_vdy_ew = rad_prof_from_maps(map_vdy_ew,d)
    prof_vz_ew = rad_prof_from_maps(map_vz_ew,d)
    prof_vdz_ew = rad_prof_from_maps(map_vdz_ew,d)
    prof_vcen_ew = rad_prof_from_maps(map_vcen_ew,d)
    prof_vdcen_ew = rad_prof_from_maps(map_vdcen_ew,d)

    prof_vx_mw = rad_prof_from_maps(map_vx_mw,d)
    prof_vdx_mw = rad_prof_from_maps(map_vdx_mw,d)
    prof_vy_mw = rad_prof_from_maps(map_vy_mw,d)
    prof_vdy_mw = rad_prof_from_maps(map_vdy_mw,d)
    prof_vz_mw = rad_prof_from_maps(map_vz_mw,d)
    prof_vdz_mw = rad_prof_from_maps(map_vdz_mw,d)
    prof_vcen_mw = rad_prof_from_maps(map_vcen_mw,d)
    prof_vdcen_mw = rad_prof_from_maps(map_vdcen_mw,d)

    vt_x_ew, st_x_ew = vlos_in_quadrants_and_rad(map_vx_ew,d)
    #sys.exit()
    vt_y_ew, st_y_ew = vlos_in_quadrants_and_rad(map_vy_ew,d)
    vt_z_ew, st_z_ew = vlos_in_quadrants_and_rad(map_vz_ew,d)
    vt_cen_ew, st_cen_ew = vlos_in_quadrants_and_rad(map_vcen_ew,d)

    vt_x_mw, st_x_mw = vlos_in_quadrants_and_rad(map_vx_mw,d)
    vt_y_mw, st_y_mw = vlos_in_quadrants_and_rad(map_vy_mw,d)
    vt_z_mw, st_z_mw = vlos_in_quadrants_and_rad(map_vz_mw,d)
    vt_cen_mw, st_cen_mw = vlos_in_quadrants_and_rad(map_vcen_mw,d)


    #rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
    #rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(77)])
    rlogbin_cen = np.array([10 ** ((18 + i) * 0.1) for i in range(20)])

    fig,ax = plt.subplots(4,1,figsize=(4,16),sharex=True)

    plt.sca(ax[0])

    #plt.plot(rlogbin_cen, prof_vx_ew, marker="x", ls="dashed", color='red',label="$x_{ew}$")
    #plt.plot(rlogbin_cen, prof_vy_ew, marker="x", ls="dashed", color='blue',label="$y_{ew}$")
    #plt.plot(rlogbin_cen, prof_vz_ew, marker="x", ls="dashed", color='green',label="$z_{ew}$")
    #plt.plot(rlogbin_cen, prof_vcen_ew, marker="x", ls="dashed", color='pink',label="$cen_{ew}$")

    plt.plot(rlogbin_cen, vr_rad_log, marker="+", ls="solid", color='black', label='3D')

    #plt.plot(rlogbin_cen, prof_vx_mw, marker=".", ls="dotted", color='red',label="$x_{mw}$")
    #plt.plot(rlogbin_cen, prof_vy_mw, marker=".", ls="dotted", color='blue',label="$y_{mw}$")
    #plt.plot(rlogbin_cen, prof_vz_mw, marker=".", ls="dotted", color='green',label="$z_{mw}$")
    #plt.plot(rlogbin_cen, prof_vcen_mw, marker=".", ls="dotted", color='pink',label="$cen_{mw}$")

    plt.xscale('log')
    #plt.xlabel('$R\,[\mathrm{kpc}]$')
    #plt.xticks([])
    #plt.xaxis("off")
    plt.ylabel("$v_{r}~[\mathrm{km~s^{-1}}]$")
    plt.axvline(x=1087, color='grey', ls='dotted')
    #plt.text(1087, -192, '$R_{500}$', fontsize=14, color='grey', rotation=90)
    plt.axvline(x=2147, color='grey', ls='dotted')
    #plt.text(2147, -192, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
    #plt.title('Radial velocity')
    #plt.legend(loc='lower left',ncols=2)
    plt.ylim(-220,40)

    ax[0].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    ax[0].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    ax[0].set_xticks([])

    plt.sca(ax[1])

    #plt.plot(rlogbin_cen, vt_x_ew, marker="x", ls="dashed", color='red',label="$x_{ew}$")
    #plt.plot(rlogbin_cen, vt_y_ew, marker="x", ls="dashed", color='blue',label="$y_{ew}$")
    #plt.plot(rlogbin_cen, vt_z_ew, marker="x", ls="dashed", color='green',label="$z_{ew}$")
    #plt.plot(rlogbin_cen, vt_cen_ew, marker="x", ls="dashed", color='pink',label="$cen_{ew}$")

    plt.plot(rlogbin_cen,10**vt_rad_log,marker="+",ls="solid",color='black')

    #plt.plot(rlogbin_cen, vt_x_mw, marker=".", ls="dotted", color='red',label="$x_{mw}$")
    #plt.plot(rlogbin_cen, vt_y_mw, marker=".", ls="dotted", color='blue',label="$y_{mw}$")
    #plt.plot(rlogbin_cen, vt_z_mw, marker=".", ls="dotted", color='green',label="$z_{mw}$")
    #plt.plot(rlogbin_cen, vt_cen_mw, marker=".", ls="dotted", color='pink',label="$cen_{mw}$")

    plt.xscale('log')
    #plt.xlabel('$R\,[\mathrm{kpc}]$')
    plt.xticks([])
    #plt.xaxis("off")
    plt.ylabel("$v_{t}~[\mathrm{km~s^{-1}}]$")
    plt.axvline(x=1087, color='grey', ls='dotted')
    #plt.text(1087, 235, '$R_{500}$', fontsize=14, color='grey', rotation=90)
    plt.axvline(x=2147, color='grey', ls='dotted')
    #plt.text(2147, 235, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
    plt.ylim(230, 360)
    #plt.title('Tangential velocity')

    ax[1].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    ax[1].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    ax[1].set_xticks([])

    plt.sca(ax[2])

    #plt.plot(rlogbin_cen, prof_vdx_ew, marker="x", ls="dashed", color='red', label="$x_{ew}$")
    #plt.plot(rlogbin_cen, prof_vdy_ew, marker="x", ls="dashed", color='blue', label="$y_{ew}$")
    #plt.plot(rlogbin_cen, prof_vdz_ew, marker="x", ls="dashed", color='green', label="$z_{ew}$")
    #plt.plot(rlogbin_cen, prof_vdcen_ew, marker="x", ls="dashed", color='pink', label="$cen_{ew}$")

    plt.plot(rlogbin_cen,np.sqrt(10**sigma_r_2_rad_log),marker="+",ls="solid",color='black')

    #plt.plot(rlogbin_cen, prof_vdx_mw, marker=".", ls="dotted", color='red', label="$x_{mw}$")
    #plt.plot(rlogbin_cen, prof_vdy_mw, marker=".", ls="dotted", color='blue', label="$y_{mw}$")
    #plt.plot(rlogbin_cen, prof_vdz_mw, marker=".", ls="dotted", color='green', label="$z_{mw}$")
    #plt.plot(rlogbin_cen, prof_vdcen_mw, marker=".", ls="dotted", color='pink', label="$cen_{mw}$")

    plt.xscale('log')
    #plt.xlabel('$R\,[\mathrm{kpc}]$')
    plt.xticks([])
    plt.ylabel("$\sigma_{r}~[\mathrm{km~s^{-1}}]$")
    plt.axvline(x=1087, color='grey', ls='dotted')
    #plt.text(1087, 200, '$R_{500}$', fontsize=14, color='grey', rotation=90)
    plt.axvline(x=2147, color='grey', ls='dotted')
    #plt.text(2147, 200, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
    plt.ylim(180, 620)
    #plt.xaxis('off')
    #plt.title('Radial velocity dispersion')

    ax[2].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    ax[2].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    ax[2].set_xticks([])

    plt.sca(ax[3])

    #plt.plot(rlogbin_cen, st_x_ew, marker="x", ls="dashed", color='red', label="$x_{ew}$")
    #plt.plot(rlogbin_cen, st_y_ew, marker="x", ls="dashed", color='blue', label="$y_{ew}$")
    #plt.plot(rlogbin_cen, st_z_ew, marker="x", ls="dashed", color='green', label="$z_{ew}$")
    #plt.plot(rlogbin_cen, st_cen_ew, marker="x", ls="dashed", color='pink', label="$cen_{ew}$")

    plt.plot(rlogbin_cen,np.sqrt(10**sigma_t_2_rad_log),marker="+",ls="solid",color='black',label='3D')

    #plt.plot(rlogbin_cen, st_x_mw, marker=".", ls="dotted", color='red', label="$x_{mw}$")
    #plt.plot(rlogbin_cen, st_y_mw, marker=".", ls="dotted", color='blue', label="$y_{mw}$")
    #plt.plot(rlogbin_cen, st_z_mw, marker=".", ls="dotted", color='green', label="$z_{mw}$")
    #plt.plot(rlogbin_cen, st_cen_mw, marker=".", ls="dotted", color='pink', label="$cen_{mw}$")

    plt.xscale('log')
    plt.xlabel('$R\,[\mathrm{kpc}]$')
    plt.ylabel("$\sigma_{t}~[\mathrm{km~s^{-1}}]$")
    plt.axvline(x=1087, color='grey', ls='dotted')
    plt.text(1087, 100, '$R_{500}$', fontsize=14, color='grey', rotation=90)
    plt.axvline(x=2147, color='grey', ls='dotted')
    plt.text(2147, 100, '$R_{vir}$', fontsize=14, color='grey', rotation=90)
    plt.ylim(70,220)
    #plt.legend(loc='upper left',ncols=2,fontsize=14)
    #plt.title('Tangential velocity dispersion')

    ax[3].tick_params(which="minor", right=True, top=True, direction="in", length=3, labelbottom=False)
    ax[3].tick_params(which="major", right=True, top=True, direction="in", length=5, labelsize=16, labelbottom=True,labelleft=True)
    #ax[3].set_xticks([])

    plt.subplots_adjust(wspace=0, hspace=0)

    plt.show()

def estimate_overdensity():

    fileh = "./virgo_xyz_files/virgo_xyz_hydro_l21.dat"
    print('hydro')
    #print(file)
    h = FortranFile(fileh, 'r')

    ncell = h.read_ints()
    print("ncell", ncell)

    print("ne")
    n_e = []
    n_e = h.read_reals()

    print("t")
    t = []
    t = h.read_reals()

    print("p")
    p = []
    p = h.read_reals()

    print("x")
    xb = []
    xb = h.read_reals()

    print('y')
    yb = []
    yb = h.read_reals()

    print("z")
    zb = []
    zb = h.read_reals()

    print("vx")
    vx = []
    vx = h.read_reals()

    print("vy")
    vy = []
    vy = h.read_reals()

    print("vz")
    vz = []
    vz = h.read_reals()

    print("m")
    mb = []
    mb = h.read_reals()

    print("lvl")
    lvl = []
    lvl = h.read_reals()

    m_cumul_ba = np.zeros(21)

    x_cen = 0.48461068
    y_cen = 0.50809848
    z_cen = 0.49687076

    x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
    y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
    z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

    rb = np.sqrt((xb - x_cen) ** 2 + (yb - y_cen) ** 2 + (zb - z_cen) ** 2)


    print('dm')
    filedm = "./virgo_xyz_files/virgo_xyz_dm_high_res.dat"
    d = FortranFile(filedm, 'r')

    ncell = d.read_ints()

    xdm, ydm, zdm, mdm, vx, vy, vz = ftp.f90_to_py.read_dm(ncell,filedm)

    rdm = np.sqrt(xdm**2+ydm**2+zdm**2)

    #plt.hist(rdm)
    #plt.show()
    #sys.exit()

    print("dm data read")

    r=np.array([500,505,510,515,520])

    for i in r :
        print("r",i)
        #sys.exit()
        m = np.sum(mb[rb<i])+np.sum(mdm[rdm<i])
        den = (3 * m_sun * m) / (4 * np.pi * (i * pc * 1E3) ** 3)
        overden = den / (rho_c * (omega_c / omega_m))
        print("r (kpc)",i,"delta",overden,"m",m/1E14)

    sys.exit()

def Mach_and_Pnt(dim):

    def load_map(file,proj):

        h = FortranFile(file, 'r')
        nx,ny,nz = h.read_ints()
        cen_x,cen_y,cen_z = h.read_reals()
        #print("nx,ny,nz",nx,ny,nz)
        #print("cen_x,cen_y,cen_z",cen_x,cen_y,cen_z)
        #sys.exit()
        #ncell = 0
        #print(ncell.dtype)
        #sys.exit()
        #ncell = np
        #sys.exit()
        if proj == "x":
            ncell = nz * ny
        elif proj == "y":
            ncell = nx * nz
        elif proj == "z":
            #ncell = np.uint64(nx * ny)
            ncell = nx * ny
        #print("ncell",ncell)

        map = np.zeros(ncell)

        map = ftp.f90_to_py.read_map_file(ncell, file,0)

        if proj == "x":
            map = np.reshape(map, (nz, ny))
            #map2 = np.reshape(map2, (nz, ny))
            #map3 = np.reshape(map3, (nz, ny))
            nl = nx
        elif proj == "y":
            map = np.reshape(map, (nx, nz))
            #map2 = np.reshape(map2, (nx, nz))
            #map3 = np.reshape(map3, (nx, nz))
            nl = ny
        elif proj == "z":
            map = np.reshape(map, (ny, nx))
            #map2 = np.reshape(map2, (ny, nx))
            #map3 = np.reshape(map3, (ny, nx))
            nl = nz

        return map

    def m_and_pnt(v,vd,T,dim):
        if dim==2:
            #print('T',T)
            T=(T * 1.6e-16) / kb #transform T from Kev to K
            vd*=np.sqrt(3) #isotropy hypothesis (Biffi 16, Eckert 19)
        if dim==1:
            vd *= np.sqrt(3)
        #print('T',T)
        gamma=5/3
        c_s = np.sqrt((gamma*kb*T)/(mu*mp)) #sound speed in m/s
        c_s/=1e3 #sound speed in km/s
        mach=np.sqrt(vd**2+v**2)/c_s
        #mach2=vd/c_s
        #print("mach",mach,'mach2',mach2)
        alpha = mach**2/(3/gamma + mach**2)
        print("vrestframe=", "{:.2e}".format(v),"sigma=", "{:.2e}".format(vd), "T=","{:.3e}".format(T),"c_s=","{:.3e}".format(c_s), "M=","{:.2e}".format(mach), 'alpha=', "{:.2e}".format(alpha))
        return c_s,mach,alpha


    if dim==2:

        d5 = np.load('map_distances_lvl15_proj_vel_5Mpc_222.npy')
        d10 = np.load('map_distances_lvl15_10Mpc_444.npy')  # Be careful it is in log scale, and not d5
        d10 = 10 ** d10
        # print(np.shape(T_x))
        # print(np.shape(d5), np.max(d5))
        # print(np.shape(d10),np.max(d10))

        r500 = 1087
        rvir = 2147

        def calculation_from_map_vir(proj,weight):
            print('')
            file_root='./maps/high_res/velocity/15f15_analysis/map_high_15f15_'+str(proj)
            file_t=file_root+'_map_T_sl_Tsup7_5Mpc2.bin'
            if proj=='cen':
                proj2="z"
            else :
                proj2=proj
            file_v=file_root+'_map_v'+str(proj2)+'_'+str(weight)+'_Tsup7_5Mpc2.bin'
            file_vd=file_root+'_map_vd'+str(proj2)+'_'+str(weight)+'_Tsup7_5Mpc2.bin'

            T=load_map(file_t,proj2)
            v=load_map(file_v,proj2)
            vd=load_map(file_vd,proj2)

            T_500 = np.nanmean(T[d5 < r500])
            T_vir = np.nanmean(T[d5 < rvir])
            vd_500 = np.nanmean(vd[d5 < r500])
            vd_vir = np.nanmean(vd[d5 < rvir])
            v_500 = np.nanmean(v[d5 < r500])
            v_vir = np.nanmean(v[d5 < rvir])

            v_std_500 = np.nanstd(v[d5 < r500])
            v_std_vir = np.nanstd(v[d5 < rvir])


            #text="2D "+str(proj)+" r500 "+str(weight)
            #print(text)
            #mach_500, alpha_500 = m_and_pnt(v_500,vd_500, T_500, 2)

            #text="2D "+str(proj)+" r500 "+str(weight) + " v_std"
            #print(text)
            #mach_500, alpha_500 = m_and_pnt(v_500,v_std_500, T_500, 2)


            text = "2D " + str(proj) + " rvir " + str(weight)
            print(text)
            c_s, mach_vir_vd, alpha_vir_vd = m_and_pnt(v_vir,vd_vir, T_vir, 2)

            text = "2D " + str(proj) + " rvir " + str(weight) + " v_std"
            print(text)
            c_s, mach_vir_vstd, alpha_vir_vstd = m_and_pnt(v_vir,v_std_vir, T_vir, 2)

            return T_vir, c_s, v_vir, vd_vir, v_std_vir, mach_vir_vd,mach_vir_vstd, alpha_vir_vd, alpha_vir_vstd

        def calculation_from_map_500(proj,weight):
            print('')
            file_root='./maps/high_res/velocity/15f15_analysis/map_high_15f15_'+str(proj)
            file_t=file_root+'_map_T_sl_Tsup7_5Mpc2.bin'
            if proj=='cen':
                proj2="z"
            else :
                proj2=proj
            file_v=file_root+'_map_v'+str(proj2)+'_'+str(weight)+'_Tsup7_5Mpc2.bin'
            file_vd=file_root+'_map_vd'+str(proj2)+'_'+str(weight)+'_Tsup7_5Mpc2.bin'

            T=load_map(file_t,proj2)
            v=load_map(file_v,proj2)
            vd=load_map(file_vd,proj2)

            T_500 = np.nanmean(T[d5 < r500])
            T_vir = np.nanmean(T[d5 < rvir])
            vd_500 = np.nanmean(vd[d5 < r500])
            vd_vir = np.nanmean(vd[d5 < rvir])
            v_500 = np.nanmean(v[d5 < r500])
            v_vir = np.nanmean(v[d5 < rvir])

            v_std_500 = np.nanstd(v[d5 < r500])
            v_std_vir = np.nanstd(v[d5 < rvir])


            #text="2D "+str(proj)+" r500 "+str(weight)
            #print(text)
            #mach_500, alpha_500 = m_and_pnt(v_500,vd_500, T_500, 2)

            #text="2D "+str(proj)+" r500 "+str(weight) + " v_std"
            #print(text)
            #mach_500, alpha_500 = m_and_pnt(v_500,v_std_500, T_500, 2)


            text = "2D " + str(proj) + " r500 " + str(weight)
            print(text)
            c_s, mach_500_vd, alpha_500_vd = m_and_pnt(v_500,vd_500, T_500, 2)

            text = "2D " + str(proj) + " r500 " + str(weight) + " v_std"
            print(text)
            c_s, mach_500_vstd, alpha_500_vstd = m_and_pnt(v_500,v_std_500, T_500, 2)

            return T_500, c_s, v_500, vd_500, v_std_500, mach_500_vd,mach_500_vstd, alpha_500_vd, alpha_500_vstd

        data_2D=np.zeros((9,12))
        rad=2147
        if rad==2147:

            data_2D[:,0] = calculation_from_map_vir('x',"ew")
            data_2D[:,1] = calculation_from_map_vir('x',"mw")

            data_2D[:,2] = calculation_from_map_vir('y', "ew")
            data_2D[:,3] = calculation_from_map_vir('y', "mw")

            data_2D[:,4] = calculation_from_map_vir('z', "ew")
            data_2D[:,5] = calculation_from_map_vir('z', "mw")

            data_2D[:,6] = calculation_from_map_vir('cen', "ew")
            data_2D[:,7] = calculation_from_map_vir('cen', "mw")

        else:
            data_2D[:,0] = calculation_from_map_500('x',"ew")
            data_2D[:,1] = calculation_from_map_500('x',"mw")

            data_2D[:,2] = calculation_from_map_500('y', "ew")
            data_2D[:,3] = calculation_from_map_500('y', "mw")

            data_2D[:,4] = calculation_from_map_500('z', "ew")
            data_2D[:,5] = calculation_from_map_500('z', "mw")

            data_2D[:,6] = calculation_from_map_500('cen', "ew")
            data_2D[:,7] = calculation_from_map_500('cen', "mw")



        list=['norm','x','y','z']
        j=8
        for i in list:
            dim=1
            #print(i)
            text="3D "+i
            print(text)
            file="3D_"+i+"_v_vd_T_in_vir_and_500.npy"
            v_vir,v_500,vd_vir,vd_500,T_vir,T_500=np.load(file)
            print("R500")
            cs_3D_500, mach_3D_500, alpha_3D_500 = m_and_pnt(v_500,vd_500, T_500, dim)
            print("Rvir")
            cs_3D_vir, mach_3D_vir, alpha_3D_vir = m_and_pnt(v_vir,vd_vir, T_vir,dim)
            #print('j',j)
            if rad==2147:
                data_2D[:, j] = [T_vir, cs_3D_vir, v_vir, vd_vir, np.nan, mach_3D_vir,np.nan, alpha_3D_vir,np.nan]
            else:
                data_2D[:, j] = [T_500, cs_3D_500, v_500, vd_500, np.nan, mach_3D_500, np.nan, alpha_3D_500, np.nan]
            j=j+1

        f,a=plt.subplots(4,1,figsize=(4,8), constrained_layout=True)
        n=[1,2,3,7]
        j=0
        label=[r"$c_s~\mathrm{[km~s^{-1}]}$",r"$v~\mathrm{[km~s^{-1}]}$",r"$\sigma~\mathrm{[km~s^{-1}]}$",r"$\frac{P_{nt}}{P_{tot}}$"]
        for i in n:
            plt.sca(a[j])
            plt.ylabel(label[j])
            colors=['red','red','blue','blue','green','green','pink','pink','black',"red","blue","green"]
            marker_all=["+","s","+","s","+","s","+","s",".",".",".","."]
            marker_v_std=["x","d","x","d","x","d","x","d","","","",""]



            #markers=['+','x','s','d',]
            for k in range(12):
                plt.scatter(data_2D[5,k],data_2D[i,k],c=colors[k],marker=marker_all[k],alpha=0.5,label=marker_all[k],s=32)
                if i<3:
                    plt.scatter(data_2D[6, k], data_2D[i,k], c=colors[k],marker=marker_v_std[k],alpha=0.5,label=marker_v_std[k],s=32)
                else:
                    plt.scatter(data_2D[6, k], data_2D[i+1, k], c=colors[k], marker=marker_v_std[k],alpha=0.5,label=marker_v_std[k],s=32)

                #    plt.scatter(data_2D[5, k], data_2D[i+1, k], c=colors[k], marker=marker_all[k])
                #    plt.scatter(data_2D[6, k], data_2D[i+1, k], c=colors[k], marker=marker_v_std[k])

            plt.xlim([0.18,0.55])
            if j==2:
                plt.ylim([90,350])
            elif j==3:
                    plt.ylim([0,0.15])

            j=j+1

            if i!=7:
                plt.xticks([])
            else:
                plt.xlabel(r"$M_{3D}$")

        if rad==2147:
            plt.suptitle("$R_{vir}$")
        elif rad==1087:
            plt.suptitle("$R_{500}$")


        #plt.legend()
        plt.show()

        sys.exit()

    if dim==3 :
        def hydro(file, t_cut, mean_med, log_before, n):
            print('hydro')
            print(file)
            h = FortranFile(file, 'r')

            ncell = h.read_ints()
            print("ncell", ncell)

            print("ne")
            n_e = []
            n_e = h.read_reals()

            print("t")
            t = []
            t = h.read_reals()

            print("p")
            p = []
            p = h.read_reals()

            print("x")
            x = []
            x = h.read_reals()

            print('y')
            y = []
            y = h.read_reals()

            print("z")
            z = []
            z = h.read_reals()

            print("vx")
            vx = []
            vx = h.read_reals()

            print("vy")
            vy = []
            vy = h.read_reals()

            print("vz")
            vz = []
            vz = h.read_reals()

            print("m")
            m = []
            m = h.read_reals()

            print("lvl")
            lvl = []
            lvl = h.read_reals()

            m_cumul_ba = np.zeros(21)

            x_cen = 0.48461068
            y_cen = 0.50809848
            z_cen = 0.49687076

            x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
            y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
            z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

            #print('test')

            # @jit(nopython=True)
            def change_units(x, y, z, p, n_e, t, m, vx, vy, vz, lvl, t_cut):
                #print('in')
                x_cen = 0.48461068
                y_cen = 0.50809848
                z_cen = 0.49687076

                x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
                y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
                z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

                # print("x_cen", x_cen, "y_cen", y_cen, "z_cen", z_cen)

                x -= x_cen
                y -= y_cen
                z -= z_cen

                r = np.sqrt(x ** 2 + y ** 2 + z ** 2)
                # r=np.array(r)

                vx_virgo = -509.1301
                vy_virgo = 228.9488
                vz_virgo = -131.9249

                vz -= vz_virgo
                vy -= vy_virgo
                vx -= vx_virgo

                # n_e *= 1E6 / 0.864
                n_e /= 0.864  # np/ne = 0.864
                # plt.hist(np.log10(n_e),bins=100,range=[-3,7])
                # plt.show()
                # sys.exit()

                p /= 10
                # print("max p in km m s units", np.max(p))
                p /= 1.602 * 10 ** (-10)
                p *= (0.76 / 0.864)
                # print("max p in Kev",np.max(p))
                #sys.exit()
                # print("P",p)
                print("nb part", len(n_e))

                ###define velocity in spherical coordinates and velocity dispersion

                rho = np.sqrt(x ** 2 + y ** 2)

                vr = (x * vx + y * vy + z * vz) / r
                vtheta = (z * (vx * x + vy * y) - (x ** 2 + y ** 2) * vz) / (r * rho)
                vphi = (x * vy - y * vx) / rho

                # m_no_cut = m
                # r_no_cut = r

                if t_cut == 1:
                    rnocut = r
                    mnocut = m
                    lim = 0
                    cond = np.logical_and(t > 1E5, n_e > 0)  # Standard condition
                    # cond = np.logical_and(t > 1E5,np.logical_and(n_e > 0,np.logical_and(x>x_cen,np.logical_and(y>y_cen,z>z_cen)))) #Conditions for sectors study
                    n_e2 = n_e[cond]
                    t = t[cond]
                    x = x[cond]
                    y = y[cond]
                    z = z[cond]
                    p = p[cond]
                    r = r[cond]
                    m = m[cond]
                    t = t[cond]
                    vx = vx[cond]
                    vy = vy[cond]
                    vz = vz[cond]
                    lvl = lvl[cond]
                    n_e = n_e2
                    # t = t_2
                    # x = x_2
                    # y = y_2
                    # z = z_2

                if t_cut == 2:
                    rnocut = r
                    mnocut = m
                    cond = np.logical_and(t > 1E7, n_e > 0)
                    n_e2 = n_e[cond]
                    p = p[cond]
                    r = r[cond]
                    m = m[cond]
                    t = t[cond]
                    vr = vr[cond]
                    vtheta = vtheta[cond]
                    vphi = vphi[cond]
                    vx = vx[cond]
                    vy = vy[cond]
                    vz = vz[cond]
                    n_e = n_e2

                print("nb part after cut", len(n_e))

                # t *= kb / 1.602e-16

                k = t / n_e ** (2 / 3)

                rho = n_e * me * 1e3

                # vx*=1e6
                # vy*=1e6
                # vz*=1e6 #comprendre pk j'avais mis *1e6 et pk ça a l'air de marcher (plutôt que *1e5 qui permettrait de passer de km/s à cm/s)

                rlog = np.log10(r)
                rlognocut = np.log10(rnocut)

                if log_before == 1:
                    p = np.log10(p)
                    t = np.log10(t)
                    n_e = np.log10(n_e)
                    k = np.log10(k)

                ####test for validity of method : log before sum ok ?

                # np.save("p_test.npy",p)
                # np.save("m_test.npy",m)
                # np.save("ne_test.npy",n_e)

                ####

                vxm=np.mean(vx)
                vym=np.mean(vy)
                vzm=np.mean(vz)

                vm=np.sqrt(vxm**2+vym**2+vzm**2)
                v=np.sqrt(vx**2+vy**2+vz**2)



                vx_rvir = np.average(vx[r < 2147],weights=m[r<2147])
                vx_r500 = np.average(vx[r < 1087],weights=m[r<1087])
                vy_rvir = np.average(vy[r < 2147],weights=m[r<2147])
                vy_r500 = np.average(vy[r < 1087],weights=m[r<1087])
                vz_rvir = np.average(vz[r < 2147],weights=m[r<2147])
                vz_r500 = np.average(vz[r < 1087],weights=m[r<1087])
                v_rvir = np.sqrt(vx_rvir**2+vy_rvir**2+vz_rvir**2)
                v_r500 = np.sqrt(vx_r500**2+vy_r500**2+vz_r500**2)


                #vd_rvir=DescrStatsW(v[r < 2147], weights=m[r<2147]).std

                #print("vdvir",vd_rvir)
                #vd_rvir = np.std(v[r < 2147])
                #print("vdvir",vd_rvir)
                #sys.exit()
                #vd_r500 = DescrStatsW(v[r < 1087], weights=m[r<1087]).std
                vdx_r500 = DescrStatsW(vx[r < 1087], weights=m[r<1087]).std
                vdy_r500 = DescrStatsW(vy[r < 1087], weights=m[r<1087]).std
                vdz_r500 = DescrStatsW(vz[r < 1087], weights=m[r<1087]).std
                vd_r500 = np.sqrt((vdx_r500 ** 2 + vdy_r500 ** 2 + vdz_r500 ** 2) / 3)
                vdx_rvir = DescrStatsW(vx[r < 2147], weights=m[r<2147]).std
                vdy_rvir = DescrStatsW(vy[r < 2147], weights=m[r<2147]).std
                vdz_rvir = DescrStatsW(vz[r < 2147], weights=m[r<2147]).std
                vd_rvir = np.sqrt((vdx_rvir ** 2 + vdy_rvir ** 2 + vdz_rvir ** 2) / 3)
                print("sigmas in R500 :norm",vd_r500,"x",vdx_r500,"y",vdy_r500,"z",vdz_r500,"3D from comps:",np.sqrt(vdx_r500**2+vdy_r500**2+vdz_r500**2),"1D from comps:",np.sqrt((vdx_r500**2+vdy_r500**2+vdz_r500**2)/3))
                #print("3D in R500: sigma_vnorm=",vd_r500,"sigma_vx",np.std(vx[r<1087]),'sigma_vy',np.std(vy[r<1087]),'sgima_vz',np.std(vz[r<1087]))
                #sys.exit()

                T_rvir = np.average(t[r<2147],weights=m[r<2147])
                T_r500 = np.average(t[r<1087],weights=m[r<1087])

                print("tvir",T_rvir)
                print("t500",T_r500)
                #sys.exit()

                data = [v_rvir,v_r500,vd_rvir,vd_r500,T_rvir,T_r500]

                print('data vnorm',data)

                np.save("3D_norm_v_vd_T_in_vir_and_500",data)

                data = [vx_rvir, vx_r500, vdx_rvir, vdx_r500, T_rvir, T_r500]

                print('data vx', data)

                np.save("3D_x_v_vd_T_in_vir_and_500", data)

                data = [vy_rvir, vy_r500, vdy_rvir, vdy_r500, T_rvir, T_r500]

                print('data vy', data)

                np.save("3D_y_v_vd_T_in_vir_and_500", data)

                data = [vz_rvir, vz_r500, vdz_rvir, vdz_r500, T_rvir, T_r500]

                print('data vz', data)

                np.save("3D_z_v_vd_T_in_vir_and_500", data)

                print('data saved')
                sys.exit()

                return x, y, z, p, n_e, t, m, rlog, k, rho, vx, vy, vz, lvl, vr, vtheta, vphi, rlognocut, mnocut

            # start=time.time()
            x, y, z, p, n_e, t, m, rlog, k, rho, vx, vy, vz, lvl, vr, vtheta, vphi, rlognocut, mnocut = change_units(x, y, z, p, n_e, t, m, vx, vy, vz, lvl, 2)

            print("unit change done")  # , plotting histogram")



            def normal_scale():
                for i in range(400):
                    print(i)
                    cond = np.logical_and(r > i * 10, r < (i + 1) * 10)
                    t_sum = t[cond]
                    m_sum = m[cond]
                    if np.sum(m_sum) > 0:
                        t_rad[i] = np.sum(t_sum * m_sum) / np.sum(m_sum)
                    else:
                        t_rad[i] = np.nan
                    ne_rad[i] = np.median(n_e[cond])
                    p_rad[i] = np.median(p[cond])
                    # m_rad[i]=np.sum(m_sum)
                    m_rad[i] = np.sum(m_no_cut[np.logical_and(r_no_cut > i * 10, r_no_cut < (i + 1) * 10)])
                    n_rad[i] = len(m_sum)
                    # print(n_rad)
                    # nb=int(n_rad[i]*0.5)
                    # print("nb",nb)
                    # med=np.zeros(100)
                    # if(nb>1):
                    #    for j in range(100):
                    #        #print(j)
                    #        med[j]=np.median(resample(n_e[cond],n_samples=nb))
                    #
                    #        ne_rad_std[i]=np.std(med)
                    #    else:
                    #        ne_rad_std[i]=0

            # @jit(nopython=True)
            def log_scale(n):
                x_cen = 0.48461068
                y_cen = 0.50809848
                z_cen = 0.49687076
                x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
                y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
                z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

                # n = 40 #modif pr secteurs :77, 40 avant (pour 40 bins de 0.05)

                p_rad_log = np.zeros(n)
                t_rad_log = np.zeros(n)
                ne_rad_log = np.zeros(n)
                n_log = np.zeros(n)
                m_rad_log = np.zeros(n)
                err_p = np.zeros(n)
                err_ne = np.zeros(n)
                err_t = np.zeros(n)

                p_turb = np.zeros(n)
                err_pturb = np.zeros(n)

                k_rad_log = np.zeros(n)
                err_k = np.zeros(n)

                vt_rad_log = np.zeros(n)
                vr_rad_log = np.zeros(n)
                sigma_r_2_rad_log = np.zeros(n)
                sigma_t_2_rad_log = np.zeros(n)

                print("med_mean=", mean_med)

                ####test for validity of method : log before sum ok ?

                # p_test = np.load("p_test.npy")
                # m_test = np.load("m_test.npy")
                # n_e_test = np.load("ne_test.npy")

                # p_rad_test = np.zeros(n)
                # ne_rad_test = np.zeros(n)

                ####

                # m_cumul_ba=np.zeros(40)

                ###### modif pour secteurs:
                # n = 77
                rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])
                rlogbin = np.array([10 ** ((35 + i) * 0.05) for i in range(n)])

                for i in range(0, n):
                    print(i)

                    # cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
                    # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
                    # cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))

                    # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y > y_cen,z > z_cen)))) #Sector 8 = Spherical Collapse
                    # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x < x_cen,np.logical_and(y < y_cen,z < z_cen))))  # Sector 1 = Relaxed
                    # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y < y_cen, z < z_cen))))  # Sector 5 = Filament

                    # cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)
                    cond = np.logical_and(rlog > (i + 17.5) * 0.1, rlog < (i + 18.5) * 0.1)

                    m_sum_log = m[cond]
                    m_rad_log[i] = m_sum_log.sum()
                    n_log[i] = len(m[cond])
                    # rlim = 10 ** ((35.5 + i) * 0.05)
                    # print(i, 'rlim ', rlim)
                    # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
                    # m_cumul_ba[i] = np.sum(m[r < rlim])

                    # print('test')
                    if mean_med == 1:
                        # print('test 1')
                        p_sum_log = p[cond]
                        ne_sum_log = n_e[cond]
                        t_sum_log = t[cond]
                        k_sum_log = k[cond]

                        # print('test 1.5')
                        # print("msumlog",m_sum_log)
                        # print("psumlog",p_sum_log)
                        p_rad_log[i] = np.sum(p_sum_log * m_sum_log) / np.sum(m_sum_log)
                        # print('test 2')
                        ne_rad_log[i] = np.sum(ne_sum_log * m_sum_log) / np.sum(m_sum_log)
                        # print('test 3')
                        t_rad_log[i] = np.sum(t_sum_log * m_sum_log) / np.sum(m_sum_log)
                        # print('test 4')
                        err_ne[i] = np.sqrt(np.sum(m_sum_log * (ne_sum_log - ne_rad_log[i]) ** 2) / np.sum(m_sum_log))
                        err_t[i] = np.sqrt(np.sum(m_sum_log * (t_sum_log - t_rad_log[i]) ** 2) / np.sum(m_sum_log))
                        err_p[i] = np.sqrt(np.sum(m_sum_log * (p_sum_log - p_rad_log[i]) ** 2) / np.sum(m_sum_log))

                        k_rad_log[i] = np.sum(k_sum_log * m_sum_log) / np.sum(m_sum_log)
                        err_k[i] = np.sqrt(np.sum(m_sum_log * (k_sum_log - k_rad_log[i]) ** 2) / np.sum(m_sum_log))

                        # used in paper 1 to estimate p_nth

                        vxmean = np.mean(vx[cond])
                        vymean = np.mean(vy[cond])
                        vzmean = np.mean(vz[cond])
                        sigmax = np.sum(m_sum_log * (vx[cond] - vxmean) ** 2) / np.sum(m_sum_log)
                        sigmay = np.sum(m_sum_log * (vy[cond] - vymean) ** 2) / np.sum(m_sum_log)
                        sigmaz = np.sum(m_sum_log * (vz[cond] - vzmean) ** 2) / np.sum(m_sum_log)
                        sigmatot = sigmax + sigmay + sigmaz
                        rhomean = np.sum(rho[cond] * m_sum_log) / np.sum(m_sum_log)

                        p_turb[i] = rhomean * sigmatot

                        ##### paper 4 ####

                        vt = np.sqrt(vtheta ** 2 + vphi ** 2)

                        vt_rad_log[i] = np.sum(vt[cond] * m_sum_log) / np.sum(m_sum_log)
                        vt_rad_log_2 = np.sum(vt[cond] ** 2 * m_sum_log) / np.sum(m_sum_log)
                        sigma_t_2_rad_log[i] = vt_rad_log_2 - vt_rad_log[i] ** 2

                        vr_rad_log[i] = np.sum(vr[cond] * m_sum_log) / np.sum(m_sum_log)
                        vr_rad_log_2 = np.sum(vr[cond] ** 2 * m_sum_log) / np.sum(m_sum_log)
                        sigma_r_2_rad_log[i] = vr_rad_log_2 - vr_rad_log[i] ** 2

                        vtheta_rad_log = np.sum(vtheta[cond] * m_sum_log) / np.sum(m_sum_log)
                        vtheta_rad_log_2 = np.sum(vtheta[cond] ** 2 * m_sum_log) / np.sum(m_sum_log)
                        sigma_theta_2_rad_log = vtheta_rad_log_2 - vtheta_rad_log ** 2

                        vphi_rad_log = np.sum(vphi[cond] * m_sum_log) / np.sum(m_sum_log)
                        vphi_rad_log_2 = np.sum(vphi[cond] ** 2 * m_sum_log) / np.sum(m_sum_log)
                        sigma_phi_2_rad_log = vphi_rad_log_2 - vphi_rad_log ** 2

                        # print("vt_rad_log",vt_rad_log[i])
                        # print("sigma_t_2_rad_log",sigma_t_2_rad_log[i],"sigma_t_rad_log",np.sqrt(sigma_t_2_rad_log[i]))

                        # print("vr_rad_log",vr_rad_log)
                        # print("sigma_r_2_rad_log",sigma_r_2_rad_log[i],"sigma_r_rad_log",np.sqrt(sigma_r_2_rad_log[i]))

                        # print("vtheta_rad_log",vtheta_rad_log)
                        # print("sigma_theta_2_rad_log",sigma_theta_2_rad_log)

                        # print("vphi_rad_log",vphi_rad_log)
                        # print("sigma_phi_2_rad_log",sigma_phi_2_rad_log)

                        # print("v_car_module",np.sqrt(vx**2+vy**2+vz**2))
                        # print("v_sph_module",np.sqrt(vr**2+vtheta**2+vphi**2))

                        # sys.exit()

                    # print("ne rad log[0]",ne_rad_log[i])
                    # print("p rad log[0]",p_rad_log[i])
                    # sys.exit()

                    condnocut = np.logical_and(rlognocut > (i + 17.5) * 0.1, rlognocut < (i + 18.5) * 0.1)
                    m_sum_log = mnocut[condnocut]
                    m_rad_log[i] = m_sum_log.sum()

                p_turb /= 10
                p_turb /= 1.602 * 10 ** (-10)
                p_turb = np.log10(p_turb)
                # print("p_turb log", p_turb)

                if log_before == 0:
                    err_p = err_p / (np.log(10) * p_rad_log)
                    err_t = err_t / (np.log(10) * t_rad_log)
                    err_ne = err_ne / (np.log(10) * ne_rad_log)
                    err_k = err_k / (np.log(10) * k_rad_log)
                    p_rad_log = np.log10(p_rad_log)
                    t_rad_log = np.log10(t_rad_log)
                    ne_rad_log = np.log10(ne_rad_log)
                    k_rad_log = np.log10(k_rad_log)
                    sigma_r_2_rad_log = np.log10(sigma_r_2_rad_log)
                    sigma_t_2_rad_log = np.log10(sigma_t_2_rad_log)
                    vt_rad_log = np.log10(vt_rad_log)
                    # vr_rad_log = np.log10(vr_rad_log)

                mass_before_1st_bin = np.sum(mnocut[rlognocut < 17.5 * 0.1])

                return p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_ne, err_p, err_t, err_k, p_turb, vr_rad_log, vt_rad_log, sigma_r_2_rad_log, sigma_t_2_rad_log, mass_before_1st_bin

            def test():
                p_rad_log = np.array(
                    [np.median(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
                ne_rad_log = np.array(
                    [np.median(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
                n_log = np.array(
                    [len(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
                m_rad_log = np.array(
                    [np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
                t_rad_log = np.array([np.sum(tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * m[
                    np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) / np.sum(
                    m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])

                mad_ne_log = np.array(
                    [np.median(
                        np.abs(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - ne_rad_log[i]))
                        for i in range(40)])
                mad_plog = np.array(
                    [np.median(np.abs(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - p_rad_log[i]))
                     for
                     i in range(40)])
                w_std_plog = np.array([np.sqrt(np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * (
                        tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - t_rad_log[i]) ** 2) / np.sum(
                    m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)])) for i in range(40)])

                return p_rad_log, t_rad_log, ne_rad_log, m_rad_log, n_log, mad_ne_log, mad_plog, w_std_plog

            # start=time.time()
            p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_nelog, err_plog, err_tlog, err_klog, p_turb, vr_rad_log, vt_rad_log, sigma_r_2_rad_log, sigma_t_2_rad_log, mass_before_1st_bin = log_scale(n)

            # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

            ptot = 10 ** p_rad_log + 10 ** p_turb
            alpha = (10 ** p_turb) / ptot
            # plt.scatter(rlogbin_cen,p_rad_log,s=6, c='orange')
            # plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted', label='$8192^3$', alpha=0.7, c='orange')
            # plt.xscale('log')
            # plt.show()
            # np.save("alpha.npy",alpha)
            # sys.exit()

            # end=time.time()
            # print("durée:",end-start)

            # rratio=rlogbin_cen/1087
            # krad=np.array([10**k_rad_log[i] for i in range(len(k_rad_log))])

            # rad_data = np.zeros((2, 40))
            # rad_data[0,:]=krad
            # rad_data[1,:]=krad*err_klog
            # np.save("K_prof_high",rad_data)

            # plt.plot(rratio,10**p_turb/(10**p_rad_log))
            # plt.scatter(rlogbin_cen, krad, s=6, c='green',label='Entropy')
            # plt.errorbar(rlogbin_cen, krad, yerr=krad*err_klog, ls='dotted', label='3D, 8192^3', alpha=0.7, c='orange')
            # plt.scatter(rlogbin_cen, p_rad_log, s=6, c='orange')
            # plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted',label='Rescaled data (lvl=15, low res)', alpha=0.7, c='orange')
            # plt.scatter(rlogbin_cen,np.log10(10**p_rad_log+10**p_turb),label='P_tot',s=6,c='blue')
            # plt.xscale('log')
            # plt.yscale('log')
            # plt.yscale('log')
            # plt.axvline(x=1087, color='grey')
            # plt.text(1087, 2.75, "$R_{500}$", rotation=90, size=16)
            # plt.axvline(x=2147, color='grey', ls='dashed')
            # plt.text(2147, 2.75, "$R_{vir}$", rotation=90, size=16)
            # plt.xlabel("R(kpc)", size=16)
            # plt.ylabel('$log_{10}(K[keV.cm^{2}])$')
            # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
            # plt.legend(prop={'size': 16})
            # plt.show()

            # sys.exit()

            # return t_rad, ne_rad, p_rad, m_rad, n_rad, p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, ne_rad_std, mad_ne_log, mad_plog, w_std_plog
            return p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, err_nelog, err_plog, err_tlog, err_klog, p_turb, vr_rad_log, vt_rad_log, sigma_r_2_rad_log, sigma_t_2_rad_log, mass_before_1st_bin
        p_rad_log, t_rad_log, ne_rad_log, n_log, m_ba_rad_log, err_nelog, err_plog, err_tlog, err_klog, p_turb, vr_rad_log, vt_rad_log, sigma_r_2_rad_log, sigma_t_2_rad_log, mass_ba_before_1st_bin = hydro("./virgo_xyz_files/virgo_xyz_hydro_l15_high.dat", 2, 1, 0, 20)


    def Pnt_from_rho(Pth,ne,sigma):
        Pth=5e-4 #in kev.cm-3
        Pth*=1.602e-10 # in kg m-1 s-2 (Pascal)
        ne=1e-4 #in cm-3
        ne *=1e6 #conversion in m-3
        print("sigma in km/s",sigma)
        sigma *=1e3 #conversion from km/s to m/s
        print("sigma in m/s",sigma)
        Pnt=ne*me*sigma**2
        print("Pth",Pth,"Pnt",Pnt)
        alpha=Pnt/(Pth+Pnt)
        return Pnt,alpha

    def Pnt_from_rho(Pth,ne,sigma): #test with fake 3D values
        Pth=5e-4 #in kev.cm-3
        Pth*=1.602e-10 # in kg m-1 s-2 (Pascal)
        ne=1e-4 #in cm-3
        ne *=1e6 #conversion in m-3
        print("sigma in km/s",sigma)
        sigma *=1e3 #conversion from km/s to m/s
        print("sigma in m/s",sigma)
        Pnt=ne*me*sigma**2
        print("Pth",Pth,"Pnt",Pnt)
        alpha=Pnt/(Pth+Pnt)
        return Pnt,alpha

    #pnt_from_rho,alpha_from_rho = Pnt_from_rho(P_500,ne_500,vd_500)



    sys.exit()

def thermo_profs_univ_prof_overplot():
    def hydro(file, t_cut, mean_med, log_before, n):
        print('hydro')
        print(file)
        h = FortranFile(file, 'r')

        ncell = h.read_ints()
        # nline = h.read_ints()
        # nline=[1,1]
        # nline=int(nline[0])
        print("ncell", ncell)

        # sys.exit()
        # print("nline",nline)
        # ncell=np.fromfile(file,dtype=np.int)
        # print("ncell",ncell)
        # n_e=np.fromfile(file,dtype=np.float64)
        # print("ne",n_e)
        # sys.exit()
        n_e = []
        # print("ne",n_e)

        # for i in range(0,nline):
        n_e = h.read_reals()
        # n_e=np.concatenate((n_e,n_e_line))
        # print("len ne",len(n_e))

        # plt.hist(n_e, bins=100)
        # plt.xscale('log')
        # plt.yscale('log')
        # plt.show()
        # sys.exit()

        print("t")
        t = []
        # for i in range(0, nline):
        t = h.read_reals()
        # t = np.concatenate((t, t_line))

        # plt.hist(t,bins=100)
        # plt.xscale('log')
        # plt.yscale('log')
        # plt.show()
        # sys.exit()

        print("p")
        p = []
        # for i in range(0, nline):
        p = h.read_reals()
        # p = np.concatenate((p, p_line))

        # plt.hist(p, bins=100)
        # plt.xscale('log')
        # plt.yscale('log')
        # plt.show()
        # sys.exit()

        print("x")
        x = []
        # for i in range(0, nline):
        x = h.read_reals()
        # x = np.concatenate((x, x_line))

        # print("x len",len(x))
        # print("xmin",np.min(x))
        # print("xmax",np.max(x))

        # print("hist x")

        # plt.hist(x, bins=100)
        # plt.show()

        # sys.exit()

        print('y')
        y = []
        # for i in range(0, nline):
        y = h.read_reals()
        #    y = np.concatenate((y, y_line))

        # print("ymin", np.min(y))
        # print("ymax", np.max(y))

        # ys.exit()

        print("z")
        z = []
        # for i in range(0, nline):
        z = h.read_reals()
        #    z = np.concatenate((z, z_line))

        # plt.hist(z, bins=100)
        # plt.show()
        # sys.exit()

        # print("zmin", np.min(z))
        # print("zmax", np.max(z))

        # sys.exit()

        print("vx")
        vx = []
        # for i in range(0, nline):
        vx = h.read_reals()
        #    vx = np.concatenate((vx, vx_line))

        print("vy")
        vy = []
        # for i in range(0, nline):
        vy = h.read_reals()
        #   vy = np.concatenate((vy, vy_line))

        print("vz")
        vz = []
        # for i in range(0, nline):
        vz = h.read_reals()

        #    vz = np.concatenate((vz, vz_line))

        def vel_comp_3D_hist(x, y, z, vx, vy, vz):

            x_cen = 0.48461068
            y_cen = 0.50809848
            z_cen = 0.49687076

            x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
            y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
            z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

            # print("x_cen", x_cen, "y_cen", y_cen, "z_cen", z_cen)

            r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)

            vx_virgo = -509.1301
            vy_virgo = 228.9488
            vz_virgo = -131.9249

            vz -= vz_virgo
            vy -= vy_virgo
            vx -= vx_virgo

            # plt.hist(vz[r<2500],bins=100)
            # plt.show()
            # sys.exit()

            def gauss(x, A, mu, sigma):
                return A * norm.pdf(x, mu, sigma)

            def gaussian_fit(data, count, bins):

                # Bin centers for fitting
                bin_centers = (bins[:-1] + bins[1:]) / 2

                # Define Gaussian function

                model = GaussianModel()

                params = model.make_params(amplitude=1, center=np.mean(data), sigma=np.std(data))
                result = model.fit(count, params, x=bin_centers)

                print(result.fit_report())

                # print("best values",result.best_values)
                # print("best fit",result.best_fit)
                # print("red chi2",result.redchi)

                amplitude_best = result.params['amplitude'].value
                amplitude_error = result.params['amplitude'].stderr

                center_best = result.params['center'].value
                center_error = result.params['center'].stderr

                sigma_best = result.params['sigma'].value
                sigma_error = result.params['sigma'].stderr

                height_best = result.params['height'].value
                height_error = result.params['height'].stderr

                chi2 = result.chisqr
                red_chi2 = result.redchi

                popt = [amplitude_best, center_best, sigma_best, height_best]
                errors = [amplitude_error, center_error, sigma_error, height_error]

                # sys.exit()

                # Initial guesses: amplitude, mean, std
                # p0 = [0.015, np.mean(data), np.std(data)]

                # Perform the fit
                # popt, pcov = curve_fit(gauss, bin_centers, count, p0=p0)

                # Extract fitted parameters and their errors from the covariance matrix
                # A_fit, mu_fit, sigma_fit = popt
                # errors = np.sqrt(np.diag(pcov))

                # print(f'Fit results: A = {A_fit:.3g} ± {errors[0]:.3g}, '
                #      f'mean = {mu_fit:.3g} ± {errors[1]:.3g}, '
                #      f'std = {sigma_fit:.3g} ± {errors[2]:.3g}')

                # expected = gauss(bin_centers, *popt)
                # chi2 = np.sum((count - expected) ** 2 / expected)
                # dof = len(count) - len(popt)

                # print(f'Chi-square: {chi2:.3g}')
                # print(f'Reduced Chi-square: {chi2 / dof:.3g}')

                # red_chi2= chi2/dof

                # normalisation = A_fit/(np.sqrt(2*np.pi)*sigma_fit)
                # normalisation_error = (1/(np.sqrt(2*np.pi)*sigma_fit))*np.sqrt(errors[0]**2+((-A_fit*errors[2])/sigma_fit)**2)

                # print("normalisation",normalisation,"±",normalisation_error)

                return popt, errors, chi2, red_chi2, bin_centers
                # sys.exit()

            large = 1

            def velocity_components_hist(x, y, z, vx, vy, vz, large):

                f, axs = plt.subplots(3, 4, figsize=(20, 8), constrained_layout=True)

                if large == 1:
                    r1 = 2147
                    r2 = 1087
                    plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
                    pdfrvir = "PDF ($R<R_{vir}$)"
                    pdfr500 = "PDF ($R<R_{500}$)"
                    height = 0.0017

                if large == 0:
                    r1 = 500
                    r2 = 100
                    plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
                    pdfrvir = "PDF ($R<500 kpc$)"
                    pdfr500 = "PDF ($R<100 kpc$)"
                    height = 0.0035

                vx_r1 = vx[r < r1]
                vy_r1 = vy[r < r1]
                vz_r1 = vz[r < r1]

                print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio", len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

                vx_r1 = vx_r1[t[r < r1] < 1e7]

                # sys.exit()

                # meanvx,stdvx = norm.fit(vx_r1)
                # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

                print(
                    f"vx_r1 stat: mean={np.mean(vx_r1):.4g}, "f"median={np.median(vx_r1):.4g}, "f"std={np.std(vx_r1):.4g}, "f"skewness={skew(vx_r1):.4g}, "f"kurtosis={kurtosis(vx_r1):.4g}")

                # sys.exit()

                print(
                    f"vy_r1 stat: mean={np.mean(vy_r1):.4g}, "f"median={np.median(vy_r1):.4g}, "f"std={np.std(vy_r1):.4g}, "f"skewness={skew(vy_r1):.4g}, "f"kurtosis={kurtosis(vy_r1):.4g}")
                print(
                    f"vz_r1 stat: mean={np.mean(vz_r1):.4g}, "f"median={np.median(vz_r1):.4g}, "f"std={np.std(vz_r1):.4g}, "f"skewness={skew(vz_r1):.4g}, "f"kurtosis={kurtosis(vz_r1):.4g}")

                vx_r2 = vx[r < r2]
                vy_r2 = vy[r < r2]
                vz_r2 = vz[r < r2]

                print(
                    f"vx_r2 stat: mean={np.mean(vx_r2):.4g}, "f"median={np.median(vx_r2):.4g}, "f"std={np.std(vx_r2):.4g}, "f"skewness={skew(vx_r2):.4g}, "f"kurtosis={kurtosis(vx_r2):.4g}")
                print(
                    f"vy_r2 stat: mean={np.mean(vy_r2):.4g}, "f"median={np.median(vy_r2):.4g}, "f"std={np.std(vy_r2):.4g}, "f"skewness={skew(vy_r2):.4g}, "f"kurtosis={kurtosis(vy_r2):.4g}")
                print(
                    f"vz_r2 stat: mean={np.mean(vz_r2):.4g}, "f"median={np.median(vz_r2):.4g}, "f"std={np.std(vz_r2):.4g}, "f"skewness={skew(vz_r2):.4g}, "f"kurtosis={kurtosis(vz_r2):.4g}")

                count, bins, _ = axs[0, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='red', density=True)

                # print("count",count)
                # sys.exit()

                popt, errors, chi2, red_chi2 = gaussian_fit(vx[r < r1], count, bins)
                axs[0, 0].plot(bins, gauss(bins, *popt[0:3]), color='black', label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[0,0].yscale('log')
                axs[0, 0].set_xlim(-1900, 1900)
                axs[0, 0].set_ylim(0, height)
                # axs[0, 0].set_ylim(0, 1.2e6)
                # axs[0,0].legend(fontsize=10)
                # axs[0, 0].set_title("$V_x$")
                # axs[0,0].set_xlabel("Vx [km/s]")
                # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
                axs[0, 0].set_ylabel(pdfrvir)
                axs[0, 0].set_xticks([])
                axs[0, 0].legend(fontsize=10)

                count, bins, _ = axs[0, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='blue', density=True)

                popt, errors, chi2, red_chi2 = gaussian_fit(vy[r < r1], count, bins)
                axs[0, 1].plot(bins, gauss(bins, *popt[0:3]), color='black', label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # xs[0,1].yscale('log')
                axs[0, 1].set_xlim(-1900, 1900)
                axs[0, 1].set_ylim(0, height)
                # axs[0, 1].set_ylim(0, 1.2e6)
                # axs[0,1].legend(fontsize=10)
                # axs[0, 1].set_title("y component")
                axs[0, 1].set_yticks([])
                # axs[0,1].set_xlabel("Vy [km/s]")
                axs[0, 1].set_xticks([])
                axs[0, 1].legend(fontsize=10)

                count, bins, _ = axs[0, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='green', density=True)

                popt, errors, chi2, red_chi2 = gaussian_fit(vz[r < r1], count, bins)
                axs[0, 2].plot(bins, gauss(bins, *popt[0:3]), color='black', label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[0,2].yscale('log')
                axs[0, 2].set_xlim(-1900, 1900)
                axs[0, 2].set_ylim(0, height)
                # axs[0, 2].set_ylim(0, 1.2e6)
                # axs[0,2].legend(fontsize=10)
                # axs[0, 2].set_title("z projection")
                # axs[0,2].set_xlabel("Vz [km/s]")
                axs[0, 2].set_yticks([])
                axs[0, 2].set_xticks([])
                axs[0, 2].legend(fontsize=10)

                axs[0, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
                axs[0, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
                axs[0, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
                axs[0, 3].set_xlim(-1900, 1900)
                axs[0, 3].set_ylim(0, height)
                # axs[0, 3].set_ylim(0, 1.2e6)
                axs[0, 3].set_yticks([])
                axs[0, 3].set_xticks([])
                axs[0, 3].legend(fontsize=10)

                # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
                #         rotation=270, fontsize=14)

                count, bins, _ = axs[1, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='red', density=True)

                popt, errors, chi2, red_chi2 = gaussian_fit(vx[r < r2], count, bins)
                axs[1, 0].plot(bins, gauss(bins, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[1,0].yscale('log')
                axs[1, 0].set_xlim(-1900, 1900)
                axs[1, 0].set_ylim(0, height)
                # axs[1, 0].set_ylim(0, 1.3e4)
                # axs[1,0].legend(fontsize=10)
                # axs[1,0].set_title("x projection")
                # axs[1,0].set_xlabel("Vx [km/s]")
                # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
                axs[1, 0].set_ylabel(pdfr500)
                axs[1, 0].set_xticks([])
                axs[1, 0].legend(fontsize=10)

                count, bins, _ = axs[1, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', density=True)

                popt, errors, chi2, red_chi2 = gaussian_fit(vy[r < r2], count, bins)
                axs[1, 1].plot(bins, gauss(bins, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # xs[1,1].yscale('log')
                axs[1, 1].set_xlim(-1900, 1900)
                axs[1, 1].set_ylim(0, height)
                # axs[1, 1].set_ylim(0, 1.3e4)
                # axs[1,1].legend(fontsize=10)
                # axs[1,1].set_title("y projection")
                axs[1, 1].set_yticks([])
                # axs[1,1].set_xlabel("Vy [km/s]")
                axs[1, 1].set_xticks([])
                axs[1, 1].legend(fontsize=10)

                count, bins, _ = axs[1, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='green', density=True)

                popt, errors, chi2, red_chi2 = gaussian_fit(vz[r < r2], count, bins)
                axs[1, 2].plot(bins, gauss(bins, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[1,2].yscale('log')
                axs[1, 2].set_xlim(-1900, 1900)
                axs[1, 2].set_ylim(0, height)
                # axs[1, 2].set_ylim(0, 1.3e4)
                # axs[1,2].legend(fontsize=10)
                # axs[1,2].set_title("z projection")
                # axs[1,2].set_xlabel("Vz [km/s]")
                axs[1, 2].set_yticks([])
                axs[1, 2].set_xticks([])
                axs[1, 2].legend(fontsize=10)

                axs[1, 3].hist(vx[r < r2], bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
                axs[1, 3].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
                axs[1, 3].hist(vz[r < r2], bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
                axs[1, 3].set_xlim(-1900, 1900)
                axs[1, 3].set_ylim(0, height)
                # axs[1, 3].set_ylim(0, 1.3e4)
                axs[1, 3].set_yticks([])
                axs[1, 3].legend(fontsize=10)
                # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
                #         rotation=270, fontsize=14)

                axs[2, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='red', label='$R<R_{vir}$', density=True)
                axs[2, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='darkred', label='$R<R_{500}$', density=True)
                # axs[2,0].yscale('log')
                axs[2, 0].set_xlim(-1900, 1900)
                axs[2, 0].set_ylim(0, height)
                # axs[2, 0].set_ylim(0, 700)
                # axs[2,0].legend(fontsize=10)
                # axs[2,0].set_title("x projection")
                axs[2, 0].set_xlabel("Vx [km/s]")
                axs[2, 0].set_ylabel("PDF")
                axs[2, 0].legend(fontsize=10)
                # axs[2, 0].set_yscale('log')

                axs[2, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='blue', label='$R<R_{vir}$', density=True)
                axs[2, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='darkblue', label='$R<R_{500}$', density=True)
                # xs[2,1].yscale('log')
                axs[2, 1].set_xlim(-1900, 1900)
                axs[2, 1].set_ylim(0, height)
                # axs[2, 1].set_ylim(0, 700)
                # axs[2,1].legend(fontsize=10)
                # axs[2,1].set_title("y projection")
                axs[2, 1].set_yticks([])
                axs[2, 1].set_xlabel("Vy [km/s]")
                axs[2, 1].legend(fontsize=10)
                # axs[2, 1].set_yscale('log')

                axs[2, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='green', label='$R<R_{vir}$', density=True)
                axs[2, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='darkgreen', label='$R<R_{500}$', density=True)
                # axs[2,2].yscale('log')
                axs[2, 2].set_xlim(-1900, 1900)
                axs[2, 2].set_ylim(0, height)
                # axs[2, 2].set_ylim(0, 700)
                # axs[2,2].legend(fontsize=10)
                # axs[2,2].set_title("z projection")
                axs[2, 2].set_xlabel("Vz [km/s]")
                axs[2, 2].set_yticks([])
                axs[2, 2].legend(fontsize=10)
                # axs[2, 2].set_yscale('log')

                # axs[3].yscale('log')

                # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
                # plt.grid(b=None)
                plt.legend()
                # plt.ylabel("PDF")
                axs[1, 3].set_xlabel("V [km/s]")

                axs[2, 3].axis("off")

                # plt.yscale('log')
                # plt.title("Vz distribution on ew sightline velocity along z axis")
                # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

                plt.show()

                sys.exit()

            def velocity_components_hist_5x4(x, y, z, vx, vy, vz, large):
                f, axs = plt.subplots(5, 4, figsize=(20, 8), constrained_layout=True)

                if large == 1:
                    r1 = 2147
                    r2 = 1087
                    plt.suptitle("Velocity components distribution within $R_{vir}$(=2.15Mpc) and $R_{500}$(=1.1Mpc)")
                    pdfrvir = "PDF \n ($R<R_{vir}$)"
                    pdfr500 = "PDF \n ($R<R_{500}$)"
                    height = 0.0017
                    # height = 0.0035

                if large == 0:
                    r1 = 500
                    r2 = 100
                    plt.suptitle("Velocity components distribution within spheres of 500kpc and 100kpc radii")
                    pdfrvir = "PDF \n ($R<500\,\mathrm{kpc}$)"
                    pdfr500 = "PDF \n ($R<100$ kpc)"
                    height = 0.0035

                vx_r1 = vx[r < r1]
                vy_r1 = vy[r < r1]
                vz_r1 = vz[r < r1]

                # print("nbr of cells with T<10^7K", len(vx_r1[t[r < r1] < 1e7]), "ratio",len(vx_r1[t[r < r1] < 1e7]) / len(vx_r1))

                # vx_r1 = vx_r1[t[r < r1] < 1e7]

                # meanvx,stdvx = norm.fit(vx_r1)
                # print(f"Vx fit:mean={meanvx:.4g},"f"std={stdvx:.4g}")

                print(
                    f"vx_r1 stat: mean={np.mean(vx_r1):.4g}, "f"median={np.median(vx_r1):.4g}, "f"std={np.std(vx_r1):.4g}, "f"skewness={skew(vx_r1):.4g}, "f"kurtosis={kurtosis(vx_r1):.4g}")

                # sys.exit()

                print(
                    f"vy_r1 stat: mean={np.mean(vy_r1):.4g}, "f"median={np.median(vy_r1):.4g}, "f"std={np.std(vy_r1):.4g}, "f"skewness={skew(vy_r1):.4g}, "f"kurtosis={kurtosis(vy_r1):.4g}")
                print(
                    f"vz_r1 stat: mean={np.mean(vz_r1):.4g}, "f"median={np.median(vz_r1):.4g}, "f"std={np.std(vz_r1):.4g}, "f"skewness={skew(vz_r1):.4g}, "f"kurtosis={kurtosis(vz_r1):.4g}")

                vx_r2 = vx[r < r2]
                vy_r2 = vy[r < r2]
                vz_r2 = vz[r < r2]

                print(
                    f"vx_r2 stat: mean={np.mean(vx_r2):.4g}, "f"median={np.median(vx_r2):.4g}, "f"std={np.std(vx_r2):.4g}, "f"skewness={skew(vx_r2):.4g}, "f"kurtosis={kurtosis(vx_r2):.4g}")
                print(
                    f"vy_r2 stat: mean={np.mean(vy_r2):.4g}, "f"median={np.median(vy_r2):.4g}, "f"std={np.std(vy_r2):.4g}, "f"skewness={skew(vy_r2):.4g}, "f"kurtosis={kurtosis(vy_r2):.4g}")
                print(
                    f"vz_r2 stat: mean={np.mean(vz_r2):.4g}, "f"median={np.median(vz_r2):.4g}, "f"std={np.std(vz_r2):.4g}, "f"skewness={skew(vz_r2):.4g}, "f"kurtosis={kurtosis(vz_r2):.4g}")

                count, bins, _ = axs[0, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='darkred', density=True)

                # print("count",count)
                # sys.exit()

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r1], count, bins)
                axs[0, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[0,0].yscale('log')
                axs[0, 0].set_xlim(-1600, 1600)
                axs[0, 0].set_ylim(1e-5, height)
                # axs[0, 0].set_ylim(0, 1.2e6)
                # axs[0,0].legend(fontsize=10)
                # axs[0, 0].set_title("$V_x$")
                # axs[0,0].set_xlabel("Vx [km/s]")
                # axs[0, 0].set_ylabel("PDF ($R<R_{vir}$)")
                axs[0, 0].set_ylabel(pdfrvir)
                axs[0, 0].set_xticks([])
                axs[0, 0].set_yscale('log')
                # axs[0, 0].legend(fontsize=10)
                # axs[0,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='solid')

                count, bins, _ = axs[0, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='darkblue', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r1], count, bins)
                axs[0, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # xs[0,1].yscale('log')
                axs[0, 1].set_xlim(-1600, 1600)
                axs[0, 1].set_ylim(1e-5, height)
                # axs[0, 1].set_ylim(0, 1.2e6)
                # axs[0,1].legend(fontsize=10)
                # axs[0, 1].set_title("y component")
                axs[0, 1].set_yticks([])
                # axs[0,1].set_xlabel("Vy [km/s]")
                axs[0, 1].set_xticks([])
                axs[0, 1].set_yscale('log')
                # axs[0, 1].legend(fontsize=10)
                axs[0, 1].yaxis.set_visible(False)
                # axs[0, 1].axvline(x=np.mean(vy[r < r1]), color='black', linestyle='solid')

                count, bins, _ = axs[0, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='darkgreen', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r1], count, bins)
                axs[0, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[0,2].yscale('log')
                axs[0, 2].set_xlim(-1600, 1600)
                axs[0, 2].set_ylim(1e-5, height)
                # axs[0, 2].set_ylim(0, 1.2e6)
                # axs[0,2].legend(fontsize=10)
                # axs[0, 2].set_title("z projection")
                # axs[0,2].set_xlabel("Vz [km/s]")
                axs[0, 2].set_yticks([])
                axs[0, 2].set_xticks([])
                axs[0, 2].set_yscale('log')
                # axs[0, 2].legend(fontsize=10)
                axs[0, 2].yaxis.set_visible(False)
                # axs[0, 2].axvline(x=np.mean(vz[r < r1]), color='black', linestyle='solid')

                axs[0, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='darkred', label='$V_x$', density=True)
                axs[0, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='darkblue', label='$V_y$', density=True)
                axs[0, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='darkgreen', label='$V_z$', density=True)
                axs[0, 3].set_xlim(-1600, 1600)
                axs[0, 3].set_ylim(1e-5, height)
                # axs[0, 3].set_ylim(0, 1.2e6)
                axs[0, 3].set_yticks([])
                axs[0, 3].set_xticks([])
                axs[0, 3].set_yscale('log')
                # axs[0, 3].legend(fontsize=10)
                axs[0, 3].yaxis.set_visible(False)
                # axs[0, 3].axvline(x=np.mean(vx[r < r1]), color='red', linestyle='solid')
                # axs[0, 3].axvline(x=np.mean(vy[r < r1]), color='blue', linestyle='solid')
                # axs[0, 3].axvline(x=np.mean(vz[r < r1]), color='green', linestyle='solid')

                # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[0, 3].transAxes, verticalalignment='center',
                #         rotation=270, fontsize=14)

                count, bins, _ = axs[1, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='red', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r2], count, bins)
                axs[1, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[1,0].yscale('log')
                axs[1, 0].set_xlim(-1600, 1600)
                axs[1, 0].set_ylim(1e-5, height)
                # axs[1, 0].set_ylim(0, 1.3e4)
                # axs[1,0].legend(fontsize=10)
                # axs[1,0].set_title("x projection")
                # axs[1,0].set_xlabel("Vx [km/s]")
                # axs[1, 0].set_ylabel("PDF ($R<R_{500}$)")
                axs[1, 0].set_ylabel(pdfr500)
                axs[1, 0].set_xticks([])
                axs[1, 0].set_yscale('log')
                # axs[1, 0].legend(fontsize=10)
                # axs[1,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashed')

                count, bins, _ = axs[1, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r2], count, bins)
                axs[1, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # xs[1,1].yscale('log')
                axs[1, 1].set_xlim(-1600, 1600)
                axs[1, 1].set_ylim(1e-5, height)
                # axs[1, 1].set_ylim(0, 1.3e4)
                # axs[1,1].legend(fontsize=10)
                # axs[1,1].set_title("y projection")
                axs[1, 1].set_yticks([])
                # axs[1,1].set_xlabel("Vy [km/s]")
                axs[1, 1].set_xticks([])
                axs[1, 1].set_yscale('log')
                # axs[1, 1].legend(fontsize=10)
                axs[1, 1].yaxis.set_visible(False)
                # axs[1, 1].axvline(x=np.mean(vy[r < r2]), color='black', linestyle='dashed')

                count, bins, _ = axs[1, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='green', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r2], count, bins)
                axs[1, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[1,2].yscale('log')
                axs[1, 2].set_xlim(-1600, 1600)
                axs[1, 2].set_ylim(1e-5, height)
                # axs[1, 2].set_ylim(0, 1.3e4)
                # axs[1,2].legend(fontsize=10)
                # axs[1,2].set_title("z projection")
                # axs[1,2].set_xlabel("Vz [km/s]")
                axs[1, 2].set_yticks([])
                axs[1, 2].set_xticks([])
                axs[1, 2].set_yscale('log')
                # axs[1, 2].legend(fontsize=10)
                axs[1, 2].yaxis.set_visible(False)
                # axs[1, 2].axvline(x=np.mean(vz[r < r2]), color='black', linestyle='dashed')

                axs[1, 3].hist(vx[r < r2], bins=20, alpha=0.6, color='red', label='$V_x$', density=True)
                axs[1, 3].hist(vy[r < r2], bins=20, alpha=0.6, color='blue', label='$V_y$', density=True)
                axs[1, 3].hist(vz[r < r2], bins=20, alpha=0.6, color='green', label='$V_z$', density=True)
                axs[1, 3].set_xlim(-1600, 1600)
                axs[1, 3].set_ylim(1e-5, height)
                # axs[1, 3].set_ylim(0, 1.3e4)
                axs[1, 3].set_yticks([])
                axs[1, 3].set_xticks([])
                axs[1, 3].set_yscale('log')
                # axs[1, 3].legend(fontsize=10)
                axs[1, 3].yaxis.set_visible(False)
                # axs[1, 3].axvline(x=np.mean(vx[r < r2]), color='red', linestyle='dashed')
                # axs[1, 3].axvline(x=np.mean(vy[r < r2]), color='blue', linestyle='dashed')
                # axs[1, 3].axvline(x=np.mean(vz[r < r2]), color='green', linestyle='dashed')
                # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[1, 3].transAxes, verticalalignment='center',
                #         rotation=270, fontsize=14)

                ########################################
                ########################################

                large = 0

                if large == 0:
                    r1 = 500
                    r2 = 100
                    plt.suptitle("Velocity components PDFs within spheres of 500kpc and 100kpc radii")
                    pdfrvir = "PDF \n ($R<500\,\mathrm{kpc}$)"
                    pdfr500 = "PDF \n ($R<100\,\mathrm{kpc}$)"
                    height1 = 0.002
                    height = 0.0035

                vx_r1 = vx[r < r1]
                vy_r1 = vy[r < r1]
                vz_r1 = vz[r < r1]

                vx_r2 = vx[r < r2]
                vy_r2 = vy[r < r2]
                vz_r2 = vz[r < r2]

                count, bins, _ = axs[2, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', density=True)

                # print("count",count)
                # sys.exit()

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r1], count, bins)
                axs[2, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[2,0].yscale('log')
                axs[2, 0].set_xlim(-1600, 1600)
                axs[2, 0].set_ylim(1e-5, height1)
                # axs[2, 0].set_ylim(0, 1.2e6)
                # axs[2,0].legend(fontsize=10)
                # axs[2, 0].set_title("$V_x$")
                # axs[2,0].set_xlabel("Vx [km/s]")
                # axs[2, 0].set_ylabel("PDF ($R<R_{vir}$)")
                axs[2, 0].set_ylabel(pdfrvir)
                axs[2, 0].set_xticks([])
                axs[2, 0].set_yscale('log')
                # axs[2, 0].legend(fontsize=10)
                # axs[2,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='dotted')

                count, bins, _ = axs[2, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r1], count, bins)
                axs[2, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # xs[2,1].yscale('log')
                axs[2, 1].set_xlim(-1600, 1600)
                axs[2, 1].set_ylim(1e-5, height1)
                # axs[2, 1].set_ylim(0, 1.2e6)
                # axs[2,1].legend(fontsize=10)
                # axs[2, 1].set_title("y component")
                axs[2, 1].set_yticks([])
                # axs[2,1].set_xlabel("Vy [km/s]")
                axs[2, 1].set_xticks([])
                axs[2, 1].set_yscale('log')
                # axs[2, 1].legend(fontsize=10)
                axs[2, 1].yaxis.set_visible(False)
                # axs[2, 1].axvline(x=np.mean(vy[r < r1]), color='black', linestyle='dotted')

                count, bins, _ = axs[2, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r1], count, bins)
                axs[2, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[2,2].yscale('log')
                axs[2, 2].set_xlim(-1600, 1600)
                axs[2, 2].set_ylim(1e-5, height1)
                # axs[2, 2].set_ylim(0, 1.2e6)
                # axs[2,2].legend(fontsize=10)
                # axs[2, 2].set_title("z projection")
                # axs[2,2].set_xlabel("Vz [km/s]")
                axs[2, 2].set_yticks([])
                axs[2, 2].set_xticks([])
                axs[2, 2].set_yscale('log')
                # axs[2, 2].legend(fontsize=10)
                axs[2, 2].yaxis.set_visible(False)
                # axs[2, 2].axvline(x=np.mean(vz[r < r1]), color='black', linestyle='dotted')

                axs[2, 3].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', label='$V_x$', density=True)
                axs[2, 3].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', label='$V_y$', density=True)
                axs[2, 3].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', label='$V_z$', density=True)
                axs[2, 3].set_xlim(-1600, 1600)
                axs[2, 3].set_ylim(1e-5, height1)
                # axs[2, 3].set_ylim(0, 1.2e6)
                axs[2, 3].set_yticks([])
                axs[2, 3].set_xticks([])
                axs[2, 3].set_yscale('log')
                # axs[2, 3].legend(fontsize=10)
                axs[2, 3].yaxis.set_visible(False)
                # axs[2, 3].axvline(x=np.mean(vx[r < r1]), color='red', linestyle='dotted')
                # axs[2, 3].axvline(x=np.mean(vy[r < r1]), color='blue', linestyle='dotted')
                # axs[2, 3].axvline(x=np.mean(vz[r < r1]), color='green', linestyle='dotted')

                # plt.text(1.05, 0.5, '$R<R_{vir}$', transform=axs[2, 3].transAxes, verticalalignment='center',
                #         rotation=270, fontsize=14)

                count, bins, _ = axs[3, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vx[r < r2], count, bins)
                axs[3, 0].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[3,0].yscale('log')
                axs[3, 0].set_xlim(-1600, 1600)
                axs[3, 0].set_ylim(1e-5, height)
                # axs[3, 0].set_ylim(0, 1.3e4)
                # axs[3,0].legend(fontsize=10)
                # axs[3,0].set_title("x projection")
                # axs[3,0].set_xlabel("Vx [km/s]")
                # axs[3, 0].set_ylabel("PDF ($R<R_{500}$)")
                axs[3, 0].set_ylabel(pdfr500)
                axs[3, 0].set_xticks([])
                axs[3, 0].set_yscale('log')
                # axs[3, 0].legend(fontsize=10)
                # axs[3,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashdot')

                count, bins, _ = axs[3, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vy[r < r2], count, bins)
                axs[3, 1].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # xs[3,1].yscale('log')
                axs[3, 1].set_xlim(-1600, 1600)
                axs[3, 1].set_ylim(1e-5, height)
                # axs[3, 1].set_ylim(0, 1.3e4)
                # axs[3,1].legend(fontsize=10)
                # axs[3,1].set_title("y projection")
                axs[3, 1].set_yticks([])
                # axs[3,1].set_xlabel("Vy [km/s]")
                axs[3, 1].set_xticks([])
                axs[3, 1].set_yscale('log')
                # axs[3, 1].legend(fontsize=10)
                axs[3, 1].yaxis.set_visible(False)
                # axs[3, 1].axvline(x=np.mean(vy[r < r2]), color='black', linestyle='dashdot')

                count, bins, _ = axs[3, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', density=True)

                popt, errors, chi2, red_chi2, bin_cen = gaussian_fit(vz[r < r2], count, bins)
                axs[3, 2].plot(bin_cen, gauss(bin_cen, *popt[0:3]), color='black',
                               label='best fit : \n $\mu$={:.3g}±{:.3g}, $\sigma$={:.3g}±{:.3g} \n $Norm$={:.3g}±{:.3g} \n $\chi^2$={:.3g}, $\chi^2/dof$={:.3g}'.format(
                                   popt[1], errors[1], popt[2], errors[2], popt[3], errors[3], chi2, red_chi2))

                # axs[3,2].yscale('log')
                axs[3, 2].set_xlim(-1600, 1600)
                axs[3, 2].set_ylim(1e-5, height)
                # axs[3, 2].set_ylim(0, 1.3e4)
                # axs[3,2].legend(fontsize=10)
                # axs[3,2].set_title("z projection")
                # axs[3,2].set_xlabel("Vz [km/s]")
                axs[3, 2].set_yticks([])
                axs[3, 2].set_xticks([])
                axs[3, 2].set_yscale('log')
                # axs[3, 2].legend(fontsize=10)
                axs[3, 2].yaxis.set_visible(False)
                # axs[3, 2].axvline(x=np.mean(vz[r < r2]), color='black', linestyle='dashdot')

                axs[3, 3].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', label='$V_x$', density=True)
                axs[3, 3].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', label='$V_y$', density=True)
                axs[3, 3].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', label='$V_z$', density=True)
                axs[3, 3].set_xlim(-1600, 1600)
                axs[3, 3].set_ylim(1e-5, height)
                # axs[3, 3].set_ylim(0, 1.3e4)
                axs[3, 3].set_yticks([])
                axs[3, 3].set_xticks([])
                # axs[3, 3].legend(fontsize=10)
                axs[3, 3].set_yscale('log')
                axs[3, 3].yaxis.set_visible(False)
                # axs[3, 3].axvline(x=np.mean(vx[r < r2]), color='red', linestyle='dashdot')
                # axs[3, 3].axvline(x=np.mean(vy[r < r2]), color='blue', linestyle='dashdot')
                # axs[3, 3].axvline(x=np.mean(vz[r < r2]), color='green', linestyle='dashdot')
                # plt.text(1.05, 0.5, '$R<R_{500}$', transform=axs[3, 3].transAxes, verticalalignment='center',
                #         rotation=270, fontsize=14)

                ########################################
                ########################################

                rvir = 2147
                r500 = 1087

                axs[4, 0].hist(vx[r < rvir], bins=20, alpha=0.6, color='darkred', label='$R<R_{vir}$', density=True)  # ,histtype='step',linewidth=2)
                axs[4, 0].hist(vx[r < r500], bins=20, alpha=0.6, color='red', label='$R<R_{500}$', density=True)  # ,histtype='step',linewidth=2)
                axs[4, 0].hist(vx[r < r1], bins=20, alpha=0.6, color='orange', label='$R<500kpc$', density=True)  # ,histtype='step',linewidth=2)
                axs[4, 0].hist(vx[r < r2], bins=20, alpha=0.6, color='gold', label='$R<100kpc$', density=True)  # ,histtype='step',linewidth=2)
                # axs[4,0].yscale('log')
                axs[4, 0].set_xlim(-1600, 1600)
                axs[4, 0].set_ylim(1e-5, height)
                # axs[4, 0].set_ylim(0, 700)
                # axs[4,0].legend(fontsize=10)
                # axs[4,0].set_title("x projection")
                axs[4, 0].set_xlabel("$v_{x}~[\mathrm{km~s^{-1}}]$")
                axs[4, 0].set_ylabel("PDF")
                axs[4, 0].set_yscale('log')
                # axs[4,0].axvline(x=np.mean(vx[r<rvir]), color='black', linestyle='solid')
                # axs[4,0].axvline(x=np.mean(vx[r<r500]), color='black', linestyle='dashed')
                # axs[4,0].axvline(x=np.mean(vx[r<r1]), color='black', linestyle='dotted')
                # axs[4,0].axvline(x=np.mean(vx[r<r2]), color='black', linestyle='dashdot')
                # axs[4, 0].legend(fontsize=10)
                # axs[4, 0].set_yscale('log')

                axs[4, 1].hist(vy[r < rvir], bins=20, alpha=0.6, color='darkblue', label='$R<R_{vir}$', density=True)  # ,histtype='step',linewidth=2)
                axs[4, 1].hist(vy[r < r500], bins=20, alpha=0.6, color='blue', label='$R<R_{500}$', density=True)  # ,histtype='step',linewidth=2)
                axs[4, 1].hist(vy[r < r1], bins=20, alpha=0.6, color='cornflowerblue', label='$R<500kpc$', density=True)  # ,histtype='step',linewidth=2)
                axs[4, 1].hist(vy[r < r2], bins=20, alpha=0.6, color='aqua', label='$R<100kpc$', density=True)  # ,histtype='step',linewidth=2)
                # xs[4,1].yscale('log')
                axs[4, 1].set_xlim(-1600, 1600)
                axs[4, 1].set_ylim(1e-5, height)
                # axs[4, 1].set_ylim(0, 700)
                # axs[4,1].legend(fontsize=10)
                # axs[4,1].set_title("y projection")
                axs[4, 1].set_yticks([])
                axs[4, 1].set_xlabel("$v_{y}~[\mathrm{km~s^{-1}}]$")
                axs[4, 1].set_yscale('log')
                # axs[4,1].axvline(x=np.mean(vy[r<rvir]), color='black', linestyle='solid')
                # axs[4,1].axvline(x=np.mean(vy[r<r500]), color='black', linestyle='dashed')
                # axs[4,1].axvline(x=np.mean(vy[r<r1]), color='black', linestyle='dotted')
                # axs[4,1].axvline(x=np.mean(vy[r<r2]), color='black', linestyle='dashdot')
                # axs[4, 1].legend(fontsize=10)
                # axs[4, 1].set_yscale('log')
                axs[4, 1].yaxis.set_visible(False)

                axs[4, 2].hist(vz[r < rvir], bins=20, alpha=0.6, color='darkgreen', label='$R<R_{vir}$', density=True)  # ,histtype='step',linewidth=2)
                axs[4, 2].hist(vz[r < r500], bins=20, alpha=0.6, color='green', label='$R<R_{500}$', density=True)  # ,histtype='step',linewidth=2)
                axs[4, 2].hist(vz[r < r1], bins=20, alpha=0.6, color='turquoise', label='$R<500kpc$', density=True)  # ,histtype='step',linewidth=2)
                axs[4, 2].hist(vz[r < r2], bins=20, alpha=0.6, color='aquamarine', label='$R<100kpc$', density=True)  # ,histtype='step',linewidth=2)
                # axs[4,2].yscale('log')
                axs[4, 2].set_xlim(-1600, 1600)
                axs[4, 2].set_ylim(1e-5, height)
                # axs[4, 2].set_ylim(0, 700)
                # axs[4,2].legend(fontsize=10)
                # axs[4,2].set_title("z projection")
                axs[4, 2].set_xlabel("$v_{z}~[\mathrm{km~s^{-1}}]$")
                axs[4, 2].set_yticks([])
                # axs[4, 2].legend(fontsize=10)
                axs[4, 2].set_yscale('log')
                # axs[4,2].axvline(x=np.mean(vz[r<rvir]), color='black', linestyle='solid')
                # axs[4,2].axvline(x=np.mean(vz[r<r500]), color='black', linestyle='dashed')
                # axs[4,2].axvline(x=np.mean(vz[r<r1]), color='black', linestyle='dotted')
                # axs[4,2].axvline(x=np.mean(vz[r<r2]), color='black', linestyle='dashdot')
                axs[4, 2].yaxis.set_visible(False)
                # axs[4, 2].set_yscale('log')

                # axs[3].yscale('log')

                # plt.hist(v_Trange_list_100kpc, bins=20, alpha=0.6, color='green', label='100kpc**2, XRISM T range')
                # plt.grid(b=None)
                plt.legend()
                # plt.ylabel("PDF")
                axs[3, 3].set_xlabel("$v~[\mathrm{km~s^{-1}}]$")

                axs[4, 3].axis("off")

                # plt.yscale('log')
                # plt.title("Vz distribution on ew sightline velocity along z axis")
                # plt.title("Velocity distribution along sightlines, 100kpc**2 maps, XRISM T range")

                plt.suptitle("Velocity components distribution within $R_{vir}$, $R_{500}$, 500kpc and 100kpc radii spheres")

                plt.show()

                sys.exit()

            velocity_components_hist_5x4(x, y, z, vx, vy, vz, large)

        # vel_comp_3D_hist(x,y,z,vx,vy,vz)

        print("m")
        m = []
        # for i in range(0, nline):
        m = h.read_reals()
        #    m = np.concatenate((m, m_line))

        # print("mass min",np.min(m))
        # print("mass max",np.max(m))
        # sys.exit()

        # plt.hist(np.log10(m),bins=100,range=[2,7.2])
        # plt.show()
        # sys.exit()

        print("lvl")
        lvl = []
        # for i in range(0, nline):
        lvl = h.read_reals()
        #    lvl = np.concatenate((lvl, lvl_line))

        # print("max lvl",np.max(lvl))
        # print("min lvl",np.min(lvl))

        # sys.exit()

        # plt.hist2d(m,lvl,bins=[100,9],range=[[1E2,1E7],[11,19]])
        # plt.show()

        # sys.exit()

        # plt.scatter(m,lvl)
        # plt.show()
        # sys.exit()

        m_cumul_ba = np.zeros(21)

        x_cen = 0.48461068
        y_cen = 0.50809848
        z_cen = 0.49687076

        x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
        y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
        z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

        # cond = np.logical_and(x-x_cen<7000,np.logical_and(x-x_cen>-9000,np.logical_and(y-y_cen<2500,np.logical_and(y-y_cen>-2500,np.logical_and(z-z_cen<2500,z-z_cen>-2500)))))

        # lvl_test= lvl[cond]

        # print("lvl inf 15",len(lvl_test[lvl_test<15]),"tot lvl test",len(lvl_test))

        # sys.exit()

        # print("x_cen",x_cen,"y_cen",y_cen,"z_cen",z_cen)

        def resolution_hist(x, y, z, lvl, x_cen, y_cen, z_cen):
            x -= x_cen
            y -= y_cen
            z -= z_cen

            # plt.hist(x,bins=100)

            cond = np.logical_and(x > -9000, np.logical_and(x < -7000, np.logical_and(y > 2500, np.logical_and(y < 4500, np.logical_and(z > -1000, z < 1000)))))

            # cond = np.logical_and(x > -9000, np.logical_and(x < -7000, np.logical_and(y > -5000, np.logical_and(y < 5000,np.logical_and(z > -5000,z < 5000)))))

            plt.hist(lvl[cond], bins=100)
            plt.show()
            sys.exit()

        # resolution_hist(x,y,z,lvl,x_cen,y_cen,z_cen)

        def compute_sound_speed(vx, vy, vz):

            print("compute sound speed")

            size = (737441 * 0.03) / 8
            size = 1000
            print("size", size)

            vx_virgo = -509.1301
            vy_virgo = 228.9488
            vz_virgo = -131.9249

            vx -= vx_virgo
            vy -= vy_virgo
            vz -= vz_virgo

            cond = np.logical_and(np.abs(x - x_cen) < size / 2, np.logical_and(np.abs(y - y_cen) < size / 2, np.abs(z - z_cen) < size / 2))

            # plt.hist(x[cond],bins=100)
            # plt.show()
            # sys.exit()

            t_mean = np.mean(t[cond])
            print("T_mean", "{:.2e}".format(t_mean))

            cs = np.sqrt(((5 / 3) * kb * t_mean) / (mu * mp))

            cs_all = np.sqrt(((5 / 3) * kb * t) / (mu * mp))

            print("mp", mp)

            v_mean = np.mean(np.sqrt(vx[cond] ** 2 + vy[cond] ** 2 + vz[cond] ** 2))

            v_mean *= 1e3

            v_all = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)

            v_all *= 1e3

            print("v_mean", "{:.2e}".format(v_mean))

            print("cs", "{:.2e}".format(cs))

            print("Mach number", "{:.2e}".format(v_mean / cs))

            ratio = v_all / cs_all

            plt.hist(ratio[ratio < 100], bins=100)
            plt.show()

            sys.exit()

        # compute_sound_speed(vx, vy, vz)

        def velocity_radial_profile(x, y, z, vx, vy, vz, n, m):
            x_cen = 0.48461068
            y_cen = 0.50809848
            z_cen = 0.49687076

            x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
            y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
            z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

            r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)

            rlog = np.log10(r)

            vx_virgo = -509.1301
            vy_virgo = 228.9488
            vz_virgo = -131.9249

            vx -= vx_virgo
            vy -= vy_virgo
            vz -= vz_virgo

            v = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)

            rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

            v_rad_log = np.zeros(n)
            err_v = np.zeros(n)

            for i in range(0, n):
                print(i)

                # cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
                # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
                # cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))

                # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y > y_cen,z > z_cen)))) #Sector 8 = Spherical Collapse
                # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x < x_cen,np.logical_and(y < y_cen,z < z_cen))))  # Sector 1 = Relaxed
                # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y < y_cen, z < z_cen))))  # Sector 5 = Filament

                cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025)  # Full box

                m_sum_log = m[cond]
                v_sum_log = v[cond]

                # v_rad_log[i] = np.sum(v_sum_log * m_sum_log) / np.sum(m_sum_log)
                v_rad_log[i] = np.mean(v_sum_log)

                # err_v[i] = np.sqrt(np.sum(m_sum_log * (v_sum_log - v_rad_log[i]) ** 2) / np.sum(m_sum_log))
                err_v[i] = np.std(v_sum_log)

            plt.scatter(rlogbin_cen, v_rad_log, s=6, c='green')  # , c='blue')
            plt.errorbar(rlogbin_cen, v_rad_log, yerr=err_v, ls='dotted', label='sector 1', alpha=0.7, c='green')  # , c='blue')
            plt.show()

            sys.exit()

        # velocity_radial_profile(x,y,z,vx,vy,vz,n,m)

        # sys.exit()

        # r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)

        # plt.hist(r,bins=100)
        # plt.show()
        # sys.exit()

        # for i in range(0, 21):
        #    print(i)

        # cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
        # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
        # cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))
        # m_sum_log = m[cond]
        #    rlim = 10 ** ((18 + i) * 0.1)
        #    print(i, 'rlim ', rlim)
        # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
        #    m_cumul_ba[i] = np.sum(m[r < rlim])

        # print("msumbar", m_cumul_ba)
        # np.save("m_cumul_ba_21.npy", m_cumul_ba)

        # sys.exit()

        # @jit(nopython=True)
        def change_units(x, y, z, p, n_e, t, m, vx, vy, vz, lvl):
            x_cen = 0.48461068
            y_cen = 0.50809848
            z_cen = 0.49687076

            x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
            y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
            z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

            # print("x_cen", x_cen, "y_cen", y_cen, "z_cen", z_cen)

            r = np.sqrt((x - x_cen) ** 2 + (y - y_cen) ** 2 + (z - z_cen) ** 2)

            # m_bar_inside_200kpc = np.sum(m[r < 200])
            # np.save("m_bar_inside_200kpc_77_bins.npy",m_bar_inside_200kpc)
            # print("m_bar within 200kpc saved")
            # sys.exit()
            # r=np.array(r)

            # n_e *= 1E6 / 0.864
            n_e /= 0.864  # np/ne = 0.864
            # plt.hist(np.log10(n_e),bins=100,range=[-3,7])
            # plt.show()
            # sys.exit()
            p /= 10
            p /= 1.602 * 10 ** (-10)
            p *= (0.76 / 0.864)
            # print("P",p)
            print("nb part", len(n_e))

            # m_no_cut = m
            # r_no_cut = r

            if t_cut == 1:
                lim = 0
                cond = np.logical_and(t > 1E5, n_e > 0)  # Standard condition
                # cond = np.logical_and(t > 1E5,np.logical_and(n_e > 0,np.logical_and(x>x_cen,np.logical_and(y>y_cen,z>z_cen)))) #Conditions for sectors study
                n_e2 = n_e[cond]
                t_2 = t[cond]
                x_2 = x[cond]
                y_2 = y[cond]
                z_2 = z[cond]
                p = p[cond]
                r = r[cond]
                m = m[cond]
                t = t[cond]
                vx = vx[cond]
                vy = vy[cond]
                vz = vz[cond]
                lvl = lvl[cond]
                n_e = n_e2
                t = t_2
                x = x_2
                y = y_2
                z = z_2

            if t_cut == 2:
                cond = np.logical_and(t > 1E7, n_e > 0)
                n_e2 = n_e[cond]
                p = p[cond]
                r = r[cond]
                m = m[cond]
                t = t[cond]
                n_e = n_e2

            print("nb part after cut", len(n_e))

            # t *= kb / 1.602e-16

            k = t / n_e ** (2 / 3)

            rho = n_e * me * 1e3

            # vx*=1e6
            # vy*=1e6
            # vz*=1e6 #comprendre pk j'avais mis *1e6 et pk ça a l'air de marcher (plutôt que *1e5 qui permettrait de passer de km/s à cm/s)

            rlog = np.log10(r)

            if log_before == 1:
                p = np.log10(p)
                t = np.log10(t)
                n_e = np.log10(n_e)
                k = np.log10(k)

            ####test for validity of method : log before sum ok ?

            # np.save("p_test.npy",p)
            # np.save("m_test.npy",m)
            # np.save("ne_test.npy",n_e)

            ####

            return x, y, z, p, n_e, t, m, rlog, k, rho, vx, vy, vz, lvl

        # start=time.time()
        x, y, z, p, n_e, t, m, rlog, k, rho, vx, vy, vz, lvl = change_units(x, y, z, p, n_e, t, m, vx, vy, vz, lvl)

        print("unit change done")

        def ne_t_hist(n_e, t, rlog):

            log_ne = np.log10(n_e)
            log_t = np.log10(t)

            log_ne_5Mpc = log_ne[rlog < 3.6989]  # r<5Mpc
            log_t_5Mpc = log_t[rlog < 3.6989]  # r<5Mpc

            log_ne_2Mpc = log_ne[rlog < 3.301]  # r<5Mpc
            log_t_2Mpc = log_t[rlog < 3.301]  # r<5Mpc

            def K_to_keV(t):
                return 10 ** t * kb / 1.6e-16

            def keV_to_K(t):
                return np.log10(t * 1.6e-16 / kb)

            # kev_pos=np.logspace(-5,1.3,10)

            kev_pos = np.array([0.01, 0.05, 0.1, 0.5, 1, 2, 4, 8, 12, 20])

            f, ax = plt.subplots(1, 1, figsize=(10, 10), constrained_layout=True)

            plt.hist2d(log_ne, log_t, bins=[100, 100], density=True, range=[[-7, -1], [3, 9]], cmap='magma_r')
            secax = ax.secondary_yaxis('right', functions=(K_to_keV, keV_to_K))
            secax.set_ylabel(r'$T~[\mathrm{keV}]$')  # , fontsize=fs)
            secax.set_yticks(kev_pos)
            # secax.tick_params(labelsize=fs)
            # plt.hist2d(log_ne_2Mpc,log_t_2Mpc, bins=[100, 100],density=True,range=[[-7,-1],[3,9]],cmap='magma_r')
            # plt.hist2d(log_ne_5Mpc, log_t_5Mpc, bins=[100, 100], density=True, range=[[-7, -1], [3, 9]], cmap='magma_r')
            plt.colorbar()
            plt.xlabel('log($n_e~[\mathrm{cm^-3}]$)')
            plt.ylabel('log($T~[\mathrm{K}]$)')
            plt.title("Density and temperature distribution in the zoom-in box")
            plt.show()

            sys.exit()

        def pos_t_hist(x, y, z, t, n_e):

            x_cen = 0.48461068
            y_cen = 0.50809848
            z_cen = 0.49687076

            x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
            y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
            z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

            x -= x_cen
            y -= y_cen
            z -= z_cen

            cond_z = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(y > -100, y < 100)))
            cond_x = np.logical_and(z > -100, np.logical_and(z < 100, np.logical_and(y > -100, y < 100)))
            cond_y = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(z > -100, z < 100)))

            log_t = np.log10(t)
            log_ne = np.log10(n_e)

            # plt.hist2d(z[cond_z],,bins=100)

            def K_to_keV(t):
                return 10 ** t * kb / 1.6e-16

            def keV_to_K(t):
                return np.log10(t * 1.6e-16 / kb)

            # kev_pos = np.linspace(0, 15, 20)
            # kev_pos = np.logspace(-5, 1.3, 10)

            kev_pos = np.array([0.01, 0.1, 0.5, 4, 20])

            f, ax = plt.subplots(2, 1, figsize=(12, 6), constrained_layout=True)

            plt.sca(ax[0])
            # plt.hist2d(x[cond_x], log_t[cond_x], bins=[200, 50], density=True, range=[[-10000, 10000], [5, 9]],cmap='inferno_r')
            plt.hist2d(y[cond_y], log_t[cond_y], bins=[200, 50], density=True, range=[[-5000, 5000], [7.5, 8.5]], cmap='inferno_r')
            # plt.hist2d(z[cond_z], log_t[cond_z], bins=[200, 50], density=True, range=[[-10000, 10000], [5, 9]],cmap='inferno_r')

            secax = ax[0].secondary_yaxis('right', functions=(K_to_keV, keV_to_K))
            secax.set_ylabel(r'$T~[\mathrm{keV}]$')  # , fontsize=fs)
            secax.set_yticks(kev_pos)
            # secax.tick_params(labelsize=fs)
            # plt.hist2d(log_ne_2Mpc,log_t_2Mpc, bins=[100, 100],density=True,range=[[-7,-1],[3,9]],cmap='magma_r')
            # plt.hist2d(log_ne_5Mpc, log_t_5Mpc, bins=[100, 100], density=True, range=[[-7, -1], [3, 9]], cmap='magma_r')
            plt.colorbar()

            # plt.xlabel('$x-x_{Virgo}~[\mathrm{kpc}]$')
            # plt.xlabel('$y-y_{Virgo}~[\mathrm{kpc}]$')
            # plt.xlabel('$z-z_{Virgo}~[\mathrm{kpc}]$')

            plt.ylabel('log($T~[\mathrm{K}]$)')

            plt.xticks([])

            # plt.title("Temperature and density distribution along the x sightline")
            plt.title("Temperature and density distribution along the y sightline")
            # plt.title("Temperature and density distribution along the z sightline")

            plt.sca(ax[1])
            # plt.hist2d(x[cond_x], log_ne[cond_x], bins=[200, 50], density=True, range=[[-10000, 10000], [-7, -1]],cmap='cividis_r')
            plt.hist2d(y[cond_y], log_ne[cond_y], bins=[200, 50], density=True, range=[[-5000, 5000], [-7, -1]], cmap='cividis_r')
            # plt.hist2d(z[cond_z], log_ne[cond_z], bins=[200, 50], density=True, range=[[-10000, 10000], [-7, -1]], cmap='cividis_r')

            # secax = ax.secondary_yaxis('right', functions=(K_to_keV, keV_to_K))
            # secax.set_ylabel(r'$T~[\mathrm{keV}]$')  # , fontsize=fs)
            # secax.set_yticks(kev_pos)
            # secax.tick_params(labelsize=fs)
            # plt.hist2d(log_ne_2Mpc,log_t_2Mpc, bins=[100, 100],density=True,range=[[-7,-1],[3,9]],cmap='magma_r')
            # plt.hist2d(log_ne_5Mpc, log_t_5Mpc, bins=[100, 100], density=True, range=[[-7, -1], [3, 9]], cmap='magma_r')
            plt.colorbar()

            # plt.xlabel('$x-x_{Virgo}~[\mathrm{kpc}]$')
            plt.xlabel('$y-y_{Virgo}~[\mathrm{kpc}]$')
            # plt.xlabel('$z-z_{Virgo}~[\mathrm{kpc}]$')

            # plt.ylabel('log($T~[\mathrm{K}]$)')
            plt.ylabel('log($n_e~[\mathrm{cm^-3}]$)')

            # plt.title("Temperature distribution along the x sightline")
            # plt.title("Temperature distribution along the y sightline")
            # plt.title("Density distribution along the z sightline")

            plt.show()

            sys.exit()

        def vlos_hist(x, y, z, vx, vy, vz, t):

            x_cen = 0.48461068
            y_cen = 0.50809848
            z_cen = 0.49687076

            x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
            y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
            z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

            x -= x_cen
            y -= y_cen
            z -= z_cen

            vx_virgo = -509.1301
            vy_virgo = 228.9488
            vz_virgo = -131.9249

            vx -= vx_virgo
            vy -= vy_virgo
            vz -= vz_virgo

            cond_z = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(y > -100, y < 100)))
            cond_x = np.logical_and(z > -100, np.logical_and(z < 100, np.logical_and(y > -100, y < 100)))
            cond_y = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(z > -100, z < 100)))
            cond_T = np.logical_and(t > 2e7, t < 1.4e8)

            cond_zT = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(y > -100, np.logical_and(y < 100, np.logical_and(t > 2e7, t < 1.4e8)))))
            # cond_xT = np.logical_and(z > -100, np.logical_and(z < 100, np.logical_and(y > -100, y < 100,np.logical_and(t > 2e7, t < 1.4e8))))
            cond_xT = np.logical_and(z > -100, np.logical_and(z < 100, np.logical_and(y > -100, np.logical_and(y < 100, np.logical_and(t > 2e7, t < 1.4e8)))))
            cond_yT = np.logical_and(x > -100, np.logical_and(x < 100, np.logical_and(z > -100, np.logical_and(z < 100, np.logical_and(t > 2e7, t < 1.4e8)))))

            # log_t = np.log10(t)
            # log_ne = np.log10(n_e)

            los_v = vy

            los_vcond = los_v[cond_y]

            los_vcondT = los_v[cond_yT]

            plt.hist(los_v, bins=100, label="Full box", alpha=0.5)
            plt.hist(los_vcond, bins=100, label="centred $100kpc^2$ y los", alpha=0.5)
            plt.hist(los_vcondT, bins=100, label="centred $100kpc^2$ y los, T in XRISM range", alpha=0.5)
            plt.legend()
            plt.title("Vy distribution along y axis")
            plt.yscale('log')
            plt.xlim(-2000, 2000)
            plt.xlabel("Vy [km/s]")
            plt.ylabel("Number of cells")

            plt.show()

            sys.exit()

        # ne_t_hist(n_e,t,rlog)

        # vlos_hist(x,y,z,vx,vy,vz,t)

        # pos_t_hist(x,y,z,t,n_e)

        # r=10**rlog
        # plt.hist2d(r,lvl,bins=[20,6],range=[[0,300],[16,21]])
        # plt.hist(lvl[r<100])

        # plt.colorbar()
        # plt.show()

        # sys.exit()

        # print("r",rlog)

        # end=time.time()
        # print("time change units",end-start)
        # sys.exit()

        # print("p",p[0:10])
        # ptest=n_e*t
        # print("n_e*T",ptest[0:10])
        # ratio=p/ptest
        # print("ratio", ratio[0:10])

        # sys.exit()

        # plt.hist2d(r,lvl,bins=[2000,8])
        # plt.colorbar()
        # plt.xscale('log')
        # plt.show()

        # print(len(rlog))
        # print(lvl)
        # print(len(lvl))

        # print("exit")
        # sys.exit()

        # t_rad = np.zeros(400)
        # ne_rad = np.zeros(400)
        # ne_rad_std = np.zeros(400)
        # p_rad = np.zeros(400)
        # m_rad = np.zeros(400)
        # n_rad = np.zeros(400)

        def normal_scale():
            for i in range(400):
                print(i)
                cond = np.logical_and(r > i * 10, r < (i + 1) * 10)
                t_sum = t[cond]
                m_sum = m[cond]
                if np.sum(m_sum) > 0:
                    t_rad[i] = np.sum(t_sum * m_sum) / np.sum(m_sum)
                else:
                    t_rad[i] = np.nan
                ne_rad[i] = np.median(n_e[cond])
                p_rad[i] = np.median(p[cond])
                # m_rad[i]=np.sum(m_sum)
                m_rad[i] = np.sum(m_no_cut[np.logical_and(r_no_cut > i * 10, r_no_cut < (i + 1) * 10)])
                n_rad[i] = len(m_sum)
                # print(n_rad)
                # nb=int(n_rad[i]*0.5)
                # print("nb",nb)
                # med=np.zeros(100)
                # if(nb>1):
                #    for j in range(100):
                #        #print(j)
                #        med[j]=np.median(resample(n_e[cond],n_samples=nb))
                #
                #        ne_rad_std[i]=np.std(med)
                #    else:
                #        ne_rad_std[i]=0

        # normal_scale()

        # print("n_e[cond]",n_e[cond])
        # nbs=resample(n_e[cond],n_samples=10)
        # print("nbs",nbs)
        # print(ne_rad_std)

        # for i in range(5,395):
        #    T_smooth[i]=np.median(t_rad[i-5:i+5])
        #    ne_smooth[i]=np.mean(ne_rad[i-10:i+10])
        #    P_smooth[i]=np.mean(p_rad[i-10:i+10])

        # for i in range(-20,50):
        #    clog=np.logical_and(rlog>i*0.1,rlog<(i+1)*0.1)
        #    t_sum_log=tlog[~clog]
        #    m_sum_log=m[~clog]
        #    p_rad_log[i+20]=np.median(plog[~clog])
        #    t_rad_log[i+20]=np.sum(t_sum_log*m_sum_log)/np.sum(m_sum_log)
        #    ne_rad_log[i+20]=np.median(ne_log[~clog])
        # @jit(nopython=True)
        def log_scale(n):
            x_cen = 0.48461068
            y_cen = 0.50809848
            z_cen = 0.49687076
            x_cen = (x_cen - 0.5) * (unit_l / 3.08567758128E21)
            y_cen = (y_cen - 0.5) * (unit_l / 3.08567758128E21)
            z_cen = (z_cen - 0.5) * (unit_l / 3.08567758128E21)

            # n = 40 #modif pr secteurs :77, 40 avant (pour 40 bins de 0.05)

            p_rad_log = np.zeros(n)
            t_rad_log = np.zeros(n)
            ne_rad_log = np.zeros(n)
            n_log = np.zeros(n)
            m_rad_log = np.zeros(n)
            err_p = np.zeros(n)
            err_ne = np.zeros(n)
            err_t = np.zeros(n)

            p_turb = np.zeros(n)
            err_pturb = np.zeros(n)

            k_rad_log = np.zeros(n)
            err_k = np.zeros(n)

            print("med_mean=", mean_med)

            ####test for validity of method : log before sum ok ?

            # p_test = np.load("p_test.npy")
            # m_test = np.load("m_test.npy")
            # n_e_test = np.load("ne_test.npy")

            # p_rad_test = np.zeros(n)
            # ne_rad_test = np.zeros(n)

            ####

            # m_cumul_ba=np.zeros(40)

            ###### modif pour secteurs:
            # n = 77
            # rlogbin_cen = np.array([10 ** ((92.5 + i) * 0.025) for i in range(n)])

            for i in range(0, n):
                print(i)

                cond = np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)
                # cond2 = np.logical_and(rlog < (i + 36) * 0.05, x < x_cen)
                # cond = np.logical_and(rlog > (i + 35) * 0.05, np.logical_and(rlog < (i + 36) * 0.05, x < x_cen))

                # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y > y_cen,z > z_cen)))) #Sector 8 = Spherical Collapse
                # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x < x_cen,np.logical_and(y < y_cen,z < z_cen))))  # Sector 1 = Relaxed
                # cond = np.logical_and(rlog > (i + 92) * 0.025, np.logical_and(rlog < (i + 93) * 0.025,np.logical_and(x > x_cen,np.logical_and(y < y_cen, z < z_cen))))  # Sector 5 = Filament

                # cond = np.logical_and(rlog > (i + 92) * 0.025, rlog < (i + 93) * 0.025) #Full box

                m_sum_log = m[cond]
                # rlim = 10 ** ((35.5 + i) * 0.05)
                # print(i, 'rlim ', rlim)
                # rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
                # m_cumul_ba[i] = np.sum(m[r < rlim])

                # print('test')
                if mean_med == 1:
                    # print('test 1')
                    p_sum_log = p[cond]
                    ne_sum_log = n_e[cond]
                    t_sum_log = t[cond]
                    k_sum_log = k[cond]

                    # print('test 1.5')
                    # print("msumlog",m_sum_log)
                    # print("psumlog",p_sum_log)
                    p_rad_log[i] = np.sum(p_sum_log * m_sum_log) / np.sum(m_sum_log)
                    # print('test 2')
                    ne_rad_log[i] = np.sum(ne_sum_log * m_sum_log) / np.sum(m_sum_log)
                    # print('test 3')
                    t_rad_log[i] = np.sum(t_sum_log * m_sum_log) / np.sum(m_sum_log)
                    # print('test 4')
                    err_ne[i] = np.sqrt(np.sum(m_sum_log * (ne_sum_log - ne_rad_log[i]) ** 2) / np.sum(m_sum_log))
                    err_t[i] = np.sqrt(np.sum(m_sum_log * (t_sum_log - t_rad_log[i]) ** 2) / np.sum(m_sum_log))
                    err_p[i] = np.sqrt(np.sum(m_sum_log * (p_sum_log - p_rad_log[i]) ** 2) / np.sum(m_sum_log))

                    k_rad_log[i] = np.sum(k_sum_log * m_sum_log) / np.sum(m_sum_log)
                    err_k[i] = np.sqrt(np.sum(m_sum_log * (k_sum_log - k_rad_log[i]) ** 2) / np.sum(m_sum_log))

                    vxmean = np.mean(vx[cond])
                    vymean = np.mean(vy[cond])
                    vzmean = np.mean(vz[cond])
                    sigmax = np.sum(m_sum_log * (vx[cond] - vxmean) ** 2) / np.sum(m_sum_log)
                    sigmay = np.sum(m_sum_log * (vy[cond] - vymean) ** 2) / np.sum(m_sum_log)
                    sigmaz = np.sum(m_sum_log * (vz[cond] - vzmean) ** 2) / np.sum(m_sum_log)
                    sigmatot = sigmax + sigmay + sigmaz
                    rhomean = np.sum(rho[cond] * m_sum_log) / np.sum(m_sum_log)

                    p_turb[i] = rhomean * sigmatot

                    ####test for validity of method : log before sum ok ?

                    # m_sum_test = m_test[cond]
                    # p_sum_test = p_test[cond]

                    # p_rad_test[i] = np.sum(p_sum_test * m_sum_test) / np.sum(m_sum_test)
                    # ne_rad_test[i] = np.sum(n_e_test[cond] * m_sum_test) / np.sum(m_sum_test)

                    ###

                elif (mean_med == 2):
                    p_sum_log = p[cond]
                    ne_sum_log = n_e[cond]
                    t_sum_log = t[cond]
                    k_sum_log = k[cond]

                    t_rad_log[i] = np.median(t_sum_log)
                    p_rad_log[i] = np.median(p_sum_log)
                    ne_rad_log[i] = np.median(ne_sum_log)
                    k_rad_log[i] = np.median(k_sum_log)

                    err_ne[i] = np.median(np.abs(ne_sum_log - ne_rad_log[i]))
                    err_p[i] = np.median(np.abs(p_sum_log - p_rad_log[i]))
                    err_t[i] = np.median(np.abs(t_sum_log - t_rad_log[i]))
                    err_k[i] = np.median(np.abs(k_sum_log - k_rad_log[i]))

                else:
                    print('test 0')
                    p_rad_log[i] = np.median(plog[cond])
                    ne_rad_log[i] = np.median(ne_log[cond])

                    t_sum_log = tlog[cond]
                    t_rad_log[i] = np.sum(t_sum_log * m_sum_log) / np.sum(m_sum_log)

                    err_ne[i] = np.median(np.abs(ne_log[cond] - ne_rad_log[i]))
                    err_p[i] = np.median(np.abs(plog[cond] - p_rad_log[i]))
                    err_t[i] = np.sqrt(np.sum(m_sum_log * (t_sum_log - t_rad_log[i]) ** 2) / np.sum(m_sum_log))
                n_log[i] = len(m_sum_log)
                m_rad_log[i] = np.sum(m_sum_log)
                print(len(m_sum_log))

            # print("msumbar", m_cumul_ba)
            # np.save("m_cumul_ba.npy", m_cumul_ba)

            # sys.exit()

            # print("p_turb", p_turb)

            p_turb /= 10
            p_turb /= 1.602 * 10 ** (-10)
            p_turb = np.log10(p_turb)
            # print("p_turb log", p_turb)

            if log_before == 0:
                err_p = err_p / (np.log(10) * p_rad_log)
                err_t = err_t / (np.log(10) * t_rad_log)
                err_ne = err_ne / (np.log(10) * ne_rad_log)
                err_k = err_k / (np.log(10) * k_rad_log)
                p_rad_log = np.log10(p_rad_log)
                t_rad_log = np.log10(t_rad_log)
                ne_rad_log = np.log10(ne_rad_log)
                k_rad_log = np.log10(k_rad_log)

            def save_data_sectors(file, n):
                rad_data = np.zeros((10, n))
                rad_data[0, :] = p_rad_log
                rad_data[1, :] = err_p
                rad_data[2, :] = ne_rad_log
                rad_data[3, :] = err_ne
                rad_data[4, :] = t_rad_log
                rad_data[5, :] = err_t
                rad_data[6, :] = k_rad_log
                rad_data[7, :] = err_k
                rad_data[8, :] = m_rad_log
                rad_data[9, :] = n_log

                np.save(file, rad_data)
                print("data saved")
                sys.exit()

            # save_data_sectors("./sectors_study/splashback/lograd_profs_h_all_77_med_before_log.npy",77)

            ##plt.scatter(rlogbin_cen, p_rad_log, s=6, c='green')  # , c='blue')
            # plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_p, ls='dotted', label='sector 1', alpha=0.7, c='green')  # , c='blue')

            ##Test for method validity

            # print("p_rad_log",p_rad_log)

            # p_rad_test = np.log10(p_rad_test)
            # ne_rad_test = np.log10(ne_rad_test)

            # print("p_rad_test", p_rad_test)

            # np.save('p_rad_test.npy',p_rad_test)
            # np.save('ne_rad_test.npy',ne_rad_test)

            # print("test profs saved")
            # sys.exit()

            # plt.plot(rlogbin_cen, p_rad_log, ls='dotted', label='original method', alpha=0.7, c='green')# , c='blue')
            # plt.plot(rlogbin_cen, p_rad_test, ls='dotted', label='test', alpha=0.7, c='blue')
            # plt.xscale("log")
            # plt.legend()
            # plt.axvline(x=1087, color='grey')
            # plt.text(1087, -7, "$\mathrm{R_{500}}$", rotation=90, size=16)
            # plt.axvline(x=2147, color='grey', ls='dashed')
            # plt.text(2147, -7, "$\mathrm{R_{vir}}$", rotation=90, size=16)

            # plt.show()

            # sys.exit()

            return p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_ne, err_p, err_t, err_k, p_turb

        def test():
            p_rad_log = np.array(
                [np.median(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
            ne_rad_log = np.array(
                [np.median(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
            n_log = np.array([len(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
            m_rad_log = np.array(
                [np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])
            t_rad_log = np.array([np.sum(tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * m[
                np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) / np.sum(
                m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)]) for i in range(40)])

            mad_ne_log = np.array(
                [np.median(np.abs(ne_log[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - ne_rad_log[i]))
                 for i in range(40)])
            mad_plog = np.array(
                [np.median(np.abs(plog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - p_rad_log[i])) for
                 i in range(40)])
            w_std_plog = np.array([np.sqrt(np.sum(m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] * (
                    tlog[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)] - t_rad_log[i]) ** 2) / np.sum(
                m[np.logical_and(rlog > (i + 35) * 0.05, rlog < (i + 36) * 0.05)])) for i in range(40)])

            return p_rad_log, t_rad_log, ne_rad_log, m_rad_log, n_log, mad_ne_log, mad_plog, w_std_plog

        # start=time.time()
        p_rad_log, t_rad_log, ne_rad_log, k_rad_log, m_rad_log, n_log, err_nelog, err_plog, err_tlog, err_klog, p_turb = log_scale(n)

        print("p_rad_log", p_rad_log)
        # sys.exit()

        rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])
        print('rlogbin_cen',rlogbin_cen)
        print("p_rad_log[25]",p_rad_log[25],"r",rlogbin_cen[25])
        #ptot = 10 ** p_rad_log + 10 ** p_turb
        #alpha = (10 ** p_turb) / ptot
        #cond=np.logical_and(rlog>np.log10(1067),rlog<np.log10(1107))
        #P500=np.mean(p[cond])
        P500=np.sum(p[10**rlog<1087]*m[10**rlog<1087])/np.sum(m[10**rlog<1087])
        #print(len(p[cond]))
        print("P500",P500)
        T500 = np.sum(t[10 ** rlog < 1087] * m[10 ** rlog < 1087]) / np.sum(m[10 ** rlog < 1087])
        # print(len(p[cond]))
        print("T500", T500)
        ne500 = np.sum(n_e[10 ** rlog < 1087] * m[10 ** rlog < 1087]) / np.sum(m[10 ** rlog < 1087])
        # print(len(p[cond]))
        print("ne500", ne500)
        print("P500=ne500*k_b*T500",ne500*kb*(T500/1.602e-16))
        sys.exit()

        #sys.exit()
        # plt.scatter(rlogbin_cen,p_rad_log,s=6, c='orange')
        # plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted', label='$8192^3$', alpha=0.7, c='orange')
        # plt.xscale('log')
        # plt.show()
        # np.save("alpha.npy",alpha)
        # sys.exit()

        # end=time.time()
        # print("durée:",end-start)

        # rratio=rlogbin_cen/1087
        # krad=np.array([10**k_rad_log[i] for i in range(len(k_rad_log))])

        # rad_data = np.zeros((2, 40))
        # rad_data[0,:]=krad
        # rad_data[1,:]=krad*err_klog
        # np.save("K_prof_high",rad_data)

        # plt.plot(rratio,10**p_turb/(10**p_rad_log))
        # plt.scatter(rlogbin_cen, krad, s=6, c='green',label='Entropy')
        # plt.errorbar(rlogbin_cen, krad, yerr=krad*err_klog, ls='dotted', label='3D, 8192^3', alpha=0.7, c='orange')
        # plt.scatter(rlogbin_cen, p_rad_log, s=6, c='orange')
        # plt.errorbar(rlogbin_cen, p_rad_log, yerr=err_plog, ls='dotted',label='Rescaled data (lvl=15, low res)', alpha=0.7, c='orange')
        # plt.scatter(rlogbin_cen,np.log10(10**p_rad_log+10**p_turb),label='P_tot',s=6,c='blue')
        # plt.xscale('log')
        # plt.yscale('log')
        # plt.yscale('log')
        # plt.axvline(x=1087, color='grey')
        # plt.text(1087, 2.75, "$R_{500}$", rotation=90, size=16)
        # plt.axvline(x=2147, color='grey', ls='dashed')
        # plt.text(2147, 2.75, "$R_{vir}$", rotation=90, size=16)
        # plt.xlabel("R(kpc)", size=16)
        # plt.ylabel('$log_{10}(K[keV.cm^{2}])$')
        # plt.ylabel("$log_{10}(P[keV/cm^3])$", size=16)
        # plt.legend(prop={'size': 16})
        # plt.show()

        # sys.exit()

        # return t_rad, ne_rad, p_rad, m_rad, n_rad, p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, ne_rad_std, mad_ne_log, mad_plog, w_std_plog
        return p_rad_log, t_rad_log, ne_rad_log, n_log, m_rad_log, err_nelog, err_plog, err_tlog,

    #Plogmean, Tlogmean, nelogmean, nlog, mlog, nestdlogmean, Pstdlogmean, Tstdlogmean = hydro("/data/cluster/tlebeau/virgo/virgo_xyz_files/virgo_xyz_hydro_l21.dat", 1, 1, 0, 40)

    #np.save("P_prof_l21.npy",Plogmean)
    Plogmean=np.load("P_prof_l21.npy")
    #np.save("ne_prof_l21.npy", nelogmean)
    nelogmean = np.load("ne_prof_l21.npy")
    #np.save("T_prof_l21.npy", Tlogmean)
    Tlogmean = np.load("T_prof_l21.npy")
    rlogbin_cen = np.array([10 ** ((35.5 + i) * 0.05) for i in range(40)])

    def press_plot(Plogmean):
        p500_1=1.66e-3
        p500_2=3.652e-3
        Plogmean_1=10**Plogmean/p500_1
        Plogmean_2 = 10 ** Plogmean / p500_2
        #print("Plogmean",Plogmean)
        #sys.exit()
        r500=1087
        rbin=rlogbin_cen/r500
        n=40
        p13 = [upplog(rbin[i], 6.41, 1.81, 1.33, 4.13, 0.31) for i in range(0, n)]
        a10 = [upp(rlogbin_cen[i]/r500, 8.40, 1.18, 1.05, 5.49, 0.31) for i in range(0, n)]
        p7 = [upp(rlogbin_cen[i]/r500, 3.36, 1.18, 1.08, 4.30, 0.31) for i in range(0, n)]
        a85p = [upp(rlogbin_cen[i]/r500, 5.99, 0.02, 0.48, 14.97, 0.31) for i in range(0, n)]
        ghir19 = [upp(rlogbin_cen[i] / r500, 5.68,1.49,1.33,4.05,0.29) for i in range(0, n)]



        plt.plot(rlogbin_cen / r500, Plogmean_1,label=r'Virgo, $P_{500}=3.65\times 10^{-3}~keV~cm^{-3}$'+ '\n (mass-w pressure within $R_{500}$)',marker='.',color='black')
        plt.plot(rlogbin_cen / r500, Plogmean_2, label=r'Virgo, $P_{500}=1.66e\times 10^{-3}~keV~cm^{-3}$' +'\n (Ghirardini+19 scaling relation)', marker='.',color='grey')
        plt.plot(rlogbin_cen / r500, ghir19, label='Ghirardini+ 19', color='red')
        plt.plot(rlogbin_cen / r500, a10, label='Arnaud+ 10', color='blue')
        # plt.plot(rlogbin_cen / r500, p13,label='Planck+ 13')
        plt.plot(rlogbin_cen / r500, p7, label='PACT 21', color='forestgreen')

        plt.xscale('log')
        plt.yscale('log')
        plt.legend()
        plt.xlabel('$R/R_{500}$')
        plt.ylabel('$P/P_{500}$')
        #plt.title("$P_{500}=3.65e-3~keV~cm^{-3}$ (mass-weighted pressure within $R_{500}$)")
        #plt.title("$P_{500}=1.66e-3~keV~cm^{-3}$ (Ghirardini+19 scaling relation )")
        plt.title("Normalized pressure radial profiles")
        plt.show()
        sys.exit()

    def den_plot():

        def n_model(x, n0, a, b, c, e, rc, rs):  # ,n02,b2,rc2):
            return (n0 ** 2 * (x / rc) ** (-a)) / ((1 + (x / rc) ** 2) ** (3 * b - a / 2) * (1 + (x / rs) ** c) ** (
                    e / c))  # +n02**2/((1+(x/rc)**2)**(3*b2))
        r500=1087
        rbin=rlogbin_cen/r500
        n=40
        #print('test',10**(-4.4),10**(-0.29),1e-3)
        #sys.exit()
        ghir = [n_model(rbin[i], np.exp(-4.4), 0.89, 0.43, 3, 2.86, np.exp(-3), np.exp(-0.29)) for i in range(0, n)]
        #ghir_high = [n_model(rbin[i], np.exp(-4.4+0.5), 0.89+0.59, 0.43+0.02, 3, 2.86+0.38, np.exp(-3+0.5), np.exp(-0.29+01.5)) for i in range(0, n)]
        #ghir_low = [n_model(rbin[i], np.exp(-4.4 - 0.5), 0.89 - 0.59, 0.43 - 0.02, 3, 2.86 - 0.38, np.exp(-3 - 0.5), np.exp(-0.29 - 01.5)) for i in range(0, n)]


        plt.plot(rlogbin_cen/r500,10**nelogmean,label='Virgo',marker='.',color='black')
        plt.plot(rlogbin_cen/r500,np.sqrt(ghir),label='Ghirardini+ 19 (best fit of Vikhlinin+ 06 model)',color='red')
        #plt.fill_between(rlogbin_cen/r500,np.sqrt(ghir_low),np.sqrt(ghir_high),alpha=0.3,color="red")
        plt.xscale('log')
        plt.yscale('log')
        plt.legend()
        plt.xlabel('$R/R_{500}$')
        plt.ylabel('$n_e~[cm^{-3}]$')
        plt.title('Electron density radial profiles')
        #plt.title("$P_{500}=3.65e-3~keV~cm^{-3}$ (mass-weighted pressure within $R_{500}$)")
        #plt.title("$P_{500}=1.66e-3~keV~cm^{-3}$ (Ghirardini+19 scaling relation )")
        plt.show()
        sys.exit()

    def Temp_plot(Tlogmean):

        def T_model(r, t0, a, acool, b, c, rt, rcool, tau):
            x = (r / rcool) ** acool
            rsrt = r / rt
            return t0 * ((x + tau) / (x + 1)) * (rsrt ** (-a) / (1 + rsrt ** b) ** (c / b))

        r500 = 1087
        rbin = rlogbin_cen / r500
        n = 40
        #T500=4.277
        print('Tlogmean',Tlogmean)
        T500_1=4.277
        Tlogmean_1 = (10 ** Tlogmean*(kb/1.602e-16)) / T500_1
        T500_2=6.095
        Tlogmean_2 = (10 ** Tlogmean * (kb / 1.602e-16)) / T500_2
        # print('test',10**(-4.4),10**(-0.29),1e-3)
        # sys.exit()
        ghir = [T_model(rbin[i], 1.21, 0, 1.03, 2, 2*0.27, 0.34,np.exp(-2.8),0.5 ) for i in range(0, n)]
        # ghir_high = [n_model(rbin[i], np.exp(-4.4+0.5), 0.89+0.59, 0.43+0.02, 3, 2.86+0.38, np.exp(-3+0.5), np.exp(-0.29+01.5)) for i in range(0, n)]
        # ghir_low = [n_model(rbin[i], np.exp(-4.4 - 0.5), 0.89 - 0.59, 0.43 - 0.02, 3, 2.86 - 0.38, np.exp(-3 - 0.5), np.exp(-0.29 - 01.5)) for i in range(0, n)]

        plt.plot(rlogbin_cen / r500, Tlogmean_1, label='Virgo, $T_{500}=6.095~keV$' + '\n (mass-weighted temperature within $R_{500}$)', marker='.',color='black')
        plt.plot(rlogbin_cen / r500, Tlogmean_2, label='Virgo, $T_{500}=4.277~keV$' + '\n (Ghirardini+19 scaling relation)', marker='.',color='grey')
        plt.plot(rlogbin_cen / r500, ghir, label='Ghirardini+ 19 (best fit of Vikhlinin+ 06 model)', color='red')
        # plt.fill_between(rlogbin_cen/r500,np.sqrt(ghir_low),np.sqrt(ghir_high),alpha=0.3,color="red")
        plt.xscale('log')
        plt.yscale('log')
        plt.legend()
        plt.xlabel('$R/R_{500}$')
        plt.ylabel('$T/T_{500}$')
        #plt.title("$T_{500}=6.095~keV$ (mass-weighted temperature within $R_{500}$)")
        #plt.title("$T_{500}=4.277~keV$ (Ghirardini+19 scaling relation)")
        plt.title("Normalized temperature radial profiles")
        plt.show()
        sys.exit()


    #press_plot(Plogmean)
    #den_plot()
    Temp_plot(Tlogmean)

# Large sims routines

def create_namelist():
    
    halo_list = np.loadtxt("/data/cluster/byopic/SIMS/VirgoClone/list_halo_251.dat_js_nocontam")

    print(halo_list)

    sys.exit()